// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`crud should properly generate actions resolver classes for prisma model: CreateManyAndReturnUserResolver 1`] = `
"import { Args, ArgsType, Context, Field, Float, ID, Info, InputType, Int, Mutation, ObjectType, Parent, Query, ResolveField, Resolver, registerEnumType } from \\"@nestjs/graphql\\";
import type { GraphQLResolveInfo } from \\"graphql\\";
import { CreateManyAndReturnUserArgs } from \\"./args/CreateManyAndReturnUserArgs\\";
import { User } from \\"../../../models/User\\";
import { CreateManyAndReturnUser } from \\"../../outputs/CreateManyAndReturnUser\\";
import { transformArgsIntoPrismaArgs, transformInfoIntoPrismaArgs, getPrismaFromContext, transformCountFieldIntoSelectRelationsCount, InlineLoader } from \\"../../../helpers\\";

@Resolver(() => User)
export class CreateManyAndReturnUserResolver {
  @Mutation(() => [CreateManyAndReturnUser], {
    nullable: false
  })
  async createManyAndReturnUser(@Context() ctx: any, @Info() info: GraphQLResolveInfo, @Args() args: CreateManyAndReturnUserArgs): Promise<CreateManyAndReturnUser[]> {
    const afterProcessEvents: ((result: any) => Promise<any>)[] = [];
    const { _count } = transformInfoIntoPrismaArgs(info, 'User', 'user', 'createManyAndReturn');
    const transformedArgsIntoPrismaArgs = await transformArgsIntoPrismaArgs(info, args, ctx, 'User', 'user', 'createManyAndReturn', afterProcessEvents);
    const otherArgs = _count && transformCountFieldIntoSelectRelationsCount(_count, 'User', 'user', 'createManyAndReturn');
    const result = await getPrismaFromContext(ctx).user.createManyAndReturn({ ...transformedArgsIntoPrismaArgs, ...otherArgs, });
    for (const afterProcessEvent of afterProcessEvents) { await afterProcessEvent(result); }

    return result;
  }
}
"
`;

exports[`crud should properly generate actions resolver classes for prisma model: CreateManyUserResolver 1`] = `
"import { Args, ArgsType, Context, Field, Float, ID, Info, InputType, Int, Mutation, ObjectType, Parent, Query, ResolveField, Resolver, registerEnumType } from \\"@nestjs/graphql\\";
import type { GraphQLResolveInfo } from \\"graphql\\";
import { CreateManyUserArgs } from \\"./args/CreateManyUserArgs\\";
import { User } from \\"../../../models/User\\";
import { AffectedRowsOutput } from \\"../../outputs/AffectedRowsOutput\\";
import { transformArgsIntoPrismaArgs, transformInfoIntoPrismaArgs, getPrismaFromContext, transformCountFieldIntoSelectRelationsCount, InlineLoader } from \\"../../../helpers\\";

@Resolver(() => User)
export class CreateManyUserResolver {
  @Mutation(() => AffectedRowsOutput, {
    nullable: false
  })
  async createManyUser(@Context() ctx: any, @Info() info: GraphQLResolveInfo, @Args() args: CreateManyUserArgs): Promise<AffectedRowsOutput> {
    const afterProcessEvents: ((result: any) => Promise<any>)[] = [];
    const { _count } = transformInfoIntoPrismaArgs(info, 'User', 'user', 'createMany');
    const transformedArgsIntoPrismaArgs = await transformArgsIntoPrismaArgs(info, args, ctx, 'User', 'user', 'createMany', afterProcessEvents);
    const otherArgs = _count && transformCountFieldIntoSelectRelationsCount(_count, 'User', 'user', 'createMany');
    const result = await getPrismaFromContext(ctx).user.createMany({ ...transformedArgsIntoPrismaArgs, ...otherArgs, });
    for (const afterProcessEvent of afterProcessEvents) { await afterProcessEvent(result); }

    return result;
  }
}
"
`;

exports[`crud should properly generate actions resolver classes for prisma model: CreateOneUserResolver 1`] = `
"import { Args, ArgsType, Context, Field, Float, ID, Info, InputType, Int, Mutation, ObjectType, Parent, Query, ResolveField, Resolver, registerEnumType } from \\"@nestjs/graphql\\";
import type { GraphQLResolveInfo } from \\"graphql\\";
import { CreateOneUserArgs } from \\"./args/CreateOneUserArgs\\";
import { User } from \\"../../../models/User\\";
import { transformArgsIntoPrismaArgs, transformInfoIntoPrismaArgs, getPrismaFromContext, transformCountFieldIntoSelectRelationsCount, InlineLoader } from \\"../../../helpers\\";

@Resolver(() => User)
export class CreateOneUserResolver {
  @Mutation(() => User, {
    nullable: false
  })
  async createOneUser(@Context() ctx: any, @Info() info: GraphQLResolveInfo, @Args() args: CreateOneUserArgs): Promise<User> {
    const afterProcessEvents: ((result: any) => Promise<any>)[] = [];
    const { _count } = transformInfoIntoPrismaArgs(info, 'User', 'user', 'create');
    const transformedArgsIntoPrismaArgs = await transformArgsIntoPrismaArgs(info, args, ctx, 'User', 'user', 'create', afterProcessEvents);
    const otherArgs = _count && transformCountFieldIntoSelectRelationsCount(_count, 'User', 'user', 'create');
    const result = await getPrismaFromContext(ctx).user.create({ ...transformedArgsIntoPrismaArgs, ...otherArgs, });
    for (const afterProcessEvent of afterProcessEvents) { await afterProcessEvent(result); }

    return result;
  }
}
"
`;

exports[`crud should properly generate actions resolver classes for prisma model: DeleteManyUserResolver 1`] = `
"import { Args, ArgsType, Context, Field, Float, ID, Info, InputType, Int, Mutation, ObjectType, Parent, Query, ResolveField, Resolver, registerEnumType } from \\"@nestjs/graphql\\";
import type { GraphQLResolveInfo } from \\"graphql\\";
import { DeleteManyUserArgs } from \\"./args/DeleteManyUserArgs\\";
import { User } from \\"../../../models/User\\";
import { AffectedRowsOutput } from \\"../../outputs/AffectedRowsOutput\\";
import { transformArgsIntoPrismaArgs, transformInfoIntoPrismaArgs, getPrismaFromContext, transformCountFieldIntoSelectRelationsCount, InlineLoader } from \\"../../../helpers\\";

@Resolver(() => User)
export class DeleteManyUserResolver {
  @Mutation(() => AffectedRowsOutput, {
    nullable: false
  })
  async deleteManyUser(@Context() ctx: any, @Info() info: GraphQLResolveInfo, @Args() args: DeleteManyUserArgs): Promise<AffectedRowsOutput> {
    const afterProcessEvents: ((result: any) => Promise<any>)[] = [];
    const { _count } = transformInfoIntoPrismaArgs(info, 'User', 'user', 'deleteMany');
    const transformedArgsIntoPrismaArgs = await transformArgsIntoPrismaArgs(info, args, ctx, 'User', 'user', 'deleteMany', afterProcessEvents);
    const otherArgs = _count && transformCountFieldIntoSelectRelationsCount(_count, 'User', 'user', 'deleteMany');
    const result = await getPrismaFromContext(ctx).user.deleteMany({ ...transformedArgsIntoPrismaArgs, ...otherArgs, });
    for (const afterProcessEvent of afterProcessEvents) { await afterProcessEvent(result); }

    return result;
  }
}
"
`;

exports[`crud should properly generate actions resolver classes for prisma model: DeleteOneUserResolver 1`] = `
"import { Args, ArgsType, Context, Field, Float, ID, Info, InputType, Int, Mutation, ObjectType, Parent, Query, ResolveField, Resolver, registerEnumType } from \\"@nestjs/graphql\\";
import type { GraphQLResolveInfo } from \\"graphql\\";
import { DeleteOneUserArgs } from \\"./args/DeleteOneUserArgs\\";
import { User } from \\"../../../models/User\\";
import { transformArgsIntoPrismaArgs, transformInfoIntoPrismaArgs, getPrismaFromContext, transformCountFieldIntoSelectRelationsCount, InlineLoader } from \\"../../../helpers\\";

@Resolver(() => User)
export class DeleteOneUserResolver {
  @Mutation(() => User, {
    nullable: true
  })
  async deleteOneUser(@Context() ctx: any, @Info() info: GraphQLResolveInfo, @Args() args: DeleteOneUserArgs): Promise<User | null> {
    const afterProcessEvents: ((result: any) => Promise<any>)[] = [];
    const { _count } = transformInfoIntoPrismaArgs(info, 'User', 'user', 'delete');
    const transformedArgsIntoPrismaArgs = await transformArgsIntoPrismaArgs(info, args, ctx, 'User', 'user', 'delete', afterProcessEvents);
    const otherArgs = _count && transformCountFieldIntoSelectRelationsCount(_count, 'User', 'user', 'delete');
    const result = await getPrismaFromContext(ctx).user.delete({ ...transformedArgsIntoPrismaArgs, ...otherArgs, });
    for (const afterProcessEvent of afterProcessEvents) { await afterProcessEvent(result); }

    return result;
  }
}
"
`;

exports[`crud should properly generate actions resolver classes for prisma model: FindFirstUserOrThrowResolver 1`] = `
"import { Args, ArgsType, Context, Field, Float, ID, Info, InputType, Int, Mutation, ObjectType, Parent, Query, ResolveField, Resolver, registerEnumType } from \\"@nestjs/graphql\\";
import type { GraphQLResolveInfo } from \\"graphql\\";
import { FindFirstUserOrThrowArgs } from \\"./args/FindFirstUserOrThrowArgs\\";
import { User } from \\"../../../models/User\\";
import { transformArgsIntoPrismaArgs, transformInfoIntoPrismaArgs, getPrismaFromContext, transformCountFieldIntoSelectRelationsCount, InlineLoader } from \\"../../../helpers\\";

@Resolver(() => User)
export class FindFirstUserOrThrowResolver {
  @Query(() => User, {
    nullable: true
  })
  async findFirstUserOrThrow(@Context() ctx: any, @Info() info: GraphQLResolveInfo, @Args() args: FindFirstUserOrThrowArgs): Promise<User | null> {
    const afterProcessEvents: ((result: any) => Promise<any>)[] = [];
    const { _count } = transformInfoIntoPrismaArgs(info, 'User', 'user', 'findFirstOrThrow');
    const transformedArgsIntoPrismaArgs = await transformArgsIntoPrismaArgs(info, args, ctx, 'User', 'user', 'findFirstOrThrow', afterProcessEvents);
    const otherArgs = _count && transformCountFieldIntoSelectRelationsCount(_count, 'User', 'user', 'findFirstOrThrow');
    const result = await getPrismaFromContext(ctx).user.findFirstOrThrow({ ...transformedArgsIntoPrismaArgs, ...otherArgs, });
    for (const afterProcessEvent of afterProcessEvents) { await afterProcessEvent(result); }

    return result;
  }
}
"
`;

exports[`crud should properly generate actions resolver classes for prisma model: FindFirstUserResolver 1`] = `
"import { Args, ArgsType, Context, Field, Float, ID, Info, InputType, Int, Mutation, ObjectType, Parent, Query, ResolveField, Resolver, registerEnumType } from \\"@nestjs/graphql\\";
import type { GraphQLResolveInfo } from \\"graphql\\";
import { FindFirstUserArgs } from \\"./args/FindFirstUserArgs\\";
import { User } from \\"../../../models/User\\";
import { transformArgsIntoPrismaArgs, transformInfoIntoPrismaArgs, getPrismaFromContext, transformCountFieldIntoSelectRelationsCount, InlineLoader } from \\"../../../helpers\\";

@Resolver(() => User)
export class FindFirstUserResolver {
  @Query(() => User, {
    nullable: true
  })
  async findFirstUser(@Context() ctx: any, @Info() info: GraphQLResolveInfo, @Args() args: FindFirstUserArgs): Promise<User | null> {
    const afterProcessEvents: ((result: any) => Promise<any>)[] = [];
    const { _count } = transformInfoIntoPrismaArgs(info, 'User', 'user', 'findFirst');
    const transformedArgsIntoPrismaArgs = await transformArgsIntoPrismaArgs(info, args, ctx, 'User', 'user', 'findFirst', afterProcessEvents);
    const otherArgs = _count && transformCountFieldIntoSelectRelationsCount(_count, 'User', 'user', 'findFirst');
    const result = await getPrismaFromContext(ctx).user.findFirst({ ...transformedArgsIntoPrismaArgs, ...otherArgs, });
    for (const afterProcessEvent of afterProcessEvents) { await afterProcessEvent(result); }

    return result;
  }
}
"
`;

exports[`crud should properly generate actions resolver classes for prisma model: FindManyUserResolver 1`] = `
"import { Args, ArgsType, Context, Field, Float, ID, Info, InputType, Int, Mutation, ObjectType, Parent, Query, ResolveField, Resolver, registerEnumType } from \\"@nestjs/graphql\\";
import type { GraphQLResolveInfo } from \\"graphql\\";
import { FindManyUserArgs } from \\"./args/FindManyUserArgs\\";
import { User } from \\"../../../models/User\\";
import { transformArgsIntoPrismaArgs, transformInfoIntoPrismaArgs, getPrismaFromContext, transformCountFieldIntoSelectRelationsCount, InlineLoader } from \\"../../../helpers\\";

@Resolver(() => User)
export class FindManyUserResolver {
  @Query(() => [User], {
    nullable: false
  })
  async users(@Context() ctx: any, @Info() info: GraphQLResolveInfo, @Args() args: FindManyUserArgs): Promise<User[]> {
    const afterProcessEvents: ((result: any) => Promise<any>)[] = [];
    const { _count } = transformInfoIntoPrismaArgs(info, 'User', 'user', 'findMany');
    const transformedArgsIntoPrismaArgs = await transformArgsIntoPrismaArgs(info, args, ctx, 'User', 'user', 'findMany', afterProcessEvents);
    const otherArgs = _count && transformCountFieldIntoSelectRelationsCount(_count, 'User', 'user', 'findMany');
    const result = await getPrismaFromContext(ctx).user.findMany({ ...transformedArgsIntoPrismaArgs, ...otherArgs, });
    for (const afterProcessEvent of afterProcessEvents) { await afterProcessEvent(result); }

    return result;
  }
}
"
`;

exports[`crud should properly generate actions resolver classes for prisma model: FindUniqueUserOrThrowResolver 1`] = `
"import { Args, ArgsType, Context, Field, Float, ID, Info, InputType, Int, Mutation, ObjectType, Parent, Query, ResolveField, Resolver, registerEnumType } from \\"@nestjs/graphql\\";
import type { GraphQLResolveInfo } from \\"graphql\\";
import { FindUniqueUserOrThrowArgs } from \\"./args/FindUniqueUserOrThrowArgs\\";
import { User } from \\"../../../models/User\\";
import { transformArgsIntoPrismaArgs, transformInfoIntoPrismaArgs, getPrismaFromContext, transformCountFieldIntoSelectRelationsCount, InlineLoader } from \\"../../../helpers\\";

@Resolver(() => User)
export class FindUniqueUserOrThrowResolver {
  @Query(() => User, {
    nullable: true
  })
  async getUser(@Context() ctx: any, @Info() info: GraphQLResolveInfo, @Args() args: FindUniqueUserOrThrowArgs): Promise<User | null> {
    const afterProcessEvents: ((result: any) => Promise<any>)[] = [];
    const { _count } = transformInfoIntoPrismaArgs(info, 'User', 'user', 'findUniqueOrThrow');
    const transformedArgsIntoPrismaArgs = await transformArgsIntoPrismaArgs(info, args, ctx, 'User', 'user', 'findUniqueOrThrow', afterProcessEvents);
    const otherArgs = _count && transformCountFieldIntoSelectRelationsCount(_count, 'User', 'user', 'findUniqueOrThrow');
    const result = await getPrismaFromContext(ctx).user.findUniqueOrThrow({ ...transformedArgsIntoPrismaArgs, ...otherArgs, });
    for (const afterProcessEvent of afterProcessEvents) { await afterProcessEvent(result); }

    return result;
  }
}
"
`;

exports[`crud should properly generate actions resolver classes for prisma model: FindUniqueUserResolver 1`] = `
"import { Args, ArgsType, Context, Field, Float, ID, Info, InputType, Int, Mutation, ObjectType, Parent, Query, ResolveField, Resolver, registerEnumType } from \\"@nestjs/graphql\\";
import type { GraphQLResolveInfo } from \\"graphql\\";
import { FindUniqueUserArgs } from \\"./args/FindUniqueUserArgs\\";
import { User } from \\"../../../models/User\\";
import { transformArgsIntoPrismaArgs, transformInfoIntoPrismaArgs, getPrismaFromContext, transformCountFieldIntoSelectRelationsCount, InlineLoader } from \\"../../../helpers\\";

@Resolver(() => User)
export class FindUniqueUserResolver {
  @Query(() => User, {
    nullable: true
  })
  async user(@Context() ctx: any, @Info() info: GraphQLResolveInfo, @Args() args: FindUniqueUserArgs): Promise<User | null> {
    const afterProcessEvents: ((result: any) => Promise<any>)[] = [];
    const { _count } = transformInfoIntoPrismaArgs(info, 'User', 'user', 'findUnique');
    const transformedArgsIntoPrismaArgs = await transformArgsIntoPrismaArgs(info, args, ctx, 'User', 'user', 'findUnique', afterProcessEvents);
    const otherArgs = _count && transformCountFieldIntoSelectRelationsCount(_count, 'User', 'user', 'findUnique');
    const result = await getPrismaFromContext(ctx).user.findUnique({ ...transformedArgsIntoPrismaArgs, ...otherArgs, });
    for (const afterProcessEvent of afterProcessEvents) { await afterProcessEvent(result); }

    return result;
  }
}
"
`;

exports[`crud should properly generate actions resolver classes for prisma model: GroupByUserResolver 1`] = `
"import { Args, ArgsType, Context, Field, Float, ID, Info, InputType, Int, Mutation, ObjectType, Parent, Query, ResolveField, Resolver, registerEnumType } from \\"@nestjs/graphql\\";
import type { GraphQLResolveInfo } from \\"graphql\\";
import { GroupByUserArgs } from \\"./args/GroupByUserArgs\\";
import { User } from \\"../../../models/User\\";
import { UserGroupBy } from \\"../../outputs/UserGroupBy\\";
import { transformArgsIntoPrismaArgs, transformInfoIntoPrismaArgs, getPrismaFromContext, transformCountFieldIntoSelectRelationsCount, InlineLoader } from \\"../../../helpers\\";

@Resolver(() => User)
export class GroupByUserResolver {
  @Query(() => [UserGroupBy], {
    nullable: false
  })
  async groupByUser(@Context() ctx: any, @Info() info: GraphQLResolveInfo, @Args() args: GroupByUserArgs): Promise<UserGroupBy[]> {
    const afterProcessEvents: ((result: any) => Promise<any>)[] = [];
    const { _count, _avg, _sum, _min, _max } = transformInfoIntoPrismaArgs(info, 'User', 'user', 'groupBy');
    const transformedArgsIntoPrismaArgs = await transformArgsIntoPrismaArgs(info, args, ctx, 'User', 'user', 'groupBy', afterProcessEvents);
    const groupByArgs = Object.fromEntries(Object.entries({ _count, _avg, _sum, _min, _max }).filter(([_, v]) => v != null));
    const result = await getPrismaFromContext(ctx).user.groupBy({ ...transformedArgsIntoPrismaArgs, ...groupByArgs, });
    for (const afterProcessEvent of afterProcessEvents) { await afterProcessEvent(result); }

    return result;
  }
}
"
`;

exports[`crud should properly generate actions resolver classes for prisma model: Index 1`] = `
"export * from \\"./resolvers-actions.index\\";
export * from \\"./resolvers-crud.index\\";
export * from \\"./args.index\\";
"
`;

exports[`crud should properly generate actions resolver classes for prisma model: UpdateManyUserResolver 1`] = `
"import { Args, ArgsType, Context, Field, Float, ID, Info, InputType, Int, Mutation, ObjectType, Parent, Query, ResolveField, Resolver, registerEnumType } from \\"@nestjs/graphql\\";
import type { GraphQLResolveInfo } from \\"graphql\\";
import { UpdateManyUserArgs } from \\"./args/UpdateManyUserArgs\\";
import { User } from \\"../../../models/User\\";
import { AffectedRowsOutput } from \\"../../outputs/AffectedRowsOutput\\";
import { transformArgsIntoPrismaArgs, transformInfoIntoPrismaArgs, getPrismaFromContext, transformCountFieldIntoSelectRelationsCount, InlineLoader } from \\"../../../helpers\\";

@Resolver(() => User)
export class UpdateManyUserResolver {
  @Mutation(() => AffectedRowsOutput, {
    nullable: false
  })
  async updateManyUser(@Context() ctx: any, @Info() info: GraphQLResolveInfo, @Args() args: UpdateManyUserArgs): Promise<AffectedRowsOutput> {
    const afterProcessEvents: ((result: any) => Promise<any>)[] = [];
    const { _count } = transformInfoIntoPrismaArgs(info, 'User', 'user', 'updateMany');
    const transformedArgsIntoPrismaArgs = await transformArgsIntoPrismaArgs(info, args, ctx, 'User', 'user', 'updateMany', afterProcessEvents);
    const otherArgs = _count && transformCountFieldIntoSelectRelationsCount(_count, 'User', 'user', 'updateMany');
    const result = await getPrismaFromContext(ctx).user.updateMany({ ...transformedArgsIntoPrismaArgs, ...otherArgs, });
    for (const afterProcessEvent of afterProcessEvents) { await afterProcessEvent(result); }

    return result;
  }
}
"
`;

exports[`crud should properly generate actions resolver classes for prisma model: UpdateOneUserResolver 1`] = `
"import { Args, ArgsType, Context, Field, Float, ID, Info, InputType, Int, Mutation, ObjectType, Parent, Query, ResolveField, Resolver, registerEnumType } from \\"@nestjs/graphql\\";
import type { GraphQLResolveInfo } from \\"graphql\\";
import { UpdateOneUserArgs } from \\"./args/UpdateOneUserArgs\\";
import { User } from \\"../../../models/User\\";
import { transformArgsIntoPrismaArgs, transformInfoIntoPrismaArgs, getPrismaFromContext, transformCountFieldIntoSelectRelationsCount, InlineLoader } from \\"../../../helpers\\";

@Resolver(() => User)
export class UpdateOneUserResolver {
  @Mutation(() => User, {
    nullable: true
  })
  async updateOneUser(@Context() ctx: any, @Info() info: GraphQLResolveInfo, @Args() args: UpdateOneUserArgs): Promise<User | null> {
    const afterProcessEvents: ((result: any) => Promise<any>)[] = [];
    const { _count } = transformInfoIntoPrismaArgs(info, 'User', 'user', 'update');
    const transformedArgsIntoPrismaArgs = await transformArgsIntoPrismaArgs(info, args, ctx, 'User', 'user', 'update', afterProcessEvents);
    const otherArgs = _count && transformCountFieldIntoSelectRelationsCount(_count, 'User', 'user', 'update');
    const result = await getPrismaFromContext(ctx).user.update({ ...transformedArgsIntoPrismaArgs, ...otherArgs, });
    for (const afterProcessEvent of afterProcessEvents) { await afterProcessEvent(result); }

    return result;
  }
}
"
`;

exports[`crud should properly generate actions resolver classes for prisma model: UpsertOneUserResolver 1`] = `
"import { Args, ArgsType, Context, Field, Float, ID, Info, InputType, Int, Mutation, ObjectType, Parent, Query, ResolveField, Resolver, registerEnumType } from \\"@nestjs/graphql\\";
import type { GraphQLResolveInfo } from \\"graphql\\";
import { UpsertOneUserArgs } from \\"./args/UpsertOneUserArgs\\";
import { User } from \\"../../../models/User\\";
import { transformArgsIntoPrismaArgs, transformInfoIntoPrismaArgs, getPrismaFromContext, transformCountFieldIntoSelectRelationsCount, InlineLoader } from \\"../../../helpers\\";

@Resolver(() => User)
export class UpsertOneUserResolver {
  @Mutation(() => User, {
    nullable: false
  })
  async upsertOneUser(@Context() ctx: any, @Info() info: GraphQLResolveInfo, @Args() args: UpsertOneUserArgs): Promise<User> {
    const afterProcessEvents: ((result: any) => Promise<any>)[] = [];
    const { _count } = transformInfoIntoPrismaArgs(info, 'User', 'user', 'upsert');
    const transformedArgsIntoPrismaArgs = await transformArgsIntoPrismaArgs(info, args, ctx, 'User', 'user', 'upsert', afterProcessEvents);
    const otherArgs = _count && transformCountFieldIntoSelectRelationsCount(_count, 'User', 'user', 'upsert');
    const result = await getPrismaFromContext(ctx).user.upsert({ ...transformedArgsIntoPrismaArgs, ...otherArgs, });
    for (const afterProcessEvent of afterProcessEvents) { await afterProcessEvent(result); }

    return result;
  }
}
"
`;

exports[`crud should properly generate actions resolver classes for prisma model: actionsIndex 1`] = `
"export { AggregateUserResolver } from \\"./User/AggregateUserResolver\\";
export { CreateManyUserResolver } from \\"./User/CreateManyUserResolver\\";
export { CreateManyAndReturnUserResolver } from \\"./User/CreateManyAndReturnUserResolver\\";
export { CreateOneUserResolver } from \\"./User/CreateOneUserResolver\\";
export { DeleteManyUserResolver } from \\"./User/DeleteManyUserResolver\\";
export { DeleteOneUserResolver } from \\"./User/DeleteOneUserResolver\\";
export { FindFirstUserResolver } from \\"./User/FindFirstUserResolver\\";
export { FindFirstUserOrThrowResolver } from \\"./User/FindFirstUserOrThrowResolver\\";
export { FindManyUserResolver } from \\"./User/FindManyUserResolver\\";
export { FindUniqueUserResolver } from \\"./User/FindUniqueUserResolver\\";
export { FindUniqueUserOrThrowResolver } from \\"./User/FindUniqueUserOrThrowResolver\\";
export { GroupByUserResolver } from \\"./User/GroupByUserResolver\\";
export { UpdateManyUserResolver } from \\"./User/UpdateManyUserResolver\\";
export { UpdateOneUserResolver } from \\"./User/UpdateOneUserResolver\\";
export { UpsertOneUserResolver } from \\"./User/UpsertOneUserResolver\\";
"
`;

exports[`crud should properly generate actions resolver classes for prisma model: argsIndex 1`] = `
"export * from \\"./User/args\\";
"
`;

exports[`crud should properly generate actions resolver classes for prisma model: crudIndex 1`] = `
"export { UserCrudResolver } from \\"./User/UserCrudResolver\\";
"
`;

exports[`crud should properly generate args classes for every method of crud resolver: AggregateUserArgs 1`] = `
"import { Args, ArgsType, Context, Field, Float, ID, Info, InputType, Int, Mutation, ObjectType, Parent, Query, ResolveField, Resolver, registerEnumType } from \\"@nestjs/graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { UserOrderByWithRelationInput, UserWhereInput, UserWhereUniqueInput } from \\"../../../inputs\\";

@ArgsType()
export class AggregateUserArgs {
  @Field(() => UserWhereInput, {
    nullable: true
  })
  where?: UserWhereInput | undefined;

  @Field(() => [UserOrderByWithRelationInput], {
    nullable: true
  })
  orderBy?: UserOrderByWithRelationInput[] | undefined;

  @Field(() => UserWhereUniqueInput, {
    nullable: true
  })
  cursor?: UserWhereUniqueInput | undefined;

  @Field(() => Int, {
    nullable: true
  })
  take?: number | undefined;

  @Field(() => Int, {
    nullable: true
  })
  skip?: number | undefined;
}
"
`;

exports[`crud should properly generate args classes for every method of crud resolver: CreateManyAndReturnUserArgs 1`] = `
"import { Args, ArgsType, Context, Field, Float, ID, Info, InputType, Int, Mutation, ObjectType, Parent, Query, ResolveField, Resolver, registerEnumType } from \\"@nestjs/graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { UserCreateManyInput } from \\"../../../inputs\\";

@ArgsType()
export class CreateManyAndReturnUserArgs {
  @Field(() => [UserCreateManyInput], {
    nullable: false
  })
  data!: UserCreateManyInput[];

  @Field(() => Boolean, {
    nullable: true
  })
  skipDuplicates?: boolean | undefined;
}
"
`;

exports[`crud should properly generate args classes for every method of crud resolver: CreateManyUserArgs 1`] = `
"import { Args, ArgsType, Context, Field, Float, ID, Info, InputType, Int, Mutation, ObjectType, Parent, Query, ResolveField, Resolver, registerEnumType } from \\"@nestjs/graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { UserCreateManyInput } from \\"../../../inputs\\";

@ArgsType()
export class CreateManyUserArgs {
  @Field(() => [UserCreateManyInput], {
    nullable: false
  })
  data!: UserCreateManyInput[];

  @Field(() => Boolean, {
    nullable: true
  })
  skipDuplicates?: boolean | undefined;
}
"
`;

exports[`crud should properly generate args classes for every method of crud resolver: CreateOneUserArgs 1`] = `
"import { Args, ArgsType, Context, Field, Float, ID, Info, InputType, Int, Mutation, ObjectType, Parent, Query, ResolveField, Resolver, registerEnumType } from \\"@nestjs/graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { UserCreateInput } from \\"../../../inputs\\";

@ArgsType()
export class CreateOneUserArgs {
  @Field(() => UserCreateInput, {
    nullable: false
  })
  data!: UserCreateInput;
}
"
`;

exports[`crud should properly generate args classes for every method of crud resolver: DeleteManyUserArgs 1`] = `
"import { Args, ArgsType, Context, Field, Float, ID, Info, InputType, Int, Mutation, ObjectType, Parent, Query, ResolveField, Resolver, registerEnumType } from \\"@nestjs/graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { UserWhereInput } from \\"../../../inputs\\";

@ArgsType()
export class DeleteManyUserArgs {
  @Field(() => UserWhereInput, {
    nullable: true
  })
  where?: UserWhereInput | undefined;

  @Field(() => Int, {
    nullable: true
  })
  limit?: number | undefined;
}
"
`;

exports[`crud should properly generate args classes for every method of crud resolver: DeleteOneUserArgs 1`] = `
"import { Args, ArgsType, Context, Field, Float, ID, Info, InputType, Int, Mutation, ObjectType, Parent, Query, ResolveField, Resolver, registerEnumType } from \\"@nestjs/graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { UserWhereUniqueInput } from \\"../../../inputs\\";

@ArgsType()
export class DeleteOneUserArgs {
  @Field(() => UserWhereUniqueInput, {
    nullable: false
  })
  where!: UserWhereUniqueInput;
}
"
`;

exports[`crud should properly generate args classes for every method of crud resolver: FindFirstUserArgs 1`] = `
"import { Args, ArgsType, Context, Field, Float, ID, Info, InputType, Int, Mutation, ObjectType, Parent, Query, ResolveField, Resolver, registerEnumType } from \\"@nestjs/graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { UserOrderByWithRelationInput, UserWhereInput, UserWhereUniqueInput } from \\"../../../inputs\\";
import { UserScalarFieldEnum } from \\"../../../../enums/UserScalarFieldEnum\\";

@ArgsType()
export class FindFirstUserArgs {
  @Field(() => UserWhereInput, {
    nullable: true
  })
  where?: UserWhereInput | undefined;

  @Field(() => [UserOrderByWithRelationInput], {
    nullable: true
  })
  orderBy?: UserOrderByWithRelationInput[] | undefined;

  @Field(() => UserWhereUniqueInput, {
    nullable: true
  })
  cursor?: UserWhereUniqueInput | undefined;

  @Field(() => Int, {
    nullable: true
  })
  take?: number | undefined;

  @Field(() => Int, {
    nullable: true
  })
  skip?: number | undefined;

  @Field(() => [UserScalarFieldEnum], {
    nullable: true
  })
  distinct?: Array<\\"intIdField\\" | \\"uniqueStringField\\" | \\"optionalStringField\\" | \\"dateField\\"> | undefined;
}
"
`;

exports[`crud should properly generate args classes for every method of crud resolver: FindFirstUserOrThrowArgs 1`] = `
"import { Args, ArgsType, Context, Field, Float, ID, Info, InputType, Int, Mutation, ObjectType, Parent, Query, ResolveField, Resolver, registerEnumType } from \\"@nestjs/graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { UserOrderByWithRelationInput, UserWhereInput, UserWhereUniqueInput } from \\"../../../inputs\\";
import { UserScalarFieldEnum } from \\"../../../../enums/UserScalarFieldEnum\\";

@ArgsType()
export class FindFirstUserOrThrowArgs {
  @Field(() => UserWhereInput, {
    nullable: true
  })
  where?: UserWhereInput | undefined;

  @Field(() => [UserOrderByWithRelationInput], {
    nullable: true
  })
  orderBy?: UserOrderByWithRelationInput[] | undefined;

  @Field(() => UserWhereUniqueInput, {
    nullable: true
  })
  cursor?: UserWhereUniqueInput | undefined;

  @Field(() => Int, {
    nullable: true
  })
  take?: number | undefined;

  @Field(() => Int, {
    nullable: true
  })
  skip?: number | undefined;

  @Field(() => [UserScalarFieldEnum], {
    nullable: true
  })
  distinct?: Array<\\"intIdField\\" | \\"uniqueStringField\\" | \\"optionalStringField\\" | \\"dateField\\"> | undefined;
}
"
`;

exports[`crud should properly generate args classes for every method of crud resolver: FindManyUserArgs 1`] = `
"import { Args, ArgsType, Context, Field, Float, ID, Info, InputType, Int, Mutation, ObjectType, Parent, Query, ResolveField, Resolver, registerEnumType } from \\"@nestjs/graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { UserOrderByWithRelationInput, UserWhereInput, UserWhereUniqueInput } from \\"../../../inputs\\";
import { UserScalarFieldEnum } from \\"../../../../enums/UserScalarFieldEnum\\";

@ArgsType()
export class FindManyUserArgs {
  @Field(() => UserWhereInput, {
    nullable: true
  })
  where?: UserWhereInput | undefined;

  @Field(() => [UserOrderByWithRelationInput], {
    nullable: true
  })
  orderBy?: UserOrderByWithRelationInput[] | undefined;

  @Field(() => UserWhereUniqueInput, {
    nullable: true
  })
  cursor?: UserWhereUniqueInput | undefined;

  @Field(() => Int, {
    nullable: true
  })
  take?: number | undefined;

  @Field(() => Int, {
    nullable: true
  })
  skip?: number | undefined;

  @Field(() => [UserScalarFieldEnum], {
    nullable: true
  })
  distinct?: Array<\\"intIdField\\" | \\"uniqueStringField\\" | \\"optionalStringField\\" | \\"dateField\\"> | undefined;
}
"
`;

exports[`crud should properly generate args classes for every method of crud resolver: FindUniqueUserArgs 1`] = `
"import { Args, ArgsType, Context, Field, Float, ID, Info, InputType, Int, Mutation, ObjectType, Parent, Query, ResolveField, Resolver, registerEnumType } from \\"@nestjs/graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { UserWhereUniqueInput } from \\"../../../inputs\\";

@ArgsType()
export class FindUniqueUserArgs {
  @Field(() => UserWhereUniqueInput, {
    nullable: false
  })
  where!: UserWhereUniqueInput;
}
"
`;

exports[`crud should properly generate args classes for every method of crud resolver: FindUniqueUserOrThrowArgs 1`] = `
"import { Args, ArgsType, Context, Field, Float, ID, Info, InputType, Int, Mutation, ObjectType, Parent, Query, ResolveField, Resolver, registerEnumType } from \\"@nestjs/graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { UserWhereUniqueInput } from \\"../../../inputs\\";

@ArgsType()
export class FindUniqueUserOrThrowArgs {
  @Field(() => UserWhereUniqueInput, {
    nullable: false
  })
  where!: UserWhereUniqueInput;
}
"
`;

exports[`crud should properly generate args classes for every method of crud resolver: GroupByUserArgs 1`] = `
"import { Args, ArgsType, Context, Field, Float, ID, Info, InputType, Int, Mutation, ObjectType, Parent, Query, ResolveField, Resolver, registerEnumType } from \\"@nestjs/graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { UserOrderByWithAggregationInput, UserScalarWhereWithAggregatesInput, UserWhereInput } from \\"../../../inputs\\";
import { UserScalarFieldEnum } from \\"../../../../enums/UserScalarFieldEnum\\";

@ArgsType()
export class GroupByUserArgs {
  @Field(() => UserWhereInput, {
    nullable: true
  })
  where?: UserWhereInput | undefined;

  @Field(() => [UserOrderByWithAggregationInput], {
    nullable: true
  })
  orderBy?: UserOrderByWithAggregationInput[] | undefined;

  @Field(() => [UserScalarFieldEnum], {
    nullable: false
  })
  by!: Array<\\"intIdField\\" | \\"uniqueStringField\\" | \\"optionalStringField\\" | \\"dateField\\">;

  @Field(() => UserScalarWhereWithAggregatesInput, {
    nullable: true
  })
  having?: UserScalarWhereWithAggregatesInput | undefined;

  @Field(() => Int, {
    nullable: true
  })
  take?: number | undefined;

  @Field(() => Int, {
    nullable: true
  })
  skip?: number | undefined;
}
"
`;

exports[`crud should properly generate args classes for every method of crud resolver: Index 1`] = `
"export { AggregateUserArgs } from \\"./AggregateUserArgs\\";
export { CreateManyAndReturnUserArgs } from \\"./CreateManyAndReturnUserArgs\\";
export { CreateManyUserArgs } from \\"./CreateManyUserArgs\\";
export { CreateOneUserArgs } from \\"./CreateOneUserArgs\\";
export { DeleteManyUserArgs } from \\"./DeleteManyUserArgs\\";
export { DeleteOneUserArgs } from \\"./DeleteOneUserArgs\\";
export { FindFirstUserArgs } from \\"./FindFirstUserArgs\\";
export { FindFirstUserOrThrowArgs } from \\"./FindFirstUserOrThrowArgs\\";
export { FindManyUserArgs } from \\"./FindManyUserArgs\\";
export { FindUniqueUserArgs } from \\"./FindUniqueUserArgs\\";
export { FindUniqueUserOrThrowArgs } from \\"./FindUniqueUserOrThrowArgs\\";
export { GroupByUserArgs } from \\"./GroupByUserArgs\\";
export { UpdateManyUserArgs } from \\"./UpdateManyUserArgs\\";
export { UpdateOneUserArgs } from \\"./UpdateOneUserArgs\\";
export { UpsertOneUserArgs } from \\"./UpsertOneUserArgs\\";
"
`;

exports[`crud should properly generate args classes for every method of crud resolver: UpdateManyUserArgs 1`] = `
"import { Args, ArgsType, Context, Field, Float, ID, Info, InputType, Int, Mutation, ObjectType, Parent, Query, ResolveField, Resolver, registerEnumType } from \\"@nestjs/graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { UserUpdateManyMutationInput, UserWhereInput } from \\"../../../inputs\\";

@ArgsType()
export class UpdateManyUserArgs {
  @Field(() => UserUpdateManyMutationInput, {
    nullable: false
  })
  data!: UserUpdateManyMutationInput;

  @Field(() => UserWhereInput, {
    nullable: true
  })
  where?: UserWhereInput | undefined;

  @Field(() => Int, {
    nullable: true
  })
  limit?: number | undefined;
}
"
`;

exports[`crud should properly generate args classes for every method of crud resolver: UpdateOneUserArgs 1`] = `
"import { Args, ArgsType, Context, Field, Float, ID, Info, InputType, Int, Mutation, ObjectType, Parent, Query, ResolveField, Resolver, registerEnumType } from \\"@nestjs/graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { UserUpdateInput, UserWhereUniqueInput } from \\"../../../inputs\\";

@ArgsType()
export class UpdateOneUserArgs {
  @Field(() => UserUpdateInput, {
    nullable: false
  })
  data!: UserUpdateInput;

  @Field(() => UserWhereUniqueInput, {
    nullable: false
  })
  where!: UserWhereUniqueInput;
}
"
`;

exports[`crud should properly generate args classes for every method of crud resolver: UpsertOneUserArgs 1`] = `
"import { Args, ArgsType, Context, Field, Float, ID, Info, InputType, Int, Mutation, ObjectType, Parent, Query, ResolveField, Resolver, registerEnumType } from \\"@nestjs/graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { UserCreateInput, UserUpdateInput, UserWhereUniqueInput } from \\"../../../inputs\\";

@ArgsType()
export class UpsertOneUserArgs {
  @Field(() => UserWhereUniqueInput, {
    nullable: false
  })
  where!: UserWhereUniqueInput;

  @Field(() => UserCreateInput, {
    nullable: false
  })
  create!: UserCreateInput;

  @Field(() => UserUpdateInput, {
    nullable: false
  })
  update!: UserUpdateInput;
}
"
`;

exports[`crud should properly generate args classes for group by action using aggregate input: GroupBySampleArgs 1`] = `
"import { Args, ArgsType, Context, Field, Float, ID, Info, InputType, Int, Mutation, ObjectType, Parent, Query, ResolveField, Resolver, registerEnumType } from \\"@nestjs/graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { SampleOrderByWithAggregationInput, SampleScalarWhereWithAggregatesInput, SampleWhereInput } from \\"../../../inputs\\";
import { SampleScalarFieldEnum } from \\"../../../../enums/SampleScalarFieldEnum\\";

@ArgsType()
export class GroupBySampleArgs {
  @Field(() => SampleWhereInput, {
    nullable: true
  })
  where?: SampleWhereInput | undefined;

  @Field(() => [SampleOrderByWithAggregationInput], {
    nullable: true
  })
  orderBy?: SampleOrderByWithAggregationInput[] | undefined;

  @Field(() => [SampleScalarFieldEnum], {
    nullable: false
  })
  by!: Array<\\"idField\\" | \\"stringField\\" | \\"floatField\\" | \\"intField\\" | \\"booleanField\\" | \\"dateField\\" | \\"jsonField\\">;

  @Field(() => SampleScalarWhereWithAggregatesInput, {
    nullable: true
  })
  having?: SampleScalarWhereWithAggregatesInput | undefined;

  @Field(() => Int, {
    nullable: true
  })
  take?: number | undefined;

  @Field(() => Int, {
    nullable: true
  })
  skip?: number | undefined;
}
"
`;

exports[`crud should properly generate args classes for sorting by many-to-many relation fields: AggregateFirstModelArgs 1`] = `
"import { Args, ArgsType, Context, Field, Float, ID, Info, InputType, Int, Mutation, ObjectType, Parent, Query, ResolveField, Resolver, registerEnumType } from \\"@nestjs/graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { FirstModelOrderByWithRelationInput, FirstModelWhereInput, FirstModelWhereUniqueInput } from \\"../../../inputs\\";

@ArgsType()
export class AggregateFirstModelArgs {
  @Field(() => FirstModelWhereInput, {
    nullable: true
  })
  where?: FirstModelWhereInput | undefined;

  @Field(() => [FirstModelOrderByWithRelationInput], {
    nullable: true
  })
  orderBy?: FirstModelOrderByWithRelationInput[] | undefined;

  @Field(() => FirstModelWhereUniqueInput, {
    nullable: true
  })
  cursor?: FirstModelWhereUniqueInput | undefined;

  @Field(() => Int, {
    nullable: true
  })
  take?: number | undefined;

  @Field(() => Int, {
    nullable: true
  })
  skip?: number | undefined;
}
"
`;

exports[`crud should properly generate args classes for sorting by many-to-many relation fields: FindFirstFirstModelArgs 1`] = `
"import { Args, ArgsType, Context, Field, Float, ID, Info, InputType, Int, Mutation, ObjectType, Parent, Query, ResolveField, Resolver, registerEnumType } from \\"@nestjs/graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { FirstModelOrderByWithRelationInput, FirstModelWhereInput, FirstModelWhereUniqueInput } from \\"../../../inputs\\";
import { FirstModelScalarFieldEnum } from \\"../../../../enums/FirstModelScalarFieldEnum\\";

@ArgsType()
export class FindFirstFirstModelArgs {
  @Field(() => FirstModelWhereInput, {
    nullable: true
  })
  where?: FirstModelWhereInput | undefined;

  @Field(() => [FirstModelOrderByWithRelationInput], {
    nullable: true
  })
  orderBy?: FirstModelOrderByWithRelationInput[] | undefined;

  @Field(() => FirstModelWhereUniqueInput, {
    nullable: true
  })
  cursor?: FirstModelWhereUniqueInput | undefined;

  @Field(() => Int, {
    nullable: true
  })
  take?: number | undefined;

  @Field(() => Int, {
    nullable: true
  })
  skip?: number | undefined;

  @Field(() => [FirstModelScalarFieldEnum], {
    nullable: true
  })
  distinct?: Array<\\"idField\\" | \\"uniqueStringField\\" | \\"floatField\\"> | undefined;
}
"
`;

exports[`crud should properly generate args classes for sorting by many-to-many relation fields: FindManyFirstModelArgs 1`] = `
"import { Args, ArgsType, Context, Field, Float, ID, Info, InputType, Int, Mutation, ObjectType, Parent, Query, ResolveField, Resolver, registerEnumType } from \\"@nestjs/graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { FirstModelOrderByWithRelationInput, FirstModelWhereInput, FirstModelWhereUniqueInput } from \\"../../../inputs\\";
import { FirstModelScalarFieldEnum } from \\"../../../../enums/FirstModelScalarFieldEnum\\";

@ArgsType()
export class FindManyFirstModelArgs {
  @Field(() => FirstModelWhereInput, {
    nullable: true
  })
  where?: FirstModelWhereInput | undefined;

  @Field(() => [FirstModelOrderByWithRelationInput], {
    nullable: true
  })
  orderBy?: FirstModelOrderByWithRelationInput[] | undefined;

  @Field(() => FirstModelWhereUniqueInput, {
    nullable: true
  })
  cursor?: FirstModelWhereUniqueInput | undefined;

  @Field(() => Int, {
    nullable: true
  })
  take?: number | undefined;

  @Field(() => Int, {
    nullable: true
  })
  skip?: number | undefined;

  @Field(() => [FirstModelScalarFieldEnum], {
    nullable: true
  })
  distinct?: Array<\\"idField\\" | \\"uniqueStringField\\" | \\"floatField\\"> | undefined;
}
"
`;

exports[`crud should properly generate args classes for sorting by many-to-many relation fields: index 1`] = `
"export { AggregateFirstModelArgs } from \\"./AggregateFirstModelArgs\\";
export { CreateManyAndReturnFirstModelArgs } from \\"./CreateManyAndReturnFirstModelArgs\\";
export { CreateManyFirstModelArgs } from \\"./CreateManyFirstModelArgs\\";
export { CreateOneFirstModelArgs } from \\"./CreateOneFirstModelArgs\\";
export { DeleteManyFirstModelArgs } from \\"./DeleteManyFirstModelArgs\\";
export { DeleteOneFirstModelArgs } from \\"./DeleteOneFirstModelArgs\\";
export { FindFirstFirstModelArgs } from \\"./FindFirstFirstModelArgs\\";
export { FindFirstFirstModelOrThrowArgs } from \\"./FindFirstFirstModelOrThrowArgs\\";
export { FindManyFirstModelArgs } from \\"./FindManyFirstModelArgs\\";
export { FindUniqueFirstModelArgs } from \\"./FindUniqueFirstModelArgs\\";
export { FindUniqueFirstModelOrThrowArgs } from \\"./FindUniqueFirstModelOrThrowArgs\\";
export { GroupByFirstModelArgs } from \\"./GroupByFirstModelArgs\\";
export { UpdateManyFirstModelArgs } from \\"./UpdateManyFirstModelArgs\\";
export { UpdateOneFirstModelArgs } from \\"./UpdateOneFirstModelArgs\\";
export { UpsertOneFirstModelArgs } from \\"./UpsertOneFirstModelArgs\\";
"
`;

exports[`crud should properly generate args classes for sorting by one-to-many relation fields: AggregateSecondModelArgs 1`] = `
"import { Args, ArgsType, Context, Field, Float, ID, Info, InputType, Int, Mutation, ObjectType, Parent, Query, ResolveField, Resolver, registerEnumType } from \\"@nestjs/graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { SecondModelOrderByWithRelationInput, SecondModelWhereInput, SecondModelWhereUniqueInput } from \\"../../../inputs\\";

@ArgsType()
export class AggregateSecondModelArgs {
  @Field(() => SecondModelWhereInput, {
    nullable: true
  })
  where?: SecondModelWhereInput | undefined;

  @Field(() => [SecondModelOrderByWithRelationInput], {
    nullable: true
  })
  orderBy?: SecondModelOrderByWithRelationInput[] | undefined;

  @Field(() => SecondModelWhereUniqueInput, {
    nullable: true
  })
  cursor?: SecondModelWhereUniqueInput | undefined;

  @Field(() => Int, {
    nullable: true
  })
  take?: number | undefined;

  @Field(() => Int, {
    nullable: true
  })
  skip?: number | undefined;
}
"
`;

exports[`crud should properly generate args classes for sorting by one-to-many relation fields: FindFirstSecondModelArgs 1`] = `
"import { Args, ArgsType, Context, Field, Float, ID, Info, InputType, Int, Mutation, ObjectType, Parent, Query, ResolveField, Resolver, registerEnumType } from \\"@nestjs/graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { SecondModelOrderByWithRelationInput, SecondModelWhereInput, SecondModelWhereUniqueInput } from \\"../../../inputs\\";
import { SecondModelScalarFieldEnum } from \\"../../../../enums/SecondModelScalarFieldEnum\\";

@ArgsType()
export class FindFirstSecondModelArgs {
  @Field(() => SecondModelWhereInput, {
    nullable: true
  })
  where?: SecondModelWhereInput | undefined;

  @Field(() => [SecondModelOrderByWithRelationInput], {
    nullable: true
  })
  orderBy?: SecondModelOrderByWithRelationInput[] | undefined;

  @Field(() => SecondModelWhereUniqueInput, {
    nullable: true
  })
  cursor?: SecondModelWhereUniqueInput | undefined;

  @Field(() => Int, {
    nullable: true
  })
  take?: number | undefined;

  @Field(() => Int, {
    nullable: true
  })
  skip?: number | undefined;

  @Field(() => [SecondModelScalarFieldEnum], {
    nullable: true
  })
  distinct?: Array<\\"idField\\" | \\"uniqueStringField\\" | \\"floatField\\" | \\"firstModelFieldId\\"> | undefined;
}
"
`;

exports[`crud should properly generate args classes for sorting by one-to-many relation fields: FindManySecondModelArgs 1`] = `
"import { Args, ArgsType, Context, Field, Float, ID, Info, InputType, Int, Mutation, ObjectType, Parent, Query, ResolveField, Resolver, registerEnumType } from \\"@nestjs/graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { SecondModelOrderByWithRelationInput, SecondModelWhereInput, SecondModelWhereUniqueInput } from \\"../../../inputs\\";
import { SecondModelScalarFieldEnum } from \\"../../../../enums/SecondModelScalarFieldEnum\\";

@ArgsType()
export class FindManySecondModelArgs {
  @Field(() => SecondModelWhereInput, {
    nullable: true
  })
  where?: SecondModelWhereInput | undefined;

  @Field(() => [SecondModelOrderByWithRelationInput], {
    nullable: true
  })
  orderBy?: SecondModelOrderByWithRelationInput[] | undefined;

  @Field(() => SecondModelWhereUniqueInput, {
    nullable: true
  })
  cursor?: SecondModelWhereUniqueInput | undefined;

  @Field(() => Int, {
    nullable: true
  })
  take?: number | undefined;

  @Field(() => Int, {
    nullable: true
  })
  skip?: number | undefined;

  @Field(() => [SecondModelScalarFieldEnum], {
    nullable: true
  })
  distinct?: Array<\\"idField\\" | \\"uniqueStringField\\" | \\"floatField\\" | \\"firstModelFieldId\\"> | undefined;
}
"
`;

exports[`crud should properly generate args classes for sorting by one-to-many relation fields: index 1`] = `
"export { AggregateSecondModelArgs } from \\"./AggregateSecondModelArgs\\";
export { CreateManyAndReturnSecondModelArgs } from \\"./CreateManyAndReturnSecondModelArgs\\";
export { CreateManySecondModelArgs } from \\"./CreateManySecondModelArgs\\";
export { CreateOneSecondModelArgs } from \\"./CreateOneSecondModelArgs\\";
export { DeleteManySecondModelArgs } from \\"./DeleteManySecondModelArgs\\";
export { DeleteOneSecondModelArgs } from \\"./DeleteOneSecondModelArgs\\";
export { FindFirstSecondModelArgs } from \\"./FindFirstSecondModelArgs\\";
export { FindFirstSecondModelOrThrowArgs } from \\"./FindFirstSecondModelOrThrowArgs\\";
export { FindManySecondModelArgs } from \\"./FindManySecondModelArgs\\";
export { FindUniqueSecondModelArgs } from \\"./FindUniqueSecondModelArgs\\";
export { FindUniqueSecondModelOrThrowArgs } from \\"./FindUniqueSecondModelOrThrowArgs\\";
export { GroupBySecondModelArgs } from \\"./GroupBySecondModelArgs\\";
export { UpdateManySecondModelArgs } from \\"./UpdateManySecondModelArgs\\";
export { UpdateOneSecondModelArgs } from \\"./UpdateOneSecondModelArgs\\";
export { UpsertOneSecondModelArgs } from \\"./UpsertOneSecondModelArgs\\";
"
`;

exports[`crud should properly generate resolver class for single prisma model: Index 1`] = `
"export * from \\"./resolvers-actions.index\\";
export * from \\"./resolvers-crud.index\\";
export * from \\"./args.index\\";
"
`;

exports[`crud should properly generate resolver class for single prisma model: UserCrudResolver 1`] = `
"import { Args, ArgsType, Context, Field, Float, ID, Info, InputType, Int, Mutation, ObjectType, Parent, Query, ResolveField, Resolver, registerEnumType } from \\"@nestjs/graphql\\";
import type { GraphQLResolveInfo } from \\"graphql\\";
import { AggregateUserArgs } from \\"./args/AggregateUserArgs\\";
import { CreateManyAndReturnUserArgs } from \\"./args/CreateManyAndReturnUserArgs\\";
import { CreateManyUserArgs } from \\"./args/CreateManyUserArgs\\";
import { CreateOneUserArgs } from \\"./args/CreateOneUserArgs\\";
import { DeleteManyUserArgs } from \\"./args/DeleteManyUserArgs\\";
import { DeleteOneUserArgs } from \\"./args/DeleteOneUserArgs\\";
import { FindFirstUserArgs } from \\"./args/FindFirstUserArgs\\";
import { FindFirstUserOrThrowArgs } from \\"./args/FindFirstUserOrThrowArgs\\";
import { FindManyUserArgs } from \\"./args/FindManyUserArgs\\";
import { FindUniqueUserArgs } from \\"./args/FindUniqueUserArgs\\";
import { FindUniqueUserOrThrowArgs } from \\"./args/FindUniqueUserOrThrowArgs\\";
import { GroupByUserArgs } from \\"./args/GroupByUserArgs\\";
import { UpdateManyUserArgs } from \\"./args/UpdateManyUserArgs\\";
import { UpdateOneUserArgs } from \\"./args/UpdateOneUserArgs\\";
import { UpsertOneUserArgs } from \\"./args/UpsertOneUserArgs\\";
import { transformArgsIntoPrismaArgs, transformInfoIntoPrismaArgs, getPrismaFromContext, transformCountFieldIntoSelectRelationsCount, InlineLoader } from \\"../../../helpers\\";
import { User } from \\"../../../models/User\\";
import { AffectedRowsOutput } from \\"../../outputs/AffectedRowsOutput\\";
import { AggregateUser } from \\"../../outputs/AggregateUser\\";
import { CreateManyAndReturnUser } from \\"../../outputs/CreateManyAndReturnUser\\";
import { UserGroupBy } from \\"../../outputs/UserGroupBy\\";

@Resolver(() => User)
export class UserCrudResolver {
  @Query(() => AggregateUser, {
    nullable: false
  })
  async aggregateUser(@Context() ctx: any, @Info() info: GraphQLResolveInfo, @Args() args: AggregateUserArgs): Promise<AggregateUser> {
    const afterProcessEvents: ((result: any) => Promise<any>)[] = [];
    const transformedArgsIntoPrismaArgs = await transformArgsIntoPrismaArgs(info, args, ctx, 'User', 'user', 'aggregate', afterProcessEvents);
    const transformedInfoIntoPrismaArgs = transformInfoIntoPrismaArgs(info, 'User', 'user', 'aggregate');
    const result = await getPrismaFromContext(ctx).user.aggregate({ ...transformedArgsIntoPrismaArgs, ...transformedInfoIntoPrismaArgs, });
    for (const afterProcessEvent of afterProcessEvents) { await afterProcessEvent(result); }

    return result;
  }

  @Mutation(() => AffectedRowsOutput, {
    nullable: false
  })
  async createManyUser(@Context() ctx: any, @Info() info: GraphQLResolveInfo, @Args() args: CreateManyUserArgs): Promise<AffectedRowsOutput> {
    const afterProcessEvents: ((result: any) => Promise<any>)[] = [];
    const { _count } = transformInfoIntoPrismaArgs(info, 'User', 'user', 'createMany');
    const transformedArgsIntoPrismaArgs = await transformArgsIntoPrismaArgs(info, args, ctx, 'User', 'user', 'createMany', afterProcessEvents);
    const otherArgs = _count && transformCountFieldIntoSelectRelationsCount(_count, 'User', 'user', 'createMany');
    const result = await getPrismaFromContext(ctx).user.createMany({ ...transformedArgsIntoPrismaArgs, ...otherArgs, });
    for (const afterProcessEvent of afterProcessEvents) { await afterProcessEvent(result); }

    return result;
  }

  @Mutation(() => [CreateManyAndReturnUser], {
    nullable: false
  })
  async createManyAndReturnUser(@Context() ctx: any, @Info() info: GraphQLResolveInfo, @Args() args: CreateManyAndReturnUserArgs): Promise<CreateManyAndReturnUser[]> {
    const afterProcessEvents: ((result: any) => Promise<any>)[] = [];
    const { _count } = transformInfoIntoPrismaArgs(info, 'User', 'user', 'createManyAndReturn');
    const transformedArgsIntoPrismaArgs = await transformArgsIntoPrismaArgs(info, args, ctx, 'User', 'user', 'createManyAndReturn', afterProcessEvents);
    const otherArgs = _count && transformCountFieldIntoSelectRelationsCount(_count, 'User', 'user', 'createManyAndReturn');
    const result = await getPrismaFromContext(ctx).user.createManyAndReturn({ ...transformedArgsIntoPrismaArgs, ...otherArgs, });
    for (const afterProcessEvent of afterProcessEvents) { await afterProcessEvent(result); }

    return result;
  }

  @Mutation(() => User, {
    nullable: false
  })
  async createOneUser(@Context() ctx: any, @Info() info: GraphQLResolveInfo, @Args() args: CreateOneUserArgs): Promise<User> {
    const afterProcessEvents: ((result: any) => Promise<any>)[] = [];
    const { _count } = transformInfoIntoPrismaArgs(info, 'User', 'user', 'create');
    const transformedArgsIntoPrismaArgs = await transformArgsIntoPrismaArgs(info, args, ctx, 'User', 'user', 'create', afterProcessEvents);
    const otherArgs = _count && transformCountFieldIntoSelectRelationsCount(_count, 'User', 'user', 'create');
    const result = await getPrismaFromContext(ctx).user.create({ ...transformedArgsIntoPrismaArgs, ...otherArgs, });
    for (const afterProcessEvent of afterProcessEvents) { await afterProcessEvent(result); }

    return result;
  }

  @Mutation(() => AffectedRowsOutput, {
    nullable: false
  })
  async deleteManyUser(@Context() ctx: any, @Info() info: GraphQLResolveInfo, @Args() args: DeleteManyUserArgs): Promise<AffectedRowsOutput> {
    const afterProcessEvents: ((result: any) => Promise<any>)[] = [];
    const { _count } = transformInfoIntoPrismaArgs(info, 'User', 'user', 'deleteMany');
    const transformedArgsIntoPrismaArgs = await transformArgsIntoPrismaArgs(info, args, ctx, 'User', 'user', 'deleteMany', afterProcessEvents);
    const otherArgs = _count && transformCountFieldIntoSelectRelationsCount(_count, 'User', 'user', 'deleteMany');
    const result = await getPrismaFromContext(ctx).user.deleteMany({ ...transformedArgsIntoPrismaArgs, ...otherArgs, });
    for (const afterProcessEvent of afterProcessEvents) { await afterProcessEvent(result); }

    return result;
  }

  @Mutation(() => User, {
    nullable: true
  })
  async deleteOneUser(@Context() ctx: any, @Info() info: GraphQLResolveInfo, @Args() args: DeleteOneUserArgs): Promise<User | null> {
    const afterProcessEvents: ((result: any) => Promise<any>)[] = [];
    const { _count } = transformInfoIntoPrismaArgs(info, 'User', 'user', 'delete');
    const transformedArgsIntoPrismaArgs = await transformArgsIntoPrismaArgs(info, args, ctx, 'User', 'user', 'delete', afterProcessEvents);
    const otherArgs = _count && transformCountFieldIntoSelectRelationsCount(_count, 'User', 'user', 'delete');
    const result = await getPrismaFromContext(ctx).user.delete({ ...transformedArgsIntoPrismaArgs, ...otherArgs, });
    for (const afterProcessEvent of afterProcessEvents) { await afterProcessEvent(result); }

    return result;
  }

  @Query(() => User, {
    nullable: true
  })
  async findFirstUser(@Context() ctx: any, @Info() info: GraphQLResolveInfo, @Args() args: FindFirstUserArgs): Promise<User | null> {
    const afterProcessEvents: ((result: any) => Promise<any>)[] = [];
    const { _count } = transformInfoIntoPrismaArgs(info, 'User', 'user', 'findFirst');
    const transformedArgsIntoPrismaArgs = await transformArgsIntoPrismaArgs(info, args, ctx, 'User', 'user', 'findFirst', afterProcessEvents);
    const otherArgs = _count && transformCountFieldIntoSelectRelationsCount(_count, 'User', 'user', 'findFirst');
    const result = await getPrismaFromContext(ctx).user.findFirst({ ...transformedArgsIntoPrismaArgs, ...otherArgs, });
    for (const afterProcessEvent of afterProcessEvents) { await afterProcessEvent(result); }

    return result;
  }

  @Query(() => User, {
    nullable: true
  })
  async findFirstUserOrThrow(@Context() ctx: any, @Info() info: GraphQLResolveInfo, @Args() args: FindFirstUserOrThrowArgs): Promise<User | null> {
    const afterProcessEvents: ((result: any) => Promise<any>)[] = [];
    const { _count } = transformInfoIntoPrismaArgs(info, 'User', 'user', 'findFirstOrThrow');
    const transformedArgsIntoPrismaArgs = await transformArgsIntoPrismaArgs(info, args, ctx, 'User', 'user', 'findFirstOrThrow', afterProcessEvents);
    const otherArgs = _count && transformCountFieldIntoSelectRelationsCount(_count, 'User', 'user', 'findFirstOrThrow');
    const result = await getPrismaFromContext(ctx).user.findFirstOrThrow({ ...transformedArgsIntoPrismaArgs, ...otherArgs, });
    for (const afterProcessEvent of afterProcessEvents) { await afterProcessEvent(result); }

    return result;
  }

  @Query(() => [User], {
    nullable: false
  })
  async users(@Context() ctx: any, @Info() info: GraphQLResolveInfo, @Args() args: FindManyUserArgs): Promise<User[]> {
    const afterProcessEvents: ((result: any) => Promise<any>)[] = [];
    const { _count } = transformInfoIntoPrismaArgs(info, 'User', 'user', 'findMany');
    const transformedArgsIntoPrismaArgs = await transformArgsIntoPrismaArgs(info, args, ctx, 'User', 'user', 'findMany', afterProcessEvents);
    const otherArgs = _count && transformCountFieldIntoSelectRelationsCount(_count, 'User', 'user', 'findMany');
    const result = await getPrismaFromContext(ctx).user.findMany({ ...transformedArgsIntoPrismaArgs, ...otherArgs, });
    for (const afterProcessEvent of afterProcessEvents) { await afterProcessEvent(result); }

    return result;
  }

  @Query(() => User, {
    nullable: true
  })
  async user(@Context() ctx: any, @Info() info: GraphQLResolveInfo, @Args() args: FindUniqueUserArgs): Promise<User | null> {
    const afterProcessEvents: ((result: any) => Promise<any>)[] = [];
    const { _count } = transformInfoIntoPrismaArgs(info, 'User', 'user', 'findUnique');
    const transformedArgsIntoPrismaArgs = await transformArgsIntoPrismaArgs(info, args, ctx, 'User', 'user', 'findUnique', afterProcessEvents);
    const otherArgs = _count && transformCountFieldIntoSelectRelationsCount(_count, 'User', 'user', 'findUnique');
    const result = await getPrismaFromContext(ctx).user.findUnique({ ...transformedArgsIntoPrismaArgs, ...otherArgs, });
    for (const afterProcessEvent of afterProcessEvents) { await afterProcessEvent(result); }

    return result;
  }

  @Query(() => User, {
    nullable: true
  })
  async getUser(@Context() ctx: any, @Info() info: GraphQLResolveInfo, @Args() args: FindUniqueUserOrThrowArgs): Promise<User | null> {
    const afterProcessEvents: ((result: any) => Promise<any>)[] = [];
    const { _count } = transformInfoIntoPrismaArgs(info, 'User', 'user', 'findUniqueOrThrow');
    const transformedArgsIntoPrismaArgs = await transformArgsIntoPrismaArgs(info, args, ctx, 'User', 'user', 'findUniqueOrThrow', afterProcessEvents);
    const otherArgs = _count && transformCountFieldIntoSelectRelationsCount(_count, 'User', 'user', 'findUniqueOrThrow');
    const result = await getPrismaFromContext(ctx).user.findUniqueOrThrow({ ...transformedArgsIntoPrismaArgs, ...otherArgs, });
    for (const afterProcessEvent of afterProcessEvents) { await afterProcessEvent(result); }

    return result;
  }

  @Query(() => [UserGroupBy], {
    nullable: false
  })
  async groupByUser(@Context() ctx: any, @Info() info: GraphQLResolveInfo, @Args() args: GroupByUserArgs): Promise<UserGroupBy[]> {
    const afterProcessEvents: ((result: any) => Promise<any>)[] = [];
    const { _count, _avg, _sum, _min, _max } = transformInfoIntoPrismaArgs(info, 'User', 'user', 'groupBy');
    const transformedArgsIntoPrismaArgs = await transformArgsIntoPrismaArgs(info, args, ctx, 'User', 'user', 'groupBy', afterProcessEvents);
    const groupByArgs = Object.fromEntries(Object.entries({ _count, _avg, _sum, _min, _max }).filter(([_, v]) => v != null));
    const result = await getPrismaFromContext(ctx).user.groupBy({ ...transformedArgsIntoPrismaArgs, ...groupByArgs, });
    for (const afterProcessEvent of afterProcessEvents) { await afterProcessEvent(result); }

    return result;
  }

  @Mutation(() => AffectedRowsOutput, {
    nullable: false
  })
  async updateManyUser(@Context() ctx: any, @Info() info: GraphQLResolveInfo, @Args() args: UpdateManyUserArgs): Promise<AffectedRowsOutput> {
    const afterProcessEvents: ((result: any) => Promise<any>)[] = [];
    const { _count } = transformInfoIntoPrismaArgs(info, 'User', 'user', 'updateMany');
    const transformedArgsIntoPrismaArgs = await transformArgsIntoPrismaArgs(info, args, ctx, 'User', 'user', 'updateMany', afterProcessEvents);
    const otherArgs = _count && transformCountFieldIntoSelectRelationsCount(_count, 'User', 'user', 'updateMany');
    const result = await getPrismaFromContext(ctx).user.updateMany({ ...transformedArgsIntoPrismaArgs, ...otherArgs, });
    for (const afterProcessEvent of afterProcessEvents) { await afterProcessEvent(result); }

    return result;
  }

  @Mutation(() => User, {
    nullable: true
  })
  async updateOneUser(@Context() ctx: any, @Info() info: GraphQLResolveInfo, @Args() args: UpdateOneUserArgs): Promise<User | null> {
    const afterProcessEvents: ((result: any) => Promise<any>)[] = [];
    const { _count } = transformInfoIntoPrismaArgs(info, 'User', 'user', 'update');
    const transformedArgsIntoPrismaArgs = await transformArgsIntoPrismaArgs(info, args, ctx, 'User', 'user', 'update', afterProcessEvents);
    const otherArgs = _count && transformCountFieldIntoSelectRelationsCount(_count, 'User', 'user', 'update');
    const result = await getPrismaFromContext(ctx).user.update({ ...transformedArgsIntoPrismaArgs, ...otherArgs, });
    for (const afterProcessEvent of afterProcessEvents) { await afterProcessEvent(result); }

    return result;
  }

  @Mutation(() => User, {
    nullable: false
  })
  async upsertOneUser(@Context() ctx: any, @Info() info: GraphQLResolveInfo, @Args() args: UpsertOneUserArgs): Promise<User> {
    const afterProcessEvents: ((result: any) => Promise<any>)[] = [];
    const { _count } = transformInfoIntoPrismaArgs(info, 'User', 'user', 'upsert');
    const transformedArgsIntoPrismaArgs = await transformArgsIntoPrismaArgs(info, args, ctx, 'User', 'user', 'upsert', afterProcessEvents);
    const otherArgs = _count && transformCountFieldIntoSelectRelationsCount(_count, 'User', 'user', 'upsert');
    const result = await getPrismaFromContext(ctx).user.upsert({ ...transformedArgsIntoPrismaArgs, ...otherArgs, });
    for (const afterProcessEvent of afterProcessEvents) { await afterProcessEvent(result); }

    return result;
  }
}
"
`;

exports[`crud should properly generate resolver class for single prisma model: actionsIndex 1`] = `
"export { AggregateUserResolver } from \\"./User/AggregateUserResolver\\";
export { CreateManyUserResolver } from \\"./User/CreateManyUserResolver\\";
export { CreateManyAndReturnUserResolver } from \\"./User/CreateManyAndReturnUserResolver\\";
export { CreateOneUserResolver } from \\"./User/CreateOneUserResolver\\";
export { DeleteManyUserResolver } from \\"./User/DeleteManyUserResolver\\";
export { DeleteOneUserResolver } from \\"./User/DeleteOneUserResolver\\";
export { FindFirstUserResolver } from \\"./User/FindFirstUserResolver\\";
export { FindFirstUserOrThrowResolver } from \\"./User/FindFirstUserOrThrowResolver\\";
export { FindManyUserResolver } from \\"./User/FindManyUserResolver\\";
export { FindUniqueUserResolver } from \\"./User/FindUniqueUserResolver\\";
export { FindUniqueUserOrThrowResolver } from \\"./User/FindUniqueUserOrThrowResolver\\";
export { GroupByUserResolver } from \\"./User/GroupByUserResolver\\";
export { UpdateManyUserResolver } from \\"./User/UpdateManyUserResolver\\";
export { UpdateOneUserResolver } from \\"./User/UpdateOneUserResolver\\";
export { UpsertOneUserResolver } from \\"./User/UpsertOneUserResolver\\";
"
`;

exports[`crud should properly generate resolver class for single prisma model: argsIndex 1`] = `
"export * from \\"./User/args\\";
"
`;

exports[`crud should properly generate resolver class for single prisma model: crudIndex 1`] = `
"export { UserCrudResolver } from \\"./User/UserCrudResolver\\";
"
`;

exports[`crud should properly generate resolver class for single prisma model: mainIndex 1`] = `
"import * as crudResolversImport from \\"./resolvers/crud/resolvers-crud.index\\";

export * from \\"./enums\\";
export * from \\"./models\\";
export * from \\"./resolvers/crud\\";

export const crudResolvers = Object.values(crudResolversImport) as Function[];

export * from \\"./resolvers/inputs\\";
export * from \\"./resolvers/outputs\\";
export * from \\"./enhance\\";
export * from \\"./scalars\\";

export const resolvers = [
  ...crudResolvers,

] as Function[];
"
`;

exports[`crud should properly generate resolver class when cannot pluralize model name and provided overriding plural: StaffCrudResolver 1`] = `
"import { Args, ArgsType, Context, Field, Float, ID, Info, InputType, Int, Mutation, ObjectType, Parent, Query, ResolveField, Resolver, registerEnumType } from \\"@nestjs/graphql\\";
import type { GraphQLResolveInfo } from \\"graphql\\";
import { AggregateStaffArgs } from \\"./args/AggregateStaffArgs\\";
import { CreateManyAndReturnStaffArgs } from \\"./args/CreateManyAndReturnStaffArgs\\";
import { CreateManyStaffArgs } from \\"./args/CreateManyStaffArgs\\";
import { CreateOneStaffArgs } from \\"./args/CreateOneStaffArgs\\";
import { DeleteManyStaffArgs } from \\"./args/DeleteManyStaffArgs\\";
import { DeleteOneStaffArgs } from \\"./args/DeleteOneStaffArgs\\";
import { FindFirstStaffArgs } from \\"./args/FindFirstStaffArgs\\";
import { FindFirstStaffOrThrowArgs } from \\"./args/FindFirstStaffOrThrowArgs\\";
import { FindManyStaffArgs } from \\"./args/FindManyStaffArgs\\";
import { FindUniqueStaffArgs } from \\"./args/FindUniqueStaffArgs\\";
import { FindUniqueStaffOrThrowArgs } from \\"./args/FindUniqueStaffOrThrowArgs\\";
import { GroupByStaffArgs } from \\"./args/GroupByStaffArgs\\";
import { UpdateManyStaffArgs } from \\"./args/UpdateManyStaffArgs\\";
import { UpdateOneStaffArgs } from \\"./args/UpdateOneStaffArgs\\";
import { UpsertOneStaffArgs } from \\"./args/UpsertOneStaffArgs\\";
import { transformArgsIntoPrismaArgs, transformInfoIntoPrismaArgs, getPrismaFromContext, transformCountFieldIntoSelectRelationsCount, InlineLoader } from \\"../../../helpers\\";
import { Staff } from \\"../../../models/Staff\\";
import { AffectedRowsOutput } from \\"../../outputs/AffectedRowsOutput\\";
import { AggregateStaff } from \\"../../outputs/AggregateStaff\\";
import { CreateManyAndReturnStaff } from \\"../../outputs/CreateManyAndReturnStaff\\";
import { StaffGroupBy } from \\"../../outputs/StaffGroupBy\\";

@Resolver(() => Staff)
export class StaffCrudResolver {
  @Query(() => AggregateStaff, {
    nullable: false
  })
  async aggregateStaff(@Context() ctx: any, @Info() info: GraphQLResolveInfo, @Args() args: AggregateStaffArgs): Promise<AggregateStaff> {
    const afterProcessEvents: ((result: any) => Promise<any>)[] = [];
    const transformedArgsIntoPrismaArgs = await transformArgsIntoPrismaArgs(info, args, ctx, 'Staff', 'staff', 'aggregate', afterProcessEvents);
    const transformedInfoIntoPrismaArgs = transformInfoIntoPrismaArgs(info, 'Staff', 'staff', 'aggregate');
    const result = await getPrismaFromContext(ctx).staff.aggregate({ ...transformedArgsIntoPrismaArgs, ...transformedInfoIntoPrismaArgs, });
    for (const afterProcessEvent of afterProcessEvents) { await afterProcessEvent(result); }

    return result;
  }

  @Mutation(() => AffectedRowsOutput, {
    nullable: false
  })
  async createManyStaff(@Context() ctx: any, @Info() info: GraphQLResolveInfo, @Args() args: CreateManyStaffArgs): Promise<AffectedRowsOutput> {
    const afterProcessEvents: ((result: any) => Promise<any>)[] = [];
    const { _count } = transformInfoIntoPrismaArgs(info, 'Staff', 'staff', 'createMany');
    const transformedArgsIntoPrismaArgs = await transformArgsIntoPrismaArgs(info, args, ctx, 'Staff', 'staff', 'createMany', afterProcessEvents);
    const otherArgs = _count && transformCountFieldIntoSelectRelationsCount(_count, 'Staff', 'staff', 'createMany');
    const result = await getPrismaFromContext(ctx).staff.createMany({ ...transformedArgsIntoPrismaArgs, ...otherArgs, });
    for (const afterProcessEvent of afterProcessEvents) { await afterProcessEvent(result); }

    return result;
  }

  @Mutation(() => [CreateManyAndReturnStaff], {
    nullable: false
  })
  async createManyAndReturnStaff(@Context() ctx: any, @Info() info: GraphQLResolveInfo, @Args() args: CreateManyAndReturnStaffArgs): Promise<CreateManyAndReturnStaff[]> {
    const afterProcessEvents: ((result: any) => Promise<any>)[] = [];
    const { _count } = transformInfoIntoPrismaArgs(info, 'Staff', 'staff', 'createManyAndReturn');
    const transformedArgsIntoPrismaArgs = await transformArgsIntoPrismaArgs(info, args, ctx, 'Staff', 'staff', 'createManyAndReturn', afterProcessEvents);
    const otherArgs = _count && transformCountFieldIntoSelectRelationsCount(_count, 'Staff', 'staff', 'createManyAndReturn');
    const result = await getPrismaFromContext(ctx).staff.createManyAndReturn({ ...transformedArgsIntoPrismaArgs, ...otherArgs, });
    for (const afterProcessEvent of afterProcessEvents) { await afterProcessEvent(result); }

    return result;
  }

  @Mutation(() => Staff, {
    nullable: false
  })
  async createOneStaff(@Context() ctx: any, @Info() info: GraphQLResolveInfo, @Args() args: CreateOneStaffArgs): Promise<Staff> {
    const afterProcessEvents: ((result: any) => Promise<any>)[] = [];
    const { _count } = transformInfoIntoPrismaArgs(info, 'Staff', 'staff', 'create');
    const transformedArgsIntoPrismaArgs = await transformArgsIntoPrismaArgs(info, args, ctx, 'Staff', 'staff', 'create', afterProcessEvents);
    const otherArgs = _count && transformCountFieldIntoSelectRelationsCount(_count, 'Staff', 'staff', 'create');
    const result = await getPrismaFromContext(ctx).staff.create({ ...transformedArgsIntoPrismaArgs, ...otherArgs, });
    for (const afterProcessEvent of afterProcessEvents) { await afterProcessEvent(result); }

    return result;
  }

  @Mutation(() => AffectedRowsOutput, {
    nullable: false
  })
  async deleteManyStaff(@Context() ctx: any, @Info() info: GraphQLResolveInfo, @Args() args: DeleteManyStaffArgs): Promise<AffectedRowsOutput> {
    const afterProcessEvents: ((result: any) => Promise<any>)[] = [];
    const { _count } = transformInfoIntoPrismaArgs(info, 'Staff', 'staff', 'deleteMany');
    const transformedArgsIntoPrismaArgs = await transformArgsIntoPrismaArgs(info, args, ctx, 'Staff', 'staff', 'deleteMany', afterProcessEvents);
    const otherArgs = _count && transformCountFieldIntoSelectRelationsCount(_count, 'Staff', 'staff', 'deleteMany');
    const result = await getPrismaFromContext(ctx).staff.deleteMany({ ...transformedArgsIntoPrismaArgs, ...otherArgs, });
    for (const afterProcessEvent of afterProcessEvents) { await afterProcessEvent(result); }

    return result;
  }

  @Mutation(() => Staff, {
    nullable: true
  })
  async deleteOneStaff(@Context() ctx: any, @Info() info: GraphQLResolveInfo, @Args() args: DeleteOneStaffArgs): Promise<Staff | null> {
    const afterProcessEvents: ((result: any) => Promise<any>)[] = [];
    const { _count } = transformInfoIntoPrismaArgs(info, 'Staff', 'staff', 'delete');
    const transformedArgsIntoPrismaArgs = await transformArgsIntoPrismaArgs(info, args, ctx, 'Staff', 'staff', 'delete', afterProcessEvents);
    const otherArgs = _count && transformCountFieldIntoSelectRelationsCount(_count, 'Staff', 'staff', 'delete');
    const result = await getPrismaFromContext(ctx).staff.delete({ ...transformedArgsIntoPrismaArgs, ...otherArgs, });
    for (const afterProcessEvent of afterProcessEvents) { await afterProcessEvent(result); }

    return result;
  }

  @Query(() => Staff, {
    nullable: true
  })
  async findFirstStaff(@Context() ctx: any, @Info() info: GraphQLResolveInfo, @Args() args: FindFirstStaffArgs): Promise<Staff | null> {
    const afterProcessEvents: ((result: any) => Promise<any>)[] = [];
    const { _count } = transformInfoIntoPrismaArgs(info, 'Staff', 'staff', 'findFirst');
    const transformedArgsIntoPrismaArgs = await transformArgsIntoPrismaArgs(info, args, ctx, 'Staff', 'staff', 'findFirst', afterProcessEvents);
    const otherArgs = _count && transformCountFieldIntoSelectRelationsCount(_count, 'Staff', 'staff', 'findFirst');
    const result = await getPrismaFromContext(ctx).staff.findFirst({ ...transformedArgsIntoPrismaArgs, ...otherArgs, });
    for (const afterProcessEvent of afterProcessEvents) { await afterProcessEvent(result); }

    return result;
  }

  @Query(() => Staff, {
    nullable: true
  })
  async findFirstStaffOrThrow(@Context() ctx: any, @Info() info: GraphQLResolveInfo, @Args() args: FindFirstStaffOrThrowArgs): Promise<Staff | null> {
    const afterProcessEvents: ((result: any) => Promise<any>)[] = [];
    const { _count } = transformInfoIntoPrismaArgs(info, 'Staff', 'staff', 'findFirstOrThrow');
    const transformedArgsIntoPrismaArgs = await transformArgsIntoPrismaArgs(info, args, ctx, 'Staff', 'staff', 'findFirstOrThrow', afterProcessEvents);
    const otherArgs = _count && transformCountFieldIntoSelectRelationsCount(_count, 'Staff', 'staff', 'findFirstOrThrow');
    const result = await getPrismaFromContext(ctx).staff.findFirstOrThrow({ ...transformedArgsIntoPrismaArgs, ...otherArgs, });
    for (const afterProcessEvent of afterProcessEvents) { await afterProcessEvent(result); }

    return result;
  }

  @Query(() => [Staff], {
    nullable: false
  })
  async staffMembers(@Context() ctx: any, @Info() info: GraphQLResolveInfo, @Args() args: FindManyStaffArgs): Promise<Staff[]> {
    const afterProcessEvents: ((result: any) => Promise<any>)[] = [];
    const { _count } = transformInfoIntoPrismaArgs(info, 'Staff', 'staff', 'findMany');
    const transformedArgsIntoPrismaArgs = await transformArgsIntoPrismaArgs(info, args, ctx, 'Staff', 'staff', 'findMany', afterProcessEvents);
    const otherArgs = _count && transformCountFieldIntoSelectRelationsCount(_count, 'Staff', 'staff', 'findMany');
    const result = await getPrismaFromContext(ctx).staff.findMany({ ...transformedArgsIntoPrismaArgs, ...otherArgs, });
    for (const afterProcessEvent of afterProcessEvents) { await afterProcessEvent(result); }

    return result;
  }

  @Query(() => Staff, {
    nullable: true
  })
  async staff(@Context() ctx: any, @Info() info: GraphQLResolveInfo, @Args() args: FindUniqueStaffArgs): Promise<Staff | null> {
    const afterProcessEvents: ((result: any) => Promise<any>)[] = [];
    const { _count } = transformInfoIntoPrismaArgs(info, 'Staff', 'staff', 'findUnique');
    const transformedArgsIntoPrismaArgs = await transformArgsIntoPrismaArgs(info, args, ctx, 'Staff', 'staff', 'findUnique', afterProcessEvents);
    const otherArgs = _count && transformCountFieldIntoSelectRelationsCount(_count, 'Staff', 'staff', 'findUnique');
    const result = await getPrismaFromContext(ctx).staff.findUnique({ ...transformedArgsIntoPrismaArgs, ...otherArgs, });
    for (const afterProcessEvent of afterProcessEvents) { await afterProcessEvent(result); }

    return result;
  }

  @Query(() => Staff, {
    nullable: true
  })
  async getStaff(@Context() ctx: any, @Info() info: GraphQLResolveInfo, @Args() args: FindUniqueStaffOrThrowArgs): Promise<Staff | null> {
    const afterProcessEvents: ((result: any) => Promise<any>)[] = [];
    const { _count } = transformInfoIntoPrismaArgs(info, 'Staff', 'staff', 'findUniqueOrThrow');
    const transformedArgsIntoPrismaArgs = await transformArgsIntoPrismaArgs(info, args, ctx, 'Staff', 'staff', 'findUniqueOrThrow', afterProcessEvents);
    const otherArgs = _count && transformCountFieldIntoSelectRelationsCount(_count, 'Staff', 'staff', 'findUniqueOrThrow');
    const result = await getPrismaFromContext(ctx).staff.findUniqueOrThrow({ ...transformedArgsIntoPrismaArgs, ...otherArgs, });
    for (const afterProcessEvent of afterProcessEvents) { await afterProcessEvent(result); }

    return result;
  }

  @Query(() => [StaffGroupBy], {
    nullable: false
  })
  async groupByStaff(@Context() ctx: any, @Info() info: GraphQLResolveInfo, @Args() args: GroupByStaffArgs): Promise<StaffGroupBy[]> {
    const afterProcessEvents: ((result: any) => Promise<any>)[] = [];
    const { _count, _avg, _sum, _min, _max } = transformInfoIntoPrismaArgs(info, 'Staff', 'staff', 'groupBy');
    const transformedArgsIntoPrismaArgs = await transformArgsIntoPrismaArgs(info, args, ctx, 'Staff', 'staff', 'groupBy', afterProcessEvents);
    const groupByArgs = Object.fromEntries(Object.entries({ _count, _avg, _sum, _min, _max }).filter(([_, v]) => v != null));
    const result = await getPrismaFromContext(ctx).staff.groupBy({ ...transformedArgsIntoPrismaArgs, ...groupByArgs, });
    for (const afterProcessEvent of afterProcessEvents) { await afterProcessEvent(result); }

    return result;
  }

  @Mutation(() => AffectedRowsOutput, {
    nullable: false
  })
  async updateManyStaff(@Context() ctx: any, @Info() info: GraphQLResolveInfo, @Args() args: UpdateManyStaffArgs): Promise<AffectedRowsOutput> {
    const afterProcessEvents: ((result: any) => Promise<any>)[] = [];
    const { _count } = transformInfoIntoPrismaArgs(info, 'Staff', 'staff', 'updateMany');
    const transformedArgsIntoPrismaArgs = await transformArgsIntoPrismaArgs(info, args, ctx, 'Staff', 'staff', 'updateMany', afterProcessEvents);
    const otherArgs = _count && transformCountFieldIntoSelectRelationsCount(_count, 'Staff', 'staff', 'updateMany');
    const result = await getPrismaFromContext(ctx).staff.updateMany({ ...transformedArgsIntoPrismaArgs, ...otherArgs, });
    for (const afterProcessEvent of afterProcessEvents) { await afterProcessEvent(result); }

    return result;
  }

  @Mutation(() => Staff, {
    nullable: true
  })
  async updateOneStaff(@Context() ctx: any, @Info() info: GraphQLResolveInfo, @Args() args: UpdateOneStaffArgs): Promise<Staff | null> {
    const afterProcessEvents: ((result: any) => Promise<any>)[] = [];
    const { _count } = transformInfoIntoPrismaArgs(info, 'Staff', 'staff', 'update');
    const transformedArgsIntoPrismaArgs = await transformArgsIntoPrismaArgs(info, args, ctx, 'Staff', 'staff', 'update', afterProcessEvents);
    const otherArgs = _count && transformCountFieldIntoSelectRelationsCount(_count, 'Staff', 'staff', 'update');
    const result = await getPrismaFromContext(ctx).staff.update({ ...transformedArgsIntoPrismaArgs, ...otherArgs, });
    for (const afterProcessEvent of afterProcessEvents) { await afterProcessEvent(result); }

    return result;
  }

  @Mutation(() => Staff, {
    nullable: false
  })
  async upsertOneStaff(@Context() ctx: any, @Info() info: GraphQLResolveInfo, @Args() args: UpsertOneStaffArgs): Promise<Staff> {
    const afterProcessEvents: ((result: any) => Promise<any>)[] = [];
    const { _count } = transformInfoIntoPrismaArgs(info, 'Staff', 'staff', 'upsert');
    const transformedArgsIntoPrismaArgs = await transformArgsIntoPrismaArgs(info, args, ctx, 'Staff', 'staff', 'upsert', afterProcessEvents);
    const otherArgs = _count && transformCountFieldIntoSelectRelationsCount(_count, 'Staff', 'staff', 'upsert');
    const result = await getPrismaFromContext(ctx).staff.upsert({ ...transformedArgsIntoPrismaArgs, ...otherArgs, });
    for (const afterProcessEvent of afterProcessEvents) { await afterProcessEvent(result); }

    return result;
  }
}
"
`;

exports[`crud should properly generate resolver class when cannot pluralize model name: StaffCrudResolver 1`] = `
"import { Args, ArgsType, Context, Field, Float, ID, Info, InputType, Int, Mutation, ObjectType, Parent, Query, ResolveField, Resolver, registerEnumType } from \\"@nestjs/graphql\\";
import type { GraphQLResolveInfo } from \\"graphql\\";
import { AggregateStaffArgs } from \\"./args/AggregateStaffArgs\\";
import { CreateManyAndReturnStaffArgs } from \\"./args/CreateManyAndReturnStaffArgs\\";
import { CreateManyStaffArgs } from \\"./args/CreateManyStaffArgs\\";
import { CreateOneStaffArgs } from \\"./args/CreateOneStaffArgs\\";
import { DeleteManyStaffArgs } from \\"./args/DeleteManyStaffArgs\\";
import { DeleteOneStaffArgs } from \\"./args/DeleteOneStaffArgs\\";
import { FindFirstStaffArgs } from \\"./args/FindFirstStaffArgs\\";
import { FindFirstStaffOrThrowArgs } from \\"./args/FindFirstStaffOrThrowArgs\\";
import { FindManyStaffArgs } from \\"./args/FindManyStaffArgs\\";
import { FindUniqueStaffArgs } from \\"./args/FindUniqueStaffArgs\\";
import { FindUniqueStaffOrThrowArgs } from \\"./args/FindUniqueStaffOrThrowArgs\\";
import { GroupByStaffArgs } from \\"./args/GroupByStaffArgs\\";
import { UpdateManyStaffArgs } from \\"./args/UpdateManyStaffArgs\\";
import { UpdateOneStaffArgs } from \\"./args/UpdateOneStaffArgs\\";
import { UpsertOneStaffArgs } from \\"./args/UpsertOneStaffArgs\\";
import { transformArgsIntoPrismaArgs, transformInfoIntoPrismaArgs, getPrismaFromContext, transformCountFieldIntoSelectRelationsCount, InlineLoader } from \\"../../../helpers\\";
import { Staff } from \\"../../../models/Staff\\";
import { AffectedRowsOutput } from \\"../../outputs/AffectedRowsOutput\\";
import { AggregateStaff } from \\"../../outputs/AggregateStaff\\";
import { CreateManyAndReturnStaff } from \\"../../outputs/CreateManyAndReturnStaff\\";
import { StaffGroupBy } from \\"../../outputs/StaffGroupBy\\";

@Resolver(() => Staff)
export class StaffCrudResolver {
  @Query(() => AggregateStaff, {
    nullable: false
  })
  async aggregateStaff(@Context() ctx: any, @Info() info: GraphQLResolveInfo, @Args() args: AggregateStaffArgs): Promise<AggregateStaff> {
    const afterProcessEvents: ((result: any) => Promise<any>)[] = [];
    const transformedArgsIntoPrismaArgs = await transformArgsIntoPrismaArgs(info, args, ctx, 'Staff', 'staff', 'aggregate', afterProcessEvents);
    const transformedInfoIntoPrismaArgs = transformInfoIntoPrismaArgs(info, 'Staff', 'staff', 'aggregate');
    const result = await getPrismaFromContext(ctx).staff.aggregate({ ...transformedArgsIntoPrismaArgs, ...transformedInfoIntoPrismaArgs, });
    for (const afterProcessEvent of afterProcessEvents) { await afterProcessEvent(result); }

    return result;
  }

  @Mutation(() => AffectedRowsOutput, {
    nullable: false
  })
  async createManyStaff(@Context() ctx: any, @Info() info: GraphQLResolveInfo, @Args() args: CreateManyStaffArgs): Promise<AffectedRowsOutput> {
    const afterProcessEvents: ((result: any) => Promise<any>)[] = [];
    const { _count } = transformInfoIntoPrismaArgs(info, 'Staff', 'staff', 'createMany');
    const transformedArgsIntoPrismaArgs = await transformArgsIntoPrismaArgs(info, args, ctx, 'Staff', 'staff', 'createMany', afterProcessEvents);
    const otherArgs = _count && transformCountFieldIntoSelectRelationsCount(_count, 'Staff', 'staff', 'createMany');
    const result = await getPrismaFromContext(ctx).staff.createMany({ ...transformedArgsIntoPrismaArgs, ...otherArgs, });
    for (const afterProcessEvent of afterProcessEvents) { await afterProcessEvent(result); }

    return result;
  }

  @Mutation(() => [CreateManyAndReturnStaff], {
    nullable: false
  })
  async createManyAndReturnStaff(@Context() ctx: any, @Info() info: GraphQLResolveInfo, @Args() args: CreateManyAndReturnStaffArgs): Promise<CreateManyAndReturnStaff[]> {
    const afterProcessEvents: ((result: any) => Promise<any>)[] = [];
    const { _count } = transformInfoIntoPrismaArgs(info, 'Staff', 'staff', 'createManyAndReturn');
    const transformedArgsIntoPrismaArgs = await transformArgsIntoPrismaArgs(info, args, ctx, 'Staff', 'staff', 'createManyAndReturn', afterProcessEvents);
    const otherArgs = _count && transformCountFieldIntoSelectRelationsCount(_count, 'Staff', 'staff', 'createManyAndReturn');
    const result = await getPrismaFromContext(ctx).staff.createManyAndReturn({ ...transformedArgsIntoPrismaArgs, ...otherArgs, });
    for (const afterProcessEvent of afterProcessEvents) { await afterProcessEvent(result); }

    return result;
  }

  @Mutation(() => Staff, {
    nullable: false
  })
  async createOneStaff(@Context() ctx: any, @Info() info: GraphQLResolveInfo, @Args() args: CreateOneStaffArgs): Promise<Staff> {
    const afterProcessEvents: ((result: any) => Promise<any>)[] = [];
    const { _count } = transformInfoIntoPrismaArgs(info, 'Staff', 'staff', 'create');
    const transformedArgsIntoPrismaArgs = await transformArgsIntoPrismaArgs(info, args, ctx, 'Staff', 'staff', 'create', afterProcessEvents);
    const otherArgs = _count && transformCountFieldIntoSelectRelationsCount(_count, 'Staff', 'staff', 'create');
    const result = await getPrismaFromContext(ctx).staff.create({ ...transformedArgsIntoPrismaArgs, ...otherArgs, });
    for (const afterProcessEvent of afterProcessEvents) { await afterProcessEvent(result); }

    return result;
  }

  @Mutation(() => AffectedRowsOutput, {
    nullable: false
  })
  async deleteManyStaff(@Context() ctx: any, @Info() info: GraphQLResolveInfo, @Args() args: DeleteManyStaffArgs): Promise<AffectedRowsOutput> {
    const afterProcessEvents: ((result: any) => Promise<any>)[] = [];
    const { _count } = transformInfoIntoPrismaArgs(info, 'Staff', 'staff', 'deleteMany');
    const transformedArgsIntoPrismaArgs = await transformArgsIntoPrismaArgs(info, args, ctx, 'Staff', 'staff', 'deleteMany', afterProcessEvents);
    const otherArgs = _count && transformCountFieldIntoSelectRelationsCount(_count, 'Staff', 'staff', 'deleteMany');
    const result = await getPrismaFromContext(ctx).staff.deleteMany({ ...transformedArgsIntoPrismaArgs, ...otherArgs, });
    for (const afterProcessEvent of afterProcessEvents) { await afterProcessEvent(result); }

    return result;
  }

  @Mutation(() => Staff, {
    nullable: true
  })
  async deleteOneStaff(@Context() ctx: any, @Info() info: GraphQLResolveInfo, @Args() args: DeleteOneStaffArgs): Promise<Staff | null> {
    const afterProcessEvents: ((result: any) => Promise<any>)[] = [];
    const { _count } = transformInfoIntoPrismaArgs(info, 'Staff', 'staff', 'delete');
    const transformedArgsIntoPrismaArgs = await transformArgsIntoPrismaArgs(info, args, ctx, 'Staff', 'staff', 'delete', afterProcessEvents);
    const otherArgs = _count && transformCountFieldIntoSelectRelationsCount(_count, 'Staff', 'staff', 'delete');
    const result = await getPrismaFromContext(ctx).staff.delete({ ...transformedArgsIntoPrismaArgs, ...otherArgs, });
    for (const afterProcessEvent of afterProcessEvents) { await afterProcessEvent(result); }

    return result;
  }

  @Query(() => Staff, {
    nullable: true
  })
  async findFirstStaff(@Context() ctx: any, @Info() info: GraphQLResolveInfo, @Args() args: FindFirstStaffArgs): Promise<Staff | null> {
    const afterProcessEvents: ((result: any) => Promise<any>)[] = [];
    const { _count } = transformInfoIntoPrismaArgs(info, 'Staff', 'staff', 'findFirst');
    const transformedArgsIntoPrismaArgs = await transformArgsIntoPrismaArgs(info, args, ctx, 'Staff', 'staff', 'findFirst', afterProcessEvents);
    const otherArgs = _count && transformCountFieldIntoSelectRelationsCount(_count, 'Staff', 'staff', 'findFirst');
    const result = await getPrismaFromContext(ctx).staff.findFirst({ ...transformedArgsIntoPrismaArgs, ...otherArgs, });
    for (const afterProcessEvent of afterProcessEvents) { await afterProcessEvent(result); }

    return result;
  }

  @Query(() => Staff, {
    nullable: true
  })
  async findFirstStaffOrThrow(@Context() ctx: any, @Info() info: GraphQLResolveInfo, @Args() args: FindFirstStaffOrThrowArgs): Promise<Staff | null> {
    const afterProcessEvents: ((result: any) => Promise<any>)[] = [];
    const { _count } = transformInfoIntoPrismaArgs(info, 'Staff', 'staff', 'findFirstOrThrow');
    const transformedArgsIntoPrismaArgs = await transformArgsIntoPrismaArgs(info, args, ctx, 'Staff', 'staff', 'findFirstOrThrow', afterProcessEvents);
    const otherArgs = _count && transformCountFieldIntoSelectRelationsCount(_count, 'Staff', 'staff', 'findFirstOrThrow');
    const result = await getPrismaFromContext(ctx).staff.findFirstOrThrow({ ...transformedArgsIntoPrismaArgs, ...otherArgs, });
    for (const afterProcessEvent of afterProcessEvents) { await afterProcessEvent(result); }

    return result;
  }

  @Query(() => [Staff], {
    nullable: false
  })
  async findManyStaff(@Context() ctx: any, @Info() info: GraphQLResolveInfo, @Args() args: FindManyStaffArgs): Promise<Staff[]> {
    const afterProcessEvents: ((result: any) => Promise<any>)[] = [];
    const { _count } = transformInfoIntoPrismaArgs(info, 'Staff', 'staff', 'findMany');
    const transformedArgsIntoPrismaArgs = await transformArgsIntoPrismaArgs(info, args, ctx, 'Staff', 'staff', 'findMany', afterProcessEvents);
    const otherArgs = _count && transformCountFieldIntoSelectRelationsCount(_count, 'Staff', 'staff', 'findMany');
    const result = await getPrismaFromContext(ctx).staff.findMany({ ...transformedArgsIntoPrismaArgs, ...otherArgs, });
    for (const afterProcessEvent of afterProcessEvents) { await afterProcessEvent(result); }

    return result;
  }

  @Query(() => Staff, {
    nullable: true
  })
  async findUniqueStaff(@Context() ctx: any, @Info() info: GraphQLResolveInfo, @Args() args: FindUniqueStaffArgs): Promise<Staff | null> {
    const afterProcessEvents: ((result: any) => Promise<any>)[] = [];
    const { _count } = transformInfoIntoPrismaArgs(info, 'Staff', 'staff', 'findUnique');
    const transformedArgsIntoPrismaArgs = await transformArgsIntoPrismaArgs(info, args, ctx, 'Staff', 'staff', 'findUnique', afterProcessEvents);
    const otherArgs = _count && transformCountFieldIntoSelectRelationsCount(_count, 'Staff', 'staff', 'findUnique');
    const result = await getPrismaFromContext(ctx).staff.findUnique({ ...transformedArgsIntoPrismaArgs, ...otherArgs, });
    for (const afterProcessEvent of afterProcessEvents) { await afterProcessEvent(result); }

    return result;
  }

  @Query(() => Staff, {
    nullable: true
  })
  async findUniqueStaffOrThrow(@Context() ctx: any, @Info() info: GraphQLResolveInfo, @Args() args: FindUniqueStaffOrThrowArgs): Promise<Staff | null> {
    const afterProcessEvents: ((result: any) => Promise<any>)[] = [];
    const { _count } = transformInfoIntoPrismaArgs(info, 'Staff', 'staff', 'findUniqueOrThrow');
    const transformedArgsIntoPrismaArgs = await transformArgsIntoPrismaArgs(info, args, ctx, 'Staff', 'staff', 'findUniqueOrThrow', afterProcessEvents);
    const otherArgs = _count && transformCountFieldIntoSelectRelationsCount(_count, 'Staff', 'staff', 'findUniqueOrThrow');
    const result = await getPrismaFromContext(ctx).staff.findUniqueOrThrow({ ...transformedArgsIntoPrismaArgs, ...otherArgs, });
    for (const afterProcessEvent of afterProcessEvents) { await afterProcessEvent(result); }

    return result;
  }

  @Query(() => [StaffGroupBy], {
    nullable: false
  })
  async groupByStaff(@Context() ctx: any, @Info() info: GraphQLResolveInfo, @Args() args: GroupByStaffArgs): Promise<StaffGroupBy[]> {
    const afterProcessEvents: ((result: any) => Promise<any>)[] = [];
    const { _count, _avg, _sum, _min, _max } = transformInfoIntoPrismaArgs(info, 'Staff', 'staff', 'groupBy');
    const transformedArgsIntoPrismaArgs = await transformArgsIntoPrismaArgs(info, args, ctx, 'Staff', 'staff', 'groupBy', afterProcessEvents);
    const groupByArgs = Object.fromEntries(Object.entries({ _count, _avg, _sum, _min, _max }).filter(([_, v]) => v != null));
    const result = await getPrismaFromContext(ctx).staff.groupBy({ ...transformedArgsIntoPrismaArgs, ...groupByArgs, });
    for (const afterProcessEvent of afterProcessEvents) { await afterProcessEvent(result); }

    return result;
  }

  @Mutation(() => AffectedRowsOutput, {
    nullable: false
  })
  async updateManyStaff(@Context() ctx: any, @Info() info: GraphQLResolveInfo, @Args() args: UpdateManyStaffArgs): Promise<AffectedRowsOutput> {
    const afterProcessEvents: ((result: any) => Promise<any>)[] = [];
    const { _count } = transformInfoIntoPrismaArgs(info, 'Staff', 'staff', 'updateMany');
    const transformedArgsIntoPrismaArgs = await transformArgsIntoPrismaArgs(info, args, ctx, 'Staff', 'staff', 'updateMany', afterProcessEvents);
    const otherArgs = _count && transformCountFieldIntoSelectRelationsCount(_count, 'Staff', 'staff', 'updateMany');
    const result = await getPrismaFromContext(ctx).staff.updateMany({ ...transformedArgsIntoPrismaArgs, ...otherArgs, });
    for (const afterProcessEvent of afterProcessEvents) { await afterProcessEvent(result); }

    return result;
  }

  @Mutation(() => Staff, {
    nullable: true
  })
  async updateOneStaff(@Context() ctx: any, @Info() info: GraphQLResolveInfo, @Args() args: UpdateOneStaffArgs): Promise<Staff | null> {
    const afterProcessEvents: ((result: any) => Promise<any>)[] = [];
    const { _count } = transformInfoIntoPrismaArgs(info, 'Staff', 'staff', 'update');
    const transformedArgsIntoPrismaArgs = await transformArgsIntoPrismaArgs(info, args, ctx, 'Staff', 'staff', 'update', afterProcessEvents);
    const otherArgs = _count && transformCountFieldIntoSelectRelationsCount(_count, 'Staff', 'staff', 'update');
    const result = await getPrismaFromContext(ctx).staff.update({ ...transformedArgsIntoPrismaArgs, ...otherArgs, });
    for (const afterProcessEvent of afterProcessEvents) { await afterProcessEvent(result); }

    return result;
  }

  @Mutation(() => Staff, {
    nullable: false
  })
  async upsertOneStaff(@Context() ctx: any, @Info() info: GraphQLResolveInfo, @Args() args: UpsertOneStaffArgs): Promise<Staff> {
    const afterProcessEvents: ((result: any) => Promise<any>)[] = [];
    const { _count } = transformInfoIntoPrismaArgs(info, 'Staff', 'staff', 'upsert');
    const transformedArgsIntoPrismaArgs = await transformArgsIntoPrismaArgs(info, args, ctx, 'Staff', 'staff', 'upsert', afterProcessEvents);
    const otherArgs = _count && transformCountFieldIntoSelectRelationsCount(_count, 'Staff', 'staff', 'upsert');
    const result = await getPrismaFromContext(ctx).staff.upsert({ ...transformedArgsIntoPrismaArgs, ...otherArgs, });
    for (const afterProcessEvent of afterProcessEvents) { await afterProcessEvent(result); }

    return result;
  }
}
"
`;

exports[`crud should properly generate resolver class when useOriginalMapping is used: FindUniqueUserOrThrowResolver 1`] = `
"import { Args, ArgsType, Context, Field, Float, ID, Info, InputType, Int, Mutation, ObjectType, Parent, Query, ResolveField, Resolver, registerEnumType } from \\"@nestjs/graphql\\";
import type { GraphQLResolveInfo } from \\"graphql\\";
import { FindUniqueUserOrThrowArgs } from \\"./args/FindUniqueUserOrThrowArgs\\";
import { User } from \\"../../../models/User\\";
import { transformArgsIntoPrismaArgs, transformInfoIntoPrismaArgs, getPrismaFromContext, transformCountFieldIntoSelectRelationsCount, InlineLoader } from \\"../../../helpers\\";

@Resolver(() => User)
export class FindUniqueUserOrThrowResolver {
  @Query(() => User, {
    nullable: true
  })
  async findUniqueUserOrThrow(@Context() ctx: any, @Info() info: GraphQLResolveInfo, @Args() args: FindUniqueUserOrThrowArgs): Promise<User | null> {
    const afterProcessEvents: ((result: any) => Promise<any>)[] = [];
    const { _count } = transformInfoIntoPrismaArgs(info, 'User', 'user', 'findUniqueOrThrow');
    const transformedArgsIntoPrismaArgs = await transformArgsIntoPrismaArgs(info, args, ctx, 'User', 'user', 'findUniqueOrThrow', afterProcessEvents);
    const otherArgs = _count && transformCountFieldIntoSelectRelationsCount(_count, 'User', 'user', 'findUniqueOrThrow');
    const result = await getPrismaFromContext(ctx).user.findUniqueOrThrow({ ...transformedArgsIntoPrismaArgs, ...otherArgs, });
    for (const afterProcessEvent of afterProcessEvents) { await afterProcessEvent(result); }

    return result;
  }
}
"
`;

exports[`crud should properly generate resolver class when useOriginalMapping is used: FindUniqueUserResolver 1`] = `
"import { Args, ArgsType, Context, Field, Float, ID, Info, InputType, Int, Mutation, ObjectType, Parent, Query, ResolveField, Resolver, registerEnumType } from \\"@nestjs/graphql\\";
import type { GraphQLResolveInfo } from \\"graphql\\";
import { FindUniqueUserArgs } from \\"./args/FindUniqueUserArgs\\";
import { User } from \\"../../../models/User\\";
import { transformArgsIntoPrismaArgs, transformInfoIntoPrismaArgs, getPrismaFromContext, transformCountFieldIntoSelectRelationsCount, InlineLoader } from \\"../../../helpers\\";

@Resolver(() => User)
export class FindUniqueUserResolver {
  @Query(() => User, {
    nullable: true
  })
  async findUniqueUser(@Context() ctx: any, @Info() info: GraphQLResolveInfo, @Args() args: FindUniqueUserArgs): Promise<User | null> {
    const afterProcessEvents: ((result: any) => Promise<any>)[] = [];
    const { _count } = transformInfoIntoPrismaArgs(info, 'User', 'user', 'findUnique');
    const transformedArgsIntoPrismaArgs = await transformArgsIntoPrismaArgs(info, args, ctx, 'User', 'user', 'findUnique', afterProcessEvents);
    const otherArgs = _count && transformCountFieldIntoSelectRelationsCount(_count, 'User', 'user', 'findUnique');
    const result = await getPrismaFromContext(ctx).user.findUnique({ ...transformedArgsIntoPrismaArgs, ...otherArgs, });
    for (const afterProcessEvent of afterProcessEvents) { await afterProcessEvent(result); }

    return result;
  }
}
"
`;

exports[`crud should properly generate resolver class when useOriginalMapping is used: UserCrudResolver 1`] = `
"import { Args, ArgsType, Context, Field, Float, ID, Info, InputType, Int, Mutation, ObjectType, Parent, Query, ResolveField, Resolver, registerEnumType } from \\"@nestjs/graphql\\";
import type { GraphQLResolveInfo } from \\"graphql\\";
import { AggregateUserArgs } from \\"./args/AggregateUserArgs\\";
import { CreateManyAndReturnUserArgs } from \\"./args/CreateManyAndReturnUserArgs\\";
import { CreateManyUserArgs } from \\"./args/CreateManyUserArgs\\";
import { CreateOneUserArgs } from \\"./args/CreateOneUserArgs\\";
import { DeleteManyUserArgs } from \\"./args/DeleteManyUserArgs\\";
import { DeleteOneUserArgs } from \\"./args/DeleteOneUserArgs\\";
import { FindFirstUserArgs } from \\"./args/FindFirstUserArgs\\";
import { FindFirstUserOrThrowArgs } from \\"./args/FindFirstUserOrThrowArgs\\";
import { FindManyUserArgs } from \\"./args/FindManyUserArgs\\";
import { FindUniqueUserArgs } from \\"./args/FindUniqueUserArgs\\";
import { FindUniqueUserOrThrowArgs } from \\"./args/FindUniqueUserOrThrowArgs\\";
import { GroupByUserArgs } from \\"./args/GroupByUserArgs\\";
import { UpdateManyUserArgs } from \\"./args/UpdateManyUserArgs\\";
import { UpdateOneUserArgs } from \\"./args/UpdateOneUserArgs\\";
import { UpsertOneUserArgs } from \\"./args/UpsertOneUserArgs\\";
import { transformArgsIntoPrismaArgs, transformInfoIntoPrismaArgs, getPrismaFromContext, transformCountFieldIntoSelectRelationsCount, InlineLoader } from \\"../../../helpers\\";
import { User } from \\"../../../models/User\\";
import { AffectedRowsOutput } from \\"../../outputs/AffectedRowsOutput\\";
import { AggregateUser } from \\"../../outputs/AggregateUser\\";
import { CreateManyAndReturnUser } from \\"../../outputs/CreateManyAndReturnUser\\";
import { UserGroupBy } from \\"../../outputs/UserGroupBy\\";

@Resolver(() => User)
export class UserCrudResolver {
  @Query(() => AggregateUser, {
    nullable: false
  })
  async aggregateUser(@Context() ctx: any, @Info() info: GraphQLResolveInfo, @Args() args: AggregateUserArgs): Promise<AggregateUser> {
    const afterProcessEvents: ((result: any) => Promise<any>)[] = [];
    const transformedArgsIntoPrismaArgs = await transformArgsIntoPrismaArgs(info, args, ctx, 'User', 'user', 'aggregate', afterProcessEvents);
    const transformedInfoIntoPrismaArgs = transformInfoIntoPrismaArgs(info, 'User', 'user', 'aggregate');
    const result = await getPrismaFromContext(ctx).user.aggregate({ ...transformedArgsIntoPrismaArgs, ...transformedInfoIntoPrismaArgs, });
    for (const afterProcessEvent of afterProcessEvents) { await afterProcessEvent(result); }

    return result;
  }

  @Mutation(() => AffectedRowsOutput, {
    nullable: false
  })
  async createManyUser(@Context() ctx: any, @Info() info: GraphQLResolveInfo, @Args() args: CreateManyUserArgs): Promise<AffectedRowsOutput> {
    const afterProcessEvents: ((result: any) => Promise<any>)[] = [];
    const { _count } = transformInfoIntoPrismaArgs(info, 'User', 'user', 'createMany');
    const transformedArgsIntoPrismaArgs = await transformArgsIntoPrismaArgs(info, args, ctx, 'User', 'user', 'createMany', afterProcessEvents);
    const otherArgs = _count && transformCountFieldIntoSelectRelationsCount(_count, 'User', 'user', 'createMany');
    const result = await getPrismaFromContext(ctx).user.createMany({ ...transformedArgsIntoPrismaArgs, ...otherArgs, });
    for (const afterProcessEvent of afterProcessEvents) { await afterProcessEvent(result); }

    return result;
  }

  @Mutation(() => [CreateManyAndReturnUser], {
    nullable: false
  })
  async createManyAndReturnUser(@Context() ctx: any, @Info() info: GraphQLResolveInfo, @Args() args: CreateManyAndReturnUserArgs): Promise<CreateManyAndReturnUser[]> {
    const afterProcessEvents: ((result: any) => Promise<any>)[] = [];
    const { _count } = transformInfoIntoPrismaArgs(info, 'User', 'user', 'createManyAndReturn');
    const transformedArgsIntoPrismaArgs = await transformArgsIntoPrismaArgs(info, args, ctx, 'User', 'user', 'createManyAndReturn', afterProcessEvents);
    const otherArgs = _count && transformCountFieldIntoSelectRelationsCount(_count, 'User', 'user', 'createManyAndReturn');
    const result = await getPrismaFromContext(ctx).user.createManyAndReturn({ ...transformedArgsIntoPrismaArgs, ...otherArgs, });
    for (const afterProcessEvent of afterProcessEvents) { await afterProcessEvent(result); }

    return result;
  }

  @Mutation(() => User, {
    nullable: false
  })
  async createOneUser(@Context() ctx: any, @Info() info: GraphQLResolveInfo, @Args() args: CreateOneUserArgs): Promise<User> {
    const afterProcessEvents: ((result: any) => Promise<any>)[] = [];
    const { _count } = transformInfoIntoPrismaArgs(info, 'User', 'user', 'create');
    const transformedArgsIntoPrismaArgs = await transformArgsIntoPrismaArgs(info, args, ctx, 'User', 'user', 'create', afterProcessEvents);
    const otherArgs = _count && transformCountFieldIntoSelectRelationsCount(_count, 'User', 'user', 'create');
    const result = await getPrismaFromContext(ctx).user.create({ ...transformedArgsIntoPrismaArgs, ...otherArgs, });
    for (const afterProcessEvent of afterProcessEvents) { await afterProcessEvent(result); }

    return result;
  }

  @Mutation(() => AffectedRowsOutput, {
    nullable: false
  })
  async deleteManyUser(@Context() ctx: any, @Info() info: GraphQLResolveInfo, @Args() args: DeleteManyUserArgs): Promise<AffectedRowsOutput> {
    const afterProcessEvents: ((result: any) => Promise<any>)[] = [];
    const { _count } = transformInfoIntoPrismaArgs(info, 'User', 'user', 'deleteMany');
    const transformedArgsIntoPrismaArgs = await transformArgsIntoPrismaArgs(info, args, ctx, 'User', 'user', 'deleteMany', afterProcessEvents);
    const otherArgs = _count && transformCountFieldIntoSelectRelationsCount(_count, 'User', 'user', 'deleteMany');
    const result = await getPrismaFromContext(ctx).user.deleteMany({ ...transformedArgsIntoPrismaArgs, ...otherArgs, });
    for (const afterProcessEvent of afterProcessEvents) { await afterProcessEvent(result); }

    return result;
  }

  @Mutation(() => User, {
    nullable: true
  })
  async deleteOneUser(@Context() ctx: any, @Info() info: GraphQLResolveInfo, @Args() args: DeleteOneUserArgs): Promise<User | null> {
    const afterProcessEvents: ((result: any) => Promise<any>)[] = [];
    const { _count } = transformInfoIntoPrismaArgs(info, 'User', 'user', 'delete');
    const transformedArgsIntoPrismaArgs = await transformArgsIntoPrismaArgs(info, args, ctx, 'User', 'user', 'delete', afterProcessEvents);
    const otherArgs = _count && transformCountFieldIntoSelectRelationsCount(_count, 'User', 'user', 'delete');
    const result = await getPrismaFromContext(ctx).user.delete({ ...transformedArgsIntoPrismaArgs, ...otherArgs, });
    for (const afterProcessEvent of afterProcessEvents) { await afterProcessEvent(result); }

    return result;
  }

  @Query(() => User, {
    nullable: true
  })
  async findFirstUser(@Context() ctx: any, @Info() info: GraphQLResolveInfo, @Args() args: FindFirstUserArgs): Promise<User | null> {
    const afterProcessEvents: ((result: any) => Promise<any>)[] = [];
    const { _count } = transformInfoIntoPrismaArgs(info, 'User', 'user', 'findFirst');
    const transformedArgsIntoPrismaArgs = await transformArgsIntoPrismaArgs(info, args, ctx, 'User', 'user', 'findFirst', afterProcessEvents);
    const otherArgs = _count && transformCountFieldIntoSelectRelationsCount(_count, 'User', 'user', 'findFirst');
    const result = await getPrismaFromContext(ctx).user.findFirst({ ...transformedArgsIntoPrismaArgs, ...otherArgs, });
    for (const afterProcessEvent of afterProcessEvents) { await afterProcessEvent(result); }

    return result;
  }

  @Query(() => User, {
    nullable: true
  })
  async findFirstUserOrThrow(@Context() ctx: any, @Info() info: GraphQLResolveInfo, @Args() args: FindFirstUserOrThrowArgs): Promise<User | null> {
    const afterProcessEvents: ((result: any) => Promise<any>)[] = [];
    const { _count } = transformInfoIntoPrismaArgs(info, 'User', 'user', 'findFirstOrThrow');
    const transformedArgsIntoPrismaArgs = await transformArgsIntoPrismaArgs(info, args, ctx, 'User', 'user', 'findFirstOrThrow', afterProcessEvents);
    const otherArgs = _count && transformCountFieldIntoSelectRelationsCount(_count, 'User', 'user', 'findFirstOrThrow');
    const result = await getPrismaFromContext(ctx).user.findFirstOrThrow({ ...transformedArgsIntoPrismaArgs, ...otherArgs, });
    for (const afterProcessEvent of afterProcessEvents) { await afterProcessEvent(result); }

    return result;
  }

  @Query(() => [User], {
    nullable: false
  })
  async findManyUser(@Context() ctx: any, @Info() info: GraphQLResolveInfo, @Args() args: FindManyUserArgs): Promise<User[]> {
    const afterProcessEvents: ((result: any) => Promise<any>)[] = [];
    const { _count } = transformInfoIntoPrismaArgs(info, 'User', 'user', 'findMany');
    const transformedArgsIntoPrismaArgs = await transformArgsIntoPrismaArgs(info, args, ctx, 'User', 'user', 'findMany', afterProcessEvents);
    const otherArgs = _count && transformCountFieldIntoSelectRelationsCount(_count, 'User', 'user', 'findMany');
    const result = await getPrismaFromContext(ctx).user.findMany({ ...transformedArgsIntoPrismaArgs, ...otherArgs, });
    for (const afterProcessEvent of afterProcessEvents) { await afterProcessEvent(result); }

    return result;
  }

  @Query(() => User, {
    nullable: true
  })
  async findUniqueUser(@Context() ctx: any, @Info() info: GraphQLResolveInfo, @Args() args: FindUniqueUserArgs): Promise<User | null> {
    const afterProcessEvents: ((result: any) => Promise<any>)[] = [];
    const { _count } = transformInfoIntoPrismaArgs(info, 'User', 'user', 'findUnique');
    const transformedArgsIntoPrismaArgs = await transformArgsIntoPrismaArgs(info, args, ctx, 'User', 'user', 'findUnique', afterProcessEvents);
    const otherArgs = _count && transformCountFieldIntoSelectRelationsCount(_count, 'User', 'user', 'findUnique');
    const result = await getPrismaFromContext(ctx).user.findUnique({ ...transformedArgsIntoPrismaArgs, ...otherArgs, });
    for (const afterProcessEvent of afterProcessEvents) { await afterProcessEvent(result); }

    return result;
  }

  @Query(() => User, {
    nullable: true
  })
  async findUniqueUserOrThrow(@Context() ctx: any, @Info() info: GraphQLResolveInfo, @Args() args: FindUniqueUserOrThrowArgs): Promise<User | null> {
    const afterProcessEvents: ((result: any) => Promise<any>)[] = [];
    const { _count } = transformInfoIntoPrismaArgs(info, 'User', 'user', 'findUniqueOrThrow');
    const transformedArgsIntoPrismaArgs = await transformArgsIntoPrismaArgs(info, args, ctx, 'User', 'user', 'findUniqueOrThrow', afterProcessEvents);
    const otherArgs = _count && transformCountFieldIntoSelectRelationsCount(_count, 'User', 'user', 'findUniqueOrThrow');
    const result = await getPrismaFromContext(ctx).user.findUniqueOrThrow({ ...transformedArgsIntoPrismaArgs, ...otherArgs, });
    for (const afterProcessEvent of afterProcessEvents) { await afterProcessEvent(result); }

    return result;
  }

  @Query(() => [UserGroupBy], {
    nullable: false
  })
  async groupByUser(@Context() ctx: any, @Info() info: GraphQLResolveInfo, @Args() args: GroupByUserArgs): Promise<UserGroupBy[]> {
    const afterProcessEvents: ((result: any) => Promise<any>)[] = [];
    const { _count, _avg, _sum, _min, _max } = transformInfoIntoPrismaArgs(info, 'User', 'user', 'groupBy');
    const transformedArgsIntoPrismaArgs = await transformArgsIntoPrismaArgs(info, args, ctx, 'User', 'user', 'groupBy', afterProcessEvents);
    const groupByArgs = Object.fromEntries(Object.entries({ _count, _avg, _sum, _min, _max }).filter(([_, v]) => v != null));
    const result = await getPrismaFromContext(ctx).user.groupBy({ ...transformedArgsIntoPrismaArgs, ...groupByArgs, });
    for (const afterProcessEvent of afterProcessEvents) { await afterProcessEvent(result); }

    return result;
  }

  @Mutation(() => AffectedRowsOutput, {
    nullable: false
  })
  async updateManyUser(@Context() ctx: any, @Info() info: GraphQLResolveInfo, @Args() args: UpdateManyUserArgs): Promise<AffectedRowsOutput> {
    const afterProcessEvents: ((result: any) => Promise<any>)[] = [];
    const { _count } = transformInfoIntoPrismaArgs(info, 'User', 'user', 'updateMany');
    const transformedArgsIntoPrismaArgs = await transformArgsIntoPrismaArgs(info, args, ctx, 'User', 'user', 'updateMany', afterProcessEvents);
    const otherArgs = _count && transformCountFieldIntoSelectRelationsCount(_count, 'User', 'user', 'updateMany');
    const result = await getPrismaFromContext(ctx).user.updateMany({ ...transformedArgsIntoPrismaArgs, ...otherArgs, });
    for (const afterProcessEvent of afterProcessEvents) { await afterProcessEvent(result); }

    return result;
  }

  @Mutation(() => User, {
    nullable: true
  })
  async updateOneUser(@Context() ctx: any, @Info() info: GraphQLResolveInfo, @Args() args: UpdateOneUserArgs): Promise<User | null> {
    const afterProcessEvents: ((result: any) => Promise<any>)[] = [];
    const { _count } = transformInfoIntoPrismaArgs(info, 'User', 'user', 'update');
    const transformedArgsIntoPrismaArgs = await transformArgsIntoPrismaArgs(info, args, ctx, 'User', 'user', 'update', afterProcessEvents);
    const otherArgs = _count && transformCountFieldIntoSelectRelationsCount(_count, 'User', 'user', 'update');
    const result = await getPrismaFromContext(ctx).user.update({ ...transformedArgsIntoPrismaArgs, ...otherArgs, });
    for (const afterProcessEvent of afterProcessEvents) { await afterProcessEvent(result); }

    return result;
  }

  @Mutation(() => User, {
    nullable: false
  })
  async upsertOneUser(@Context() ctx: any, @Info() info: GraphQLResolveInfo, @Args() args: UpsertOneUserArgs): Promise<User> {
    const afterProcessEvents: ((result: any) => Promise<any>)[] = [];
    const { _count } = transformInfoIntoPrismaArgs(info, 'User', 'user', 'upsert');
    const transformedArgsIntoPrismaArgs = await transformArgsIntoPrismaArgs(info, args, ctx, 'User', 'user', 'upsert', afterProcessEvents);
    const otherArgs = _count && transformCountFieldIntoSelectRelationsCount(_count, 'User', 'user', 'upsert');
    const result = await getPrismaFromContext(ctx).user.upsert({ ...transformedArgsIntoPrismaArgs, ...otherArgs, });
    for (const afterProcessEvent of afterProcessEvents) { await afterProcessEvent(result); }

    return result;
  }
}
"
`;

exports[`crud when emitRedundantTypesInfo is set to true should properly generate type info for @Args decorator: UserCrudResolver 1`] = `
"import { Args, ArgsType, Context, Field, Float, ID, Info, InputType, Int, Mutation, ObjectType, Parent, Query, ResolveField, Resolver, registerEnumType } from \\"@nestjs/graphql\\";
import type { GraphQLResolveInfo } from \\"graphql\\";
import { AggregateUserArgs } from \\"./args/AggregateUserArgs\\";
import { CreateManyAndReturnUserArgs } from \\"./args/CreateManyAndReturnUserArgs\\";
import { CreateManyUserArgs } from \\"./args/CreateManyUserArgs\\";
import { CreateOneUserArgs } from \\"./args/CreateOneUserArgs\\";
import { DeleteManyUserArgs } from \\"./args/DeleteManyUserArgs\\";
import { DeleteOneUserArgs } from \\"./args/DeleteOneUserArgs\\";
import { FindFirstUserArgs } from \\"./args/FindFirstUserArgs\\";
import { FindFirstUserOrThrowArgs } from \\"./args/FindFirstUserOrThrowArgs\\";
import { FindManyUserArgs } from \\"./args/FindManyUserArgs\\";
import { FindUniqueUserArgs } from \\"./args/FindUniqueUserArgs\\";
import { FindUniqueUserOrThrowArgs } from \\"./args/FindUniqueUserOrThrowArgs\\";
import { GroupByUserArgs } from \\"./args/GroupByUserArgs\\";
import { UpdateManyUserArgs } from \\"./args/UpdateManyUserArgs\\";
import { UpdateOneUserArgs } from \\"./args/UpdateOneUserArgs\\";
import { UpsertOneUserArgs } from \\"./args/UpsertOneUserArgs\\";
import { transformArgsIntoPrismaArgs, transformInfoIntoPrismaArgs, getPrismaFromContext, transformCountFieldIntoSelectRelationsCount, InlineLoader } from \\"../../../helpers\\";
import { User } from \\"../../../models/User\\";
import { AffectedRowsOutput } from \\"../../outputs/AffectedRowsOutput\\";
import { AggregateUser } from \\"../../outputs/AggregateUser\\";
import { CreateManyAndReturnUser } from \\"../../outputs/CreateManyAndReturnUser\\";
import { UserGroupBy } from \\"../../outputs/UserGroupBy\\";

@Resolver(() => User)
export class UserCrudResolver {
  @Query(() => AggregateUser, {
    nullable: false
  })
  async aggregateUser(@Context() ctx: any, @Info() info: GraphQLResolveInfo, @Args(() => AggregateUserArgs) args: AggregateUserArgs): Promise<AggregateUser> {
    const afterProcessEvents: ((result: any) => Promise<any>)[] = [];
    const transformedArgsIntoPrismaArgs = await transformArgsIntoPrismaArgs(info, args, ctx, 'User', 'user', 'aggregate', afterProcessEvents);
    const transformedInfoIntoPrismaArgs = transformInfoIntoPrismaArgs(info, 'User', 'user', 'aggregate');
    const result = await getPrismaFromContext(ctx).user.aggregate({ ...transformedArgsIntoPrismaArgs, ...transformedInfoIntoPrismaArgs, });
    for (const afterProcessEvent of afterProcessEvents) { await afterProcessEvent(result); }

    return result;
  }

  @Mutation(() => AffectedRowsOutput, {
    nullable: false
  })
  async createManyUser(@Context() ctx: any, @Info() info: GraphQLResolveInfo, @Args(() => CreateManyUserArgs) args: CreateManyUserArgs): Promise<AffectedRowsOutput> {
    const afterProcessEvents: ((result: any) => Promise<any>)[] = [];
    const { _count } = transformInfoIntoPrismaArgs(info, 'User', 'user', 'createMany');
    const transformedArgsIntoPrismaArgs = await transformArgsIntoPrismaArgs(info, args, ctx, 'User', 'user', 'createMany', afterProcessEvents);
    const otherArgs = _count && transformCountFieldIntoSelectRelationsCount(_count, 'User', 'user', 'createMany');
    const result = await getPrismaFromContext(ctx).user.createMany({ ...transformedArgsIntoPrismaArgs, ...otherArgs, });
    for (const afterProcessEvent of afterProcessEvents) { await afterProcessEvent(result); }

    return result;
  }

  @Mutation(() => [CreateManyAndReturnUser], {
    nullable: false
  })
  async createManyAndReturnUser(@Context() ctx: any, @Info() info: GraphQLResolveInfo, @Args(() => CreateManyAndReturnUserArgs) args: CreateManyAndReturnUserArgs): Promise<CreateManyAndReturnUser[]> {
    const afterProcessEvents: ((result: any) => Promise<any>)[] = [];
    const { _count } = transformInfoIntoPrismaArgs(info, 'User', 'user', 'createManyAndReturn');
    const transformedArgsIntoPrismaArgs = await transformArgsIntoPrismaArgs(info, args, ctx, 'User', 'user', 'createManyAndReturn', afterProcessEvents);
    const otherArgs = _count && transformCountFieldIntoSelectRelationsCount(_count, 'User', 'user', 'createManyAndReturn');
    const result = await getPrismaFromContext(ctx).user.createManyAndReturn({ ...transformedArgsIntoPrismaArgs, ...otherArgs, });
    for (const afterProcessEvent of afterProcessEvents) { await afterProcessEvent(result); }

    return result;
  }

  @Mutation(() => User, {
    nullable: false
  })
  async createOneUser(@Context() ctx: any, @Info() info: GraphQLResolveInfo, @Args(() => CreateOneUserArgs) args: CreateOneUserArgs): Promise<User> {
    const afterProcessEvents: ((result: any) => Promise<any>)[] = [];
    const { _count } = transformInfoIntoPrismaArgs(info, 'User', 'user', 'create');
    const transformedArgsIntoPrismaArgs = await transformArgsIntoPrismaArgs(info, args, ctx, 'User', 'user', 'create', afterProcessEvents);
    const otherArgs = _count && transformCountFieldIntoSelectRelationsCount(_count, 'User', 'user', 'create');
    const result = await getPrismaFromContext(ctx).user.create({ ...transformedArgsIntoPrismaArgs, ...otherArgs, });
    for (const afterProcessEvent of afterProcessEvents) { await afterProcessEvent(result); }

    return result;
  }

  @Mutation(() => AffectedRowsOutput, {
    nullable: false
  })
  async deleteManyUser(@Context() ctx: any, @Info() info: GraphQLResolveInfo, @Args(() => DeleteManyUserArgs) args: DeleteManyUserArgs): Promise<AffectedRowsOutput> {
    const afterProcessEvents: ((result: any) => Promise<any>)[] = [];
    const { _count } = transformInfoIntoPrismaArgs(info, 'User', 'user', 'deleteMany');
    const transformedArgsIntoPrismaArgs = await transformArgsIntoPrismaArgs(info, args, ctx, 'User', 'user', 'deleteMany', afterProcessEvents);
    const otherArgs = _count && transformCountFieldIntoSelectRelationsCount(_count, 'User', 'user', 'deleteMany');
    const result = await getPrismaFromContext(ctx).user.deleteMany({ ...transformedArgsIntoPrismaArgs, ...otherArgs, });
    for (const afterProcessEvent of afterProcessEvents) { await afterProcessEvent(result); }

    return result;
  }

  @Mutation(() => User, {
    nullable: true
  })
  async deleteOneUser(@Context() ctx: any, @Info() info: GraphQLResolveInfo, @Args(() => DeleteOneUserArgs) args: DeleteOneUserArgs): Promise<User | null> {
    const afterProcessEvents: ((result: any) => Promise<any>)[] = [];
    const { _count } = transformInfoIntoPrismaArgs(info, 'User', 'user', 'delete');
    const transformedArgsIntoPrismaArgs = await transformArgsIntoPrismaArgs(info, args, ctx, 'User', 'user', 'delete', afterProcessEvents);
    const otherArgs = _count && transformCountFieldIntoSelectRelationsCount(_count, 'User', 'user', 'delete');
    const result = await getPrismaFromContext(ctx).user.delete({ ...transformedArgsIntoPrismaArgs, ...otherArgs, });
    for (const afterProcessEvent of afterProcessEvents) { await afterProcessEvent(result); }

    return result;
  }

  @Query(() => User, {
    nullable: true
  })
  async findFirstUser(@Context() ctx: any, @Info() info: GraphQLResolveInfo, @Args(() => FindFirstUserArgs) args: FindFirstUserArgs): Promise<User | null> {
    const afterProcessEvents: ((result: any) => Promise<any>)[] = [];
    const { _count } = transformInfoIntoPrismaArgs(info, 'User', 'user', 'findFirst');
    const transformedArgsIntoPrismaArgs = await transformArgsIntoPrismaArgs(info, args, ctx, 'User', 'user', 'findFirst', afterProcessEvents);
    const otherArgs = _count && transformCountFieldIntoSelectRelationsCount(_count, 'User', 'user', 'findFirst');
    const result = await getPrismaFromContext(ctx).user.findFirst({ ...transformedArgsIntoPrismaArgs, ...otherArgs, });
    for (const afterProcessEvent of afterProcessEvents) { await afterProcessEvent(result); }

    return result;
  }

  @Query(() => User, {
    nullable: true
  })
  async findFirstUserOrThrow(@Context() ctx: any, @Info() info: GraphQLResolveInfo, @Args(() => FindFirstUserOrThrowArgs) args: FindFirstUserOrThrowArgs): Promise<User | null> {
    const afterProcessEvents: ((result: any) => Promise<any>)[] = [];
    const { _count } = transformInfoIntoPrismaArgs(info, 'User', 'user', 'findFirstOrThrow');
    const transformedArgsIntoPrismaArgs = await transformArgsIntoPrismaArgs(info, args, ctx, 'User', 'user', 'findFirstOrThrow', afterProcessEvents);
    const otherArgs = _count && transformCountFieldIntoSelectRelationsCount(_count, 'User', 'user', 'findFirstOrThrow');
    const result = await getPrismaFromContext(ctx).user.findFirstOrThrow({ ...transformedArgsIntoPrismaArgs, ...otherArgs, });
    for (const afterProcessEvent of afterProcessEvents) { await afterProcessEvent(result); }

    return result;
  }

  @Query(() => [User], {
    nullable: false
  })
  async users(@Context() ctx: any, @Info() info: GraphQLResolveInfo, @Args(() => FindManyUserArgs) args: FindManyUserArgs): Promise<User[]> {
    const afterProcessEvents: ((result: any) => Promise<any>)[] = [];
    const { _count } = transformInfoIntoPrismaArgs(info, 'User', 'user', 'findMany');
    const transformedArgsIntoPrismaArgs = await transformArgsIntoPrismaArgs(info, args, ctx, 'User', 'user', 'findMany', afterProcessEvents);
    const otherArgs = _count && transformCountFieldIntoSelectRelationsCount(_count, 'User', 'user', 'findMany');
    const result = await getPrismaFromContext(ctx).user.findMany({ ...transformedArgsIntoPrismaArgs, ...otherArgs, });
    for (const afterProcessEvent of afterProcessEvents) { await afterProcessEvent(result); }

    return result;
  }

  @Query(() => User, {
    nullable: true
  })
  async user(@Context() ctx: any, @Info() info: GraphQLResolveInfo, @Args(() => FindUniqueUserArgs) args: FindUniqueUserArgs): Promise<User | null> {
    const afterProcessEvents: ((result: any) => Promise<any>)[] = [];
    const { _count } = transformInfoIntoPrismaArgs(info, 'User', 'user', 'findUnique');
    const transformedArgsIntoPrismaArgs = await transformArgsIntoPrismaArgs(info, args, ctx, 'User', 'user', 'findUnique', afterProcessEvents);
    const otherArgs = _count && transformCountFieldIntoSelectRelationsCount(_count, 'User', 'user', 'findUnique');
    const result = await getPrismaFromContext(ctx).user.findUnique({ ...transformedArgsIntoPrismaArgs, ...otherArgs, });
    for (const afterProcessEvent of afterProcessEvents) { await afterProcessEvent(result); }

    return result;
  }

  @Query(() => User, {
    nullable: true
  })
  async getUser(@Context() ctx: any, @Info() info: GraphQLResolveInfo, @Args(() => FindUniqueUserOrThrowArgs) args: FindUniqueUserOrThrowArgs): Promise<User | null> {
    const afterProcessEvents: ((result: any) => Promise<any>)[] = [];
    const { _count } = transformInfoIntoPrismaArgs(info, 'User', 'user', 'findUniqueOrThrow');
    const transformedArgsIntoPrismaArgs = await transformArgsIntoPrismaArgs(info, args, ctx, 'User', 'user', 'findUniqueOrThrow', afterProcessEvents);
    const otherArgs = _count && transformCountFieldIntoSelectRelationsCount(_count, 'User', 'user', 'findUniqueOrThrow');
    const result = await getPrismaFromContext(ctx).user.findUniqueOrThrow({ ...transformedArgsIntoPrismaArgs, ...otherArgs, });
    for (const afterProcessEvent of afterProcessEvents) { await afterProcessEvent(result); }

    return result;
  }

  @Query(() => [UserGroupBy], {
    nullable: false
  })
  async groupByUser(@Context() ctx: any, @Info() info: GraphQLResolveInfo, @Args(() => GroupByUserArgs) args: GroupByUserArgs): Promise<UserGroupBy[]> {
    const afterProcessEvents: ((result: any) => Promise<any>)[] = [];
    const { _count, _avg, _sum, _min, _max } = transformInfoIntoPrismaArgs(info, 'User', 'user', 'groupBy');
    const transformedArgsIntoPrismaArgs = await transformArgsIntoPrismaArgs(info, args, ctx, 'User', 'user', 'groupBy', afterProcessEvents);
    const groupByArgs = Object.fromEntries(Object.entries({ _count, _avg, _sum, _min, _max }).filter(([_, v]) => v != null));
    const result = await getPrismaFromContext(ctx).user.groupBy({ ...transformedArgsIntoPrismaArgs, ...groupByArgs, });
    for (const afterProcessEvent of afterProcessEvents) { await afterProcessEvent(result); }

    return result;
  }

  @Mutation(() => AffectedRowsOutput, {
    nullable: false
  })
  async updateManyUser(@Context() ctx: any, @Info() info: GraphQLResolveInfo, @Args(() => UpdateManyUserArgs) args: UpdateManyUserArgs): Promise<AffectedRowsOutput> {
    const afterProcessEvents: ((result: any) => Promise<any>)[] = [];
    const { _count } = transformInfoIntoPrismaArgs(info, 'User', 'user', 'updateMany');
    const transformedArgsIntoPrismaArgs = await transformArgsIntoPrismaArgs(info, args, ctx, 'User', 'user', 'updateMany', afterProcessEvents);
    const otherArgs = _count && transformCountFieldIntoSelectRelationsCount(_count, 'User', 'user', 'updateMany');
    const result = await getPrismaFromContext(ctx).user.updateMany({ ...transformedArgsIntoPrismaArgs, ...otherArgs, });
    for (const afterProcessEvent of afterProcessEvents) { await afterProcessEvent(result); }

    return result;
  }

  @Mutation(() => User, {
    nullable: true
  })
  async updateOneUser(@Context() ctx: any, @Info() info: GraphQLResolveInfo, @Args(() => UpdateOneUserArgs) args: UpdateOneUserArgs): Promise<User | null> {
    const afterProcessEvents: ((result: any) => Promise<any>)[] = [];
    const { _count } = transformInfoIntoPrismaArgs(info, 'User', 'user', 'update');
    const transformedArgsIntoPrismaArgs = await transformArgsIntoPrismaArgs(info, args, ctx, 'User', 'user', 'update', afterProcessEvents);
    const otherArgs = _count && transformCountFieldIntoSelectRelationsCount(_count, 'User', 'user', 'update');
    const result = await getPrismaFromContext(ctx).user.update({ ...transformedArgsIntoPrismaArgs, ...otherArgs, });
    for (const afterProcessEvent of afterProcessEvents) { await afterProcessEvent(result); }

    return result;
  }

  @Mutation(() => User, {
    nullable: false
  })
  async upsertOneUser(@Context() ctx: any, @Info() info: GraphQLResolveInfo, @Args(() => UpsertOneUserArgs) args: UpsertOneUserArgs): Promise<User> {
    const afterProcessEvents: ((result: any) => Promise<any>)[] = [];
    const { _count } = transformInfoIntoPrismaArgs(info, 'User', 'user', 'upsert');
    const transformedArgsIntoPrismaArgs = await transformArgsIntoPrismaArgs(info, args, ctx, 'User', 'user', 'upsert', afterProcessEvents);
    const otherArgs = _count && transformCountFieldIntoSelectRelationsCount(_count, 'User', 'user', 'upsert');
    const result = await getPrismaFromContext(ctx).user.upsert({ ...transformedArgsIntoPrismaArgs, ...otherArgs, });
    for (const afterProcessEvent of afterProcessEvents) { await afterProcessEvent(result); }

    return result;
  }
}
"
`;

exports[`crud when emitTranspiledCode is set to true should properly generate imports in js files for resolver classes: UserCrudResolver 1`] = `
"\\"use strict\\";
Object.defineProperty(exports, \\"__esModule\\", { value: true });
exports.UserCrudResolver = void 0;
const tslib_1 = require(\\"tslib\\");
const graphql_1 = require(\\"@nestjs/graphql\\");
const AggregateUserArgs_1 = require(\\"./args/AggregateUserArgs\\");
const CreateManyAndReturnUserArgs_1 = require(\\"./args/CreateManyAndReturnUserArgs\\");
const CreateManyUserArgs_1 = require(\\"./args/CreateManyUserArgs\\");
const CreateOneUserArgs_1 = require(\\"./args/CreateOneUserArgs\\");
const DeleteManyUserArgs_1 = require(\\"./args/DeleteManyUserArgs\\");
const DeleteOneUserArgs_1 = require(\\"./args/DeleteOneUserArgs\\");
const FindFirstUserArgs_1 = require(\\"./args/FindFirstUserArgs\\");
const FindFirstUserOrThrowArgs_1 = require(\\"./args/FindFirstUserOrThrowArgs\\");
const FindManyUserArgs_1 = require(\\"./args/FindManyUserArgs\\");
const FindUniqueUserArgs_1 = require(\\"./args/FindUniqueUserArgs\\");
const FindUniqueUserOrThrowArgs_1 = require(\\"./args/FindUniqueUserOrThrowArgs\\");
const GroupByUserArgs_1 = require(\\"./args/GroupByUserArgs\\");
const UpdateManyUserArgs_1 = require(\\"./args/UpdateManyUserArgs\\");
const UpdateOneUserArgs_1 = require(\\"./args/UpdateOneUserArgs\\");
const UpsertOneUserArgs_1 = require(\\"./args/UpsertOneUserArgs\\");
const helpers_1 = require(\\"../../../helpers\\");
const User_1 = require(\\"../../../models/User\\");
const AffectedRowsOutput_1 = require(\\"../../outputs/AffectedRowsOutput\\");
const AggregateUser_1 = require(\\"../../outputs/AggregateUser\\");
const CreateManyAndReturnUser_1 = require(\\"../../outputs/CreateManyAndReturnUser\\");
const UserGroupBy_1 = require(\\"../../outputs/UserGroupBy\\");
let UserCrudResolver = class UserCrudResolver {
    async aggregateUser(ctx, info, args) {
        const afterProcessEvents = [];
        const transformedArgsIntoPrismaArgs = await (0, helpers_1.transformArgsIntoPrismaArgs)(info, args, ctx, 'User', 'user', 'aggregate', afterProcessEvents);
        const transformedInfoIntoPrismaArgs = (0, helpers_1.transformInfoIntoPrismaArgs)(info, 'User', 'user', 'aggregate');
        const result = await (0, helpers_1.getPrismaFromContext)(ctx).user.aggregate({ ...transformedArgsIntoPrismaArgs, ...transformedInfoIntoPrismaArgs, });
        for (const afterProcessEvent of afterProcessEvents) {
            await afterProcessEvent(result);
        }
        return result;
    }
    async createManyUser(ctx, info, args) {
        const afterProcessEvents = [];
        const { _count } = (0, helpers_1.transformInfoIntoPrismaArgs)(info, 'User', 'user', 'createMany');
        const transformedArgsIntoPrismaArgs = await (0, helpers_1.transformArgsIntoPrismaArgs)(info, args, ctx, 'User', 'user', 'createMany', afterProcessEvents);
        const otherArgs = _count && (0, helpers_1.transformCountFieldIntoSelectRelationsCount)(_count, 'User', 'user', 'createMany');
        const result = await (0, helpers_1.getPrismaFromContext)(ctx).user.createMany({ ...transformedArgsIntoPrismaArgs, ...otherArgs, });
        for (const afterProcessEvent of afterProcessEvents) {
            await afterProcessEvent(result);
        }
        return result;
    }
    async createManyAndReturnUser(ctx, info, args) {
        const afterProcessEvents = [];
        const { _count } = (0, helpers_1.transformInfoIntoPrismaArgs)(info, 'User', 'user', 'createManyAndReturn');
        const transformedArgsIntoPrismaArgs = await (0, helpers_1.transformArgsIntoPrismaArgs)(info, args, ctx, 'User', 'user', 'createManyAndReturn', afterProcessEvents);
        const otherArgs = _count && (0, helpers_1.transformCountFieldIntoSelectRelationsCount)(_count, 'User', 'user', 'createManyAndReturn');
        const result = await (0, helpers_1.getPrismaFromContext)(ctx).user.createManyAndReturn({ ...transformedArgsIntoPrismaArgs, ...otherArgs, });
        for (const afterProcessEvent of afterProcessEvents) {
            await afterProcessEvent(result);
        }
        return result;
    }
    async createOneUser(ctx, info, args) {
        const afterProcessEvents = [];
        const { _count } = (0, helpers_1.transformInfoIntoPrismaArgs)(info, 'User', 'user', 'create');
        const transformedArgsIntoPrismaArgs = await (0, helpers_1.transformArgsIntoPrismaArgs)(info, args, ctx, 'User', 'user', 'create', afterProcessEvents);
        const otherArgs = _count && (0, helpers_1.transformCountFieldIntoSelectRelationsCount)(_count, 'User', 'user', 'create');
        const result = await (0, helpers_1.getPrismaFromContext)(ctx).user.create({ ...transformedArgsIntoPrismaArgs, ...otherArgs, });
        for (const afterProcessEvent of afterProcessEvents) {
            await afterProcessEvent(result);
        }
        return result;
    }
    async deleteManyUser(ctx, info, args) {
        const afterProcessEvents = [];
        const { _count } = (0, helpers_1.transformInfoIntoPrismaArgs)(info, 'User', 'user', 'deleteMany');
        const transformedArgsIntoPrismaArgs = await (0, helpers_1.transformArgsIntoPrismaArgs)(info, args, ctx, 'User', 'user', 'deleteMany', afterProcessEvents);
        const otherArgs = _count && (0, helpers_1.transformCountFieldIntoSelectRelationsCount)(_count, 'User', 'user', 'deleteMany');
        const result = await (0, helpers_1.getPrismaFromContext)(ctx).user.deleteMany({ ...transformedArgsIntoPrismaArgs, ...otherArgs, });
        for (const afterProcessEvent of afterProcessEvents) {
            await afterProcessEvent(result);
        }
        return result;
    }
    async deleteOneUser(ctx, info, args) {
        const afterProcessEvents = [];
        const { _count } = (0, helpers_1.transformInfoIntoPrismaArgs)(info, 'User', 'user', 'delete');
        const transformedArgsIntoPrismaArgs = await (0, helpers_1.transformArgsIntoPrismaArgs)(info, args, ctx, 'User', 'user', 'delete', afterProcessEvents);
        const otherArgs = _count && (0, helpers_1.transformCountFieldIntoSelectRelationsCount)(_count, 'User', 'user', 'delete');
        const result = await (0, helpers_1.getPrismaFromContext)(ctx).user.delete({ ...transformedArgsIntoPrismaArgs, ...otherArgs, });
        for (const afterProcessEvent of afterProcessEvents) {
            await afterProcessEvent(result);
        }
        return result;
    }
    async findFirstUser(ctx, info, args) {
        const afterProcessEvents = [];
        const { _count } = (0, helpers_1.transformInfoIntoPrismaArgs)(info, 'User', 'user', 'findFirst');
        const transformedArgsIntoPrismaArgs = await (0, helpers_1.transformArgsIntoPrismaArgs)(info, args, ctx, 'User', 'user', 'findFirst', afterProcessEvents);
        const otherArgs = _count && (0, helpers_1.transformCountFieldIntoSelectRelationsCount)(_count, 'User', 'user', 'findFirst');
        const result = await (0, helpers_1.getPrismaFromContext)(ctx).user.findFirst({ ...transformedArgsIntoPrismaArgs, ...otherArgs, });
        for (const afterProcessEvent of afterProcessEvents) {
            await afterProcessEvent(result);
        }
        return result;
    }
    async findFirstUserOrThrow(ctx, info, args) {
        const afterProcessEvents = [];
        const { _count } = (0, helpers_1.transformInfoIntoPrismaArgs)(info, 'User', 'user', 'findFirstOrThrow');
        const transformedArgsIntoPrismaArgs = await (0, helpers_1.transformArgsIntoPrismaArgs)(info, args, ctx, 'User', 'user', 'findFirstOrThrow', afterProcessEvents);
        const otherArgs = _count && (0, helpers_1.transformCountFieldIntoSelectRelationsCount)(_count, 'User', 'user', 'findFirstOrThrow');
        const result = await (0, helpers_1.getPrismaFromContext)(ctx).user.findFirstOrThrow({ ...transformedArgsIntoPrismaArgs, ...otherArgs, });
        for (const afterProcessEvent of afterProcessEvents) {
            await afterProcessEvent(result);
        }
        return result;
    }
    async users(ctx, info, args) {
        const afterProcessEvents = [];
        const { _count } = (0, helpers_1.transformInfoIntoPrismaArgs)(info, 'User', 'user', 'findMany');
        const transformedArgsIntoPrismaArgs = await (0, helpers_1.transformArgsIntoPrismaArgs)(info, args, ctx, 'User', 'user', 'findMany', afterProcessEvents);
        const otherArgs = _count && (0, helpers_1.transformCountFieldIntoSelectRelationsCount)(_count, 'User', 'user', 'findMany');
        const result = await (0, helpers_1.getPrismaFromContext)(ctx).user.findMany({ ...transformedArgsIntoPrismaArgs, ...otherArgs, });
        for (const afterProcessEvent of afterProcessEvents) {
            await afterProcessEvent(result);
        }
        return result;
    }
    async user(ctx, info, args) {
        const afterProcessEvents = [];
        const { _count } = (0, helpers_1.transformInfoIntoPrismaArgs)(info, 'User', 'user', 'findUnique');
        const transformedArgsIntoPrismaArgs = await (0, helpers_1.transformArgsIntoPrismaArgs)(info, args, ctx, 'User', 'user', 'findUnique', afterProcessEvents);
        const otherArgs = _count && (0, helpers_1.transformCountFieldIntoSelectRelationsCount)(_count, 'User', 'user', 'findUnique');
        const result = await (0, helpers_1.getPrismaFromContext)(ctx).user.findUnique({ ...transformedArgsIntoPrismaArgs, ...otherArgs, });
        for (const afterProcessEvent of afterProcessEvents) {
            await afterProcessEvent(result);
        }
        return result;
    }
    async getUser(ctx, info, args) {
        const afterProcessEvents = [];
        const { _count } = (0, helpers_1.transformInfoIntoPrismaArgs)(info, 'User', 'user', 'findUniqueOrThrow');
        const transformedArgsIntoPrismaArgs = await (0, helpers_1.transformArgsIntoPrismaArgs)(info, args, ctx, 'User', 'user', 'findUniqueOrThrow', afterProcessEvents);
        const otherArgs = _count && (0, helpers_1.transformCountFieldIntoSelectRelationsCount)(_count, 'User', 'user', 'findUniqueOrThrow');
        const result = await (0, helpers_1.getPrismaFromContext)(ctx).user.findUniqueOrThrow({ ...transformedArgsIntoPrismaArgs, ...otherArgs, });
        for (const afterProcessEvent of afterProcessEvents) {
            await afterProcessEvent(result);
        }
        return result;
    }
    async groupByUser(ctx, info, args) {
        const afterProcessEvents = [];
        const { _count, _avg, _sum, _min, _max } = (0, helpers_1.transformInfoIntoPrismaArgs)(info, 'User', 'user', 'groupBy');
        const transformedArgsIntoPrismaArgs = await (0, helpers_1.transformArgsIntoPrismaArgs)(info, args, ctx, 'User', 'user', 'groupBy', afterProcessEvents);
        const groupByArgs = Object.fromEntries(Object.entries({ _count, _avg, _sum, _min, _max }).filter(([_, v]) => v != null));
        const result = await (0, helpers_1.getPrismaFromContext)(ctx).user.groupBy({ ...transformedArgsIntoPrismaArgs, ...groupByArgs, });
        for (const afterProcessEvent of afterProcessEvents) {
            await afterProcessEvent(result);
        }
        return result;
    }
    async updateManyUser(ctx, info, args) {
        const afterProcessEvents = [];
        const { _count } = (0, helpers_1.transformInfoIntoPrismaArgs)(info, 'User', 'user', 'updateMany');
        const transformedArgsIntoPrismaArgs = await (0, helpers_1.transformArgsIntoPrismaArgs)(info, args, ctx, 'User', 'user', 'updateMany', afterProcessEvents);
        const otherArgs = _count && (0, helpers_1.transformCountFieldIntoSelectRelationsCount)(_count, 'User', 'user', 'updateMany');
        const result = await (0, helpers_1.getPrismaFromContext)(ctx).user.updateMany({ ...transformedArgsIntoPrismaArgs, ...otherArgs, });
        for (const afterProcessEvent of afterProcessEvents) {
            await afterProcessEvent(result);
        }
        return result;
    }
    async updateOneUser(ctx, info, args) {
        const afterProcessEvents = [];
        const { _count } = (0, helpers_1.transformInfoIntoPrismaArgs)(info, 'User', 'user', 'update');
        const transformedArgsIntoPrismaArgs = await (0, helpers_1.transformArgsIntoPrismaArgs)(info, args, ctx, 'User', 'user', 'update', afterProcessEvents);
        const otherArgs = _count && (0, helpers_1.transformCountFieldIntoSelectRelationsCount)(_count, 'User', 'user', 'update');
        const result = await (0, helpers_1.getPrismaFromContext)(ctx).user.update({ ...transformedArgsIntoPrismaArgs, ...otherArgs, });
        for (const afterProcessEvent of afterProcessEvents) {
            await afterProcessEvent(result);
        }
        return result;
    }
    async upsertOneUser(ctx, info, args) {
        const afterProcessEvents = [];
        const { _count } = (0, helpers_1.transformInfoIntoPrismaArgs)(info, 'User', 'user', 'upsert');
        const transformedArgsIntoPrismaArgs = await (0, helpers_1.transformArgsIntoPrismaArgs)(info, args, ctx, 'User', 'user', 'upsert', afterProcessEvents);
        const otherArgs = _count && (0, helpers_1.transformCountFieldIntoSelectRelationsCount)(_count, 'User', 'user', 'upsert');
        const result = await (0, helpers_1.getPrismaFromContext)(ctx).user.upsert({ ...transformedArgsIntoPrismaArgs, ...otherArgs, });
        for (const afterProcessEvent of afterProcessEvents) {
            await afterProcessEvent(result);
        }
        return result;
    }
};
exports.UserCrudResolver = UserCrudResolver;
tslib_1.__decorate([
    (0, graphql_1.Query)(() => AggregateUser_1.AggregateUser, {
        nullable: false
    }),
    tslib_1.__param(0, (0, graphql_1.Context)()),
    tslib_1.__param(1, (0, graphql_1.Info)()),
    tslib_1.__param(2, (0, graphql_1.Args)()),
    tslib_1.__metadata(\\"design:type\\", Function),
    tslib_1.__metadata(\\"design:paramtypes\\", [Object, Object, AggregateUserArgs_1.AggregateUserArgs]),
    tslib_1.__metadata(\\"design:returntype\\", Promise)
], UserCrudResolver.prototype, \\"aggregateUser\\", null);
tslib_1.__decorate([
    (0, graphql_1.Mutation)(() => AffectedRowsOutput_1.AffectedRowsOutput, {
        nullable: false
    }),
    tslib_1.__param(0, (0, graphql_1.Context)()),
    tslib_1.__param(1, (0, graphql_1.Info)()),
    tslib_1.__param(2, (0, graphql_1.Args)()),
    tslib_1.__metadata(\\"design:type\\", Function),
    tslib_1.__metadata(\\"design:paramtypes\\", [Object, Object, CreateManyUserArgs_1.CreateManyUserArgs]),
    tslib_1.__metadata(\\"design:returntype\\", Promise)
], UserCrudResolver.prototype, \\"createManyUser\\", null);
tslib_1.__decorate([
    (0, graphql_1.Mutation)(() => [CreateManyAndReturnUser_1.CreateManyAndReturnUser], {
        nullable: false
    }),
    tslib_1.__param(0, (0, graphql_1.Context)()),
    tslib_1.__param(1, (0, graphql_1.Info)()),
    tslib_1.__param(2, (0, graphql_1.Args)()),
    tslib_1.__metadata(\\"design:type\\", Function),
    tslib_1.__metadata(\\"design:paramtypes\\", [Object, Object, CreateManyAndReturnUserArgs_1.CreateManyAndReturnUserArgs]),
    tslib_1.__metadata(\\"design:returntype\\", Promise)
], UserCrudResolver.prototype, \\"createManyAndReturnUser\\", null);
tslib_1.__decorate([
    (0, graphql_1.Mutation)(() => User_1.User, {
        nullable: false
    }),
    tslib_1.__param(0, (0, graphql_1.Context)()),
    tslib_1.__param(1, (0, graphql_1.Info)()),
    tslib_1.__param(2, (0, graphql_1.Args)()),
    tslib_1.__metadata(\\"design:type\\", Function),
    tslib_1.__metadata(\\"design:paramtypes\\", [Object, Object, CreateOneUserArgs_1.CreateOneUserArgs]),
    tslib_1.__metadata(\\"design:returntype\\", Promise)
], UserCrudResolver.prototype, \\"createOneUser\\", null);
tslib_1.__decorate([
    (0, graphql_1.Mutation)(() => AffectedRowsOutput_1.AffectedRowsOutput, {
        nullable: false
    }),
    tslib_1.__param(0, (0, graphql_1.Context)()),
    tslib_1.__param(1, (0, graphql_1.Info)()),
    tslib_1.__param(2, (0, graphql_1.Args)()),
    tslib_1.__metadata(\\"design:type\\", Function),
    tslib_1.__metadata(\\"design:paramtypes\\", [Object, Object, DeleteManyUserArgs_1.DeleteManyUserArgs]),
    tslib_1.__metadata(\\"design:returntype\\", Promise)
], UserCrudResolver.prototype, \\"deleteManyUser\\", null);
tslib_1.__decorate([
    (0, graphql_1.Mutation)(() => User_1.User, {
        nullable: true
    }),
    tslib_1.__param(0, (0, graphql_1.Context)()),
    tslib_1.__param(1, (0, graphql_1.Info)()),
    tslib_1.__param(2, (0, graphql_1.Args)()),
    tslib_1.__metadata(\\"design:type\\", Function),
    tslib_1.__metadata(\\"design:paramtypes\\", [Object, Object, DeleteOneUserArgs_1.DeleteOneUserArgs]),
    tslib_1.__metadata(\\"design:returntype\\", Promise)
], UserCrudResolver.prototype, \\"deleteOneUser\\", null);
tslib_1.__decorate([
    (0, graphql_1.Query)(() => User_1.User, {
        nullable: true
    }),
    tslib_1.__param(0, (0, graphql_1.Context)()),
    tslib_1.__param(1, (0, graphql_1.Info)()),
    tslib_1.__param(2, (0, graphql_1.Args)()),
    tslib_1.__metadata(\\"design:type\\", Function),
    tslib_1.__metadata(\\"design:paramtypes\\", [Object, Object, FindFirstUserArgs_1.FindFirstUserArgs]),
    tslib_1.__metadata(\\"design:returntype\\", Promise)
], UserCrudResolver.prototype, \\"findFirstUser\\", null);
tslib_1.__decorate([
    (0, graphql_1.Query)(() => User_1.User, {
        nullable: true
    }),
    tslib_1.__param(0, (0, graphql_1.Context)()),
    tslib_1.__param(1, (0, graphql_1.Info)()),
    tslib_1.__param(2, (0, graphql_1.Args)()),
    tslib_1.__metadata(\\"design:type\\", Function),
    tslib_1.__metadata(\\"design:paramtypes\\", [Object, Object, FindFirstUserOrThrowArgs_1.FindFirstUserOrThrowArgs]),
    tslib_1.__metadata(\\"design:returntype\\", Promise)
], UserCrudResolver.prototype, \\"findFirstUserOrThrow\\", null);
tslib_1.__decorate([
    (0, graphql_1.Query)(() => [User_1.User], {
        nullable: false
    }),
    tslib_1.__param(0, (0, graphql_1.Context)()),
    tslib_1.__param(1, (0, graphql_1.Info)()),
    tslib_1.__param(2, (0, graphql_1.Args)()),
    tslib_1.__metadata(\\"design:type\\", Function),
    tslib_1.__metadata(\\"design:paramtypes\\", [Object, Object, FindManyUserArgs_1.FindManyUserArgs]),
    tslib_1.__metadata(\\"design:returntype\\", Promise)
], UserCrudResolver.prototype, \\"users\\", null);
tslib_1.__decorate([
    (0, graphql_1.Query)(() => User_1.User, {
        nullable: true
    }),
    tslib_1.__param(0, (0, graphql_1.Context)()),
    tslib_1.__param(1, (0, graphql_1.Info)()),
    tslib_1.__param(2, (0, graphql_1.Args)()),
    tslib_1.__metadata(\\"design:type\\", Function),
    tslib_1.__metadata(\\"design:paramtypes\\", [Object, Object, FindUniqueUserArgs_1.FindUniqueUserArgs]),
    tslib_1.__metadata(\\"design:returntype\\", Promise)
], UserCrudResolver.prototype, \\"user\\", null);
tslib_1.__decorate([
    (0, graphql_1.Query)(() => User_1.User, {
        nullable: true
    }),
    tslib_1.__param(0, (0, graphql_1.Context)()),
    tslib_1.__param(1, (0, graphql_1.Info)()),
    tslib_1.__param(2, (0, graphql_1.Args)()),
    tslib_1.__metadata(\\"design:type\\", Function),
    tslib_1.__metadata(\\"design:paramtypes\\", [Object, Object, FindUniqueUserOrThrowArgs_1.FindUniqueUserOrThrowArgs]),
    tslib_1.__metadata(\\"design:returntype\\", Promise)
], UserCrudResolver.prototype, \\"getUser\\", null);
tslib_1.__decorate([
    (0, graphql_1.Query)(() => [UserGroupBy_1.UserGroupBy], {
        nullable: false
    }),
    tslib_1.__param(0, (0, graphql_1.Context)()),
    tslib_1.__param(1, (0, graphql_1.Info)()),
    tslib_1.__param(2, (0, graphql_1.Args)()),
    tslib_1.__metadata(\\"design:type\\", Function),
    tslib_1.__metadata(\\"design:paramtypes\\", [Object, Object, GroupByUserArgs_1.GroupByUserArgs]),
    tslib_1.__metadata(\\"design:returntype\\", Promise)
], UserCrudResolver.prototype, \\"groupByUser\\", null);
tslib_1.__decorate([
    (0, graphql_1.Mutation)(() => AffectedRowsOutput_1.AffectedRowsOutput, {
        nullable: false
    }),
    tslib_1.__param(0, (0, graphql_1.Context)()),
    tslib_1.__param(1, (0, graphql_1.Info)()),
    tslib_1.__param(2, (0, graphql_1.Args)()),
    tslib_1.__metadata(\\"design:type\\", Function),
    tslib_1.__metadata(\\"design:paramtypes\\", [Object, Object, UpdateManyUserArgs_1.UpdateManyUserArgs]),
    tslib_1.__metadata(\\"design:returntype\\", Promise)
], UserCrudResolver.prototype, \\"updateManyUser\\", null);
tslib_1.__decorate([
    (0, graphql_1.Mutation)(() => User_1.User, {
        nullable: true
    }),
    tslib_1.__param(0, (0, graphql_1.Context)()),
    tslib_1.__param(1, (0, graphql_1.Info)()),
    tslib_1.__param(2, (0, graphql_1.Args)()),
    tslib_1.__metadata(\\"design:type\\", Function),
    tslib_1.__metadata(\\"design:paramtypes\\", [Object, Object, UpdateOneUserArgs_1.UpdateOneUserArgs]),
    tslib_1.__metadata(\\"design:returntype\\", Promise)
], UserCrudResolver.prototype, \\"updateOneUser\\", null);
tslib_1.__decorate([
    (0, graphql_1.Mutation)(() => User_1.User, {
        nullable: false
    }),
    tslib_1.__param(0, (0, graphql_1.Context)()),
    tslib_1.__param(1, (0, graphql_1.Info)()),
    tslib_1.__param(2, (0, graphql_1.Args)()),
    tslib_1.__metadata(\\"design:type\\", Function),
    tslib_1.__metadata(\\"design:paramtypes\\", [Object, Object, UpsertOneUserArgs_1.UpsertOneUserArgs]),
    tslib_1.__metadata(\\"design:returntype\\", Promise)
], UserCrudResolver.prototype, \\"upsertOneUser\\", null);
exports.UserCrudResolver = UserCrudResolver = tslib_1.__decorate([
    (0, graphql_1.Resolver)(() => User_1.User)
], UserCrudResolver);
"
`;

exports[`crud when formatGeneratedCode is set to 'prettier' should properly format generated files for resolver classes: UserCrudResolver 1`] = `
"import {
  Args,
  ArgsType,
  Context,
  Field,
  Float,
  ID,
  Info,
  InputType,
  Int,
  Mutation,
  ObjectType,
  Parent,
  Query,
  ResolveField,
  Resolver,
  registerEnumType,
} from \\"@nestjs/graphql\\";
import type { GraphQLResolveInfo } from \\"graphql\\";
import { AggregateUserArgs } from \\"./args/AggregateUserArgs\\";
import { CreateManyAndReturnUserArgs } from \\"./args/CreateManyAndReturnUserArgs\\";
import { CreateManyUserArgs } from \\"./args/CreateManyUserArgs\\";
import { CreateOneUserArgs } from \\"./args/CreateOneUserArgs\\";
import { DeleteManyUserArgs } from \\"./args/DeleteManyUserArgs\\";
import { DeleteOneUserArgs } from \\"./args/DeleteOneUserArgs\\";
import { FindFirstUserArgs } from \\"./args/FindFirstUserArgs\\";
import { FindFirstUserOrThrowArgs } from \\"./args/FindFirstUserOrThrowArgs\\";
import { FindManyUserArgs } from \\"./args/FindManyUserArgs\\";
import { FindUniqueUserArgs } from \\"./args/FindUniqueUserArgs\\";
import { FindUniqueUserOrThrowArgs } from \\"./args/FindUniqueUserOrThrowArgs\\";
import { GroupByUserArgs } from \\"./args/GroupByUserArgs\\";
import { UpdateManyUserArgs } from \\"./args/UpdateManyUserArgs\\";
import { UpdateOneUserArgs } from \\"./args/UpdateOneUserArgs\\";
import { UpsertOneUserArgs } from \\"./args/UpsertOneUserArgs\\";
import {
  transformArgsIntoPrismaArgs,
  transformInfoIntoPrismaArgs,
  getPrismaFromContext,
  transformCountFieldIntoSelectRelationsCount,
  InlineLoader,
} from \\"../../../helpers\\";
import { User } from \\"../../../models/User\\";
import { AffectedRowsOutput } from \\"../../outputs/AffectedRowsOutput\\";
import { AggregateUser } from \\"../../outputs/AggregateUser\\";
import { CreateManyAndReturnUser } from \\"../../outputs/CreateManyAndReturnUser\\";
import { UserGroupBy } from \\"../../outputs/UserGroupBy\\";

@Resolver(() => User)
export class UserCrudResolver {
  @Query(() => AggregateUser, {
    nullable: false,
  })
  async aggregateUser(
    @Context() ctx: any,
    @Info() info: GraphQLResolveInfo,
    @Args() args: AggregateUserArgs,
  ): Promise<AggregateUser> {
    const afterProcessEvents: ((result: any) => Promise<any>)[] = [];
    const transformedArgsIntoPrismaArgs = await transformArgsIntoPrismaArgs(
      info,
      args,
      ctx,
      \\"User\\",
      \\"user\\",
      \\"aggregate\\",
      afterProcessEvents,
    );
    const transformedInfoIntoPrismaArgs = transformInfoIntoPrismaArgs(
      info,
      \\"User\\",
      \\"user\\",
      \\"aggregate\\",
    );
    const result = await getPrismaFromContext(ctx).user.aggregate({
      ...transformedArgsIntoPrismaArgs,
      ...transformedInfoIntoPrismaArgs,
    });
    for (const afterProcessEvent of afterProcessEvents) {
      await afterProcessEvent(result);
    }

    return result;
  }

  @Mutation(() => AffectedRowsOutput, {
    nullable: false,
  })
  async createManyUser(
    @Context() ctx: any,
    @Info() info: GraphQLResolveInfo,
    @Args() args: CreateManyUserArgs,
  ): Promise<AffectedRowsOutput> {
    const afterProcessEvents: ((result: any) => Promise<any>)[] = [];
    const { _count } = transformInfoIntoPrismaArgs(
      info,
      \\"User\\",
      \\"user\\",
      \\"createMany\\",
    );
    const transformedArgsIntoPrismaArgs = await transformArgsIntoPrismaArgs(
      info,
      args,
      ctx,
      \\"User\\",
      \\"user\\",
      \\"createMany\\",
      afterProcessEvents,
    );
    const otherArgs =
      _count &&
      transformCountFieldIntoSelectRelationsCount(
        _count,
        \\"User\\",
        \\"user\\",
        \\"createMany\\",
      );
    const result = await getPrismaFromContext(ctx).user.createMany({
      ...transformedArgsIntoPrismaArgs,
      ...otherArgs,
    });
    for (const afterProcessEvent of afterProcessEvents) {
      await afterProcessEvent(result);
    }

    return result;
  }

  @Mutation(() => [CreateManyAndReturnUser], {
    nullable: false,
  })
  async createManyAndReturnUser(
    @Context() ctx: any,
    @Info() info: GraphQLResolveInfo,
    @Args() args: CreateManyAndReturnUserArgs,
  ): Promise<CreateManyAndReturnUser[]> {
    const afterProcessEvents: ((result: any) => Promise<any>)[] = [];
    const { _count } = transformInfoIntoPrismaArgs(
      info,
      \\"User\\",
      \\"user\\",
      \\"createManyAndReturn\\",
    );
    const transformedArgsIntoPrismaArgs = await transformArgsIntoPrismaArgs(
      info,
      args,
      ctx,
      \\"User\\",
      \\"user\\",
      \\"createManyAndReturn\\",
      afterProcessEvents,
    );
    const otherArgs =
      _count &&
      transformCountFieldIntoSelectRelationsCount(
        _count,
        \\"User\\",
        \\"user\\",
        \\"createManyAndReturn\\",
      );
    const result = await getPrismaFromContext(ctx).user.createManyAndReturn({
      ...transformedArgsIntoPrismaArgs,
      ...otherArgs,
    });
    for (const afterProcessEvent of afterProcessEvents) {
      await afterProcessEvent(result);
    }

    return result;
  }

  @Mutation(() => User, {
    nullable: false,
  })
  async createOneUser(
    @Context() ctx: any,
    @Info() info: GraphQLResolveInfo,
    @Args() args: CreateOneUserArgs,
  ): Promise<User> {
    const afterProcessEvents: ((result: any) => Promise<any>)[] = [];
    const { _count } = transformInfoIntoPrismaArgs(
      info,
      \\"User\\",
      \\"user\\",
      \\"create\\",
    );
    const transformedArgsIntoPrismaArgs = await transformArgsIntoPrismaArgs(
      info,
      args,
      ctx,
      \\"User\\",
      \\"user\\",
      \\"create\\",
      afterProcessEvents,
    );
    const otherArgs =
      _count &&
      transformCountFieldIntoSelectRelationsCount(
        _count,
        \\"User\\",
        \\"user\\",
        \\"create\\",
      );
    const result = await getPrismaFromContext(ctx).user.create({
      ...transformedArgsIntoPrismaArgs,
      ...otherArgs,
    });
    for (const afterProcessEvent of afterProcessEvents) {
      await afterProcessEvent(result);
    }

    return result;
  }

  @Mutation(() => AffectedRowsOutput, {
    nullable: false,
  })
  async deleteManyUser(
    @Context() ctx: any,
    @Info() info: GraphQLResolveInfo,
    @Args() args: DeleteManyUserArgs,
  ): Promise<AffectedRowsOutput> {
    const afterProcessEvents: ((result: any) => Promise<any>)[] = [];
    const { _count } = transformInfoIntoPrismaArgs(
      info,
      \\"User\\",
      \\"user\\",
      \\"deleteMany\\",
    );
    const transformedArgsIntoPrismaArgs = await transformArgsIntoPrismaArgs(
      info,
      args,
      ctx,
      \\"User\\",
      \\"user\\",
      \\"deleteMany\\",
      afterProcessEvents,
    );
    const otherArgs =
      _count &&
      transformCountFieldIntoSelectRelationsCount(
        _count,
        \\"User\\",
        \\"user\\",
        \\"deleteMany\\",
      );
    const result = await getPrismaFromContext(ctx).user.deleteMany({
      ...transformedArgsIntoPrismaArgs,
      ...otherArgs,
    });
    for (const afterProcessEvent of afterProcessEvents) {
      await afterProcessEvent(result);
    }

    return result;
  }

  @Mutation(() => User, {
    nullable: true,
  })
  async deleteOneUser(
    @Context() ctx: any,
    @Info() info: GraphQLResolveInfo,
    @Args() args: DeleteOneUserArgs,
  ): Promise<User | null> {
    const afterProcessEvents: ((result: any) => Promise<any>)[] = [];
    const { _count } = transformInfoIntoPrismaArgs(
      info,
      \\"User\\",
      \\"user\\",
      \\"delete\\",
    );
    const transformedArgsIntoPrismaArgs = await transformArgsIntoPrismaArgs(
      info,
      args,
      ctx,
      \\"User\\",
      \\"user\\",
      \\"delete\\",
      afterProcessEvents,
    );
    const otherArgs =
      _count &&
      transformCountFieldIntoSelectRelationsCount(
        _count,
        \\"User\\",
        \\"user\\",
        \\"delete\\",
      );
    const result = await getPrismaFromContext(ctx).user.delete({
      ...transformedArgsIntoPrismaArgs,
      ...otherArgs,
    });
    for (const afterProcessEvent of afterProcessEvents) {
      await afterProcessEvent(result);
    }

    return result;
  }

  @Query(() => User, {
    nullable: true,
  })
  async findFirstUser(
    @Context() ctx: any,
    @Info() info: GraphQLResolveInfo,
    @Args() args: FindFirstUserArgs,
  ): Promise<User | null> {
    const afterProcessEvents: ((result: any) => Promise<any>)[] = [];
    const { _count } = transformInfoIntoPrismaArgs(
      info,
      \\"User\\",
      \\"user\\",
      \\"findFirst\\",
    );
    const transformedArgsIntoPrismaArgs = await transformArgsIntoPrismaArgs(
      info,
      args,
      ctx,
      \\"User\\",
      \\"user\\",
      \\"findFirst\\",
      afterProcessEvents,
    );
    const otherArgs =
      _count &&
      transformCountFieldIntoSelectRelationsCount(
        _count,
        \\"User\\",
        \\"user\\",
        \\"findFirst\\",
      );
    const result = await getPrismaFromContext(ctx).user.findFirst({
      ...transformedArgsIntoPrismaArgs,
      ...otherArgs,
    });
    for (const afterProcessEvent of afterProcessEvents) {
      await afterProcessEvent(result);
    }

    return result;
  }

  @Query(() => User, {
    nullable: true,
  })
  async findFirstUserOrThrow(
    @Context() ctx: any,
    @Info() info: GraphQLResolveInfo,
    @Args() args: FindFirstUserOrThrowArgs,
  ): Promise<User | null> {
    const afterProcessEvents: ((result: any) => Promise<any>)[] = [];
    const { _count } = transformInfoIntoPrismaArgs(
      info,
      \\"User\\",
      \\"user\\",
      \\"findFirstOrThrow\\",
    );
    const transformedArgsIntoPrismaArgs = await transformArgsIntoPrismaArgs(
      info,
      args,
      ctx,
      \\"User\\",
      \\"user\\",
      \\"findFirstOrThrow\\",
      afterProcessEvents,
    );
    const otherArgs =
      _count &&
      transformCountFieldIntoSelectRelationsCount(
        _count,
        \\"User\\",
        \\"user\\",
        \\"findFirstOrThrow\\",
      );
    const result = await getPrismaFromContext(ctx).user.findFirstOrThrow({
      ...transformedArgsIntoPrismaArgs,
      ...otherArgs,
    });
    for (const afterProcessEvent of afterProcessEvents) {
      await afterProcessEvent(result);
    }

    return result;
  }

  @Query(() => [User], {
    nullable: false,
  })
  async users(
    @Context() ctx: any,
    @Info() info: GraphQLResolveInfo,
    @Args() args: FindManyUserArgs,
  ): Promise<User[]> {
    const afterProcessEvents: ((result: any) => Promise<any>)[] = [];
    const { _count } = transformInfoIntoPrismaArgs(
      info,
      \\"User\\",
      \\"user\\",
      \\"findMany\\",
    );
    const transformedArgsIntoPrismaArgs = await transformArgsIntoPrismaArgs(
      info,
      args,
      ctx,
      \\"User\\",
      \\"user\\",
      \\"findMany\\",
      afterProcessEvents,
    );
    const otherArgs =
      _count &&
      transformCountFieldIntoSelectRelationsCount(
        _count,
        \\"User\\",
        \\"user\\",
        \\"findMany\\",
      );
    const result = await getPrismaFromContext(ctx).user.findMany({
      ...transformedArgsIntoPrismaArgs,
      ...otherArgs,
    });
    for (const afterProcessEvent of afterProcessEvents) {
      await afterProcessEvent(result);
    }

    return result;
  }

  @Query(() => User, {
    nullable: true,
  })
  async user(
    @Context() ctx: any,
    @Info() info: GraphQLResolveInfo,
    @Args() args: FindUniqueUserArgs,
  ): Promise<User | null> {
    const afterProcessEvents: ((result: any) => Promise<any>)[] = [];
    const { _count } = transformInfoIntoPrismaArgs(
      info,
      \\"User\\",
      \\"user\\",
      \\"findUnique\\",
    );
    const transformedArgsIntoPrismaArgs = await transformArgsIntoPrismaArgs(
      info,
      args,
      ctx,
      \\"User\\",
      \\"user\\",
      \\"findUnique\\",
      afterProcessEvents,
    );
    const otherArgs =
      _count &&
      transformCountFieldIntoSelectRelationsCount(
        _count,
        \\"User\\",
        \\"user\\",
        \\"findUnique\\",
      );
    const result = await getPrismaFromContext(ctx).user.findUnique({
      ...transformedArgsIntoPrismaArgs,
      ...otherArgs,
    });
    for (const afterProcessEvent of afterProcessEvents) {
      await afterProcessEvent(result);
    }

    return result;
  }

  @Query(() => User, {
    nullable: true,
  })
  async getUser(
    @Context() ctx: any,
    @Info() info: GraphQLResolveInfo,
    @Args() args: FindUniqueUserOrThrowArgs,
  ): Promise<User | null> {
    const afterProcessEvents: ((result: any) => Promise<any>)[] = [];
    const { _count } = transformInfoIntoPrismaArgs(
      info,
      \\"User\\",
      \\"user\\",
      \\"findUniqueOrThrow\\",
    );
    const transformedArgsIntoPrismaArgs = await transformArgsIntoPrismaArgs(
      info,
      args,
      ctx,
      \\"User\\",
      \\"user\\",
      \\"findUniqueOrThrow\\",
      afterProcessEvents,
    );
    const otherArgs =
      _count &&
      transformCountFieldIntoSelectRelationsCount(
        _count,
        \\"User\\",
        \\"user\\",
        \\"findUniqueOrThrow\\",
      );
    const result = await getPrismaFromContext(ctx).user.findUniqueOrThrow({
      ...transformedArgsIntoPrismaArgs,
      ...otherArgs,
    });
    for (const afterProcessEvent of afterProcessEvents) {
      await afterProcessEvent(result);
    }

    return result;
  }

  @Query(() => [UserGroupBy], {
    nullable: false,
  })
  async groupByUser(
    @Context() ctx: any,
    @Info() info: GraphQLResolveInfo,
    @Args() args: GroupByUserArgs,
  ): Promise<UserGroupBy[]> {
    const afterProcessEvents: ((result: any) => Promise<any>)[] = [];
    const { _count, _avg, _sum, _min, _max } = transformInfoIntoPrismaArgs(
      info,
      \\"User\\",
      \\"user\\",
      \\"groupBy\\",
    );
    const transformedArgsIntoPrismaArgs = await transformArgsIntoPrismaArgs(
      info,
      args,
      ctx,
      \\"User\\",
      \\"user\\",
      \\"groupBy\\",
      afterProcessEvents,
    );
    const groupByArgs = Object.fromEntries(
      Object.entries({ _count, _avg, _sum, _min, _max }).filter(
        ([_, v]) => v != null,
      ),
    );
    const result = await getPrismaFromContext(ctx).user.groupBy({
      ...transformedArgsIntoPrismaArgs,
      ...groupByArgs,
    });
    for (const afterProcessEvent of afterProcessEvents) {
      await afterProcessEvent(result);
    }

    return result;
  }

  @Mutation(() => AffectedRowsOutput, {
    nullable: false,
  })
  async updateManyUser(
    @Context() ctx: any,
    @Info() info: GraphQLResolveInfo,
    @Args() args: UpdateManyUserArgs,
  ): Promise<AffectedRowsOutput> {
    const afterProcessEvents: ((result: any) => Promise<any>)[] = [];
    const { _count } = transformInfoIntoPrismaArgs(
      info,
      \\"User\\",
      \\"user\\",
      \\"updateMany\\",
    );
    const transformedArgsIntoPrismaArgs = await transformArgsIntoPrismaArgs(
      info,
      args,
      ctx,
      \\"User\\",
      \\"user\\",
      \\"updateMany\\",
      afterProcessEvents,
    );
    const otherArgs =
      _count &&
      transformCountFieldIntoSelectRelationsCount(
        _count,
        \\"User\\",
        \\"user\\",
        \\"updateMany\\",
      );
    const result = await getPrismaFromContext(ctx).user.updateMany({
      ...transformedArgsIntoPrismaArgs,
      ...otherArgs,
    });
    for (const afterProcessEvent of afterProcessEvents) {
      await afterProcessEvent(result);
    }

    return result;
  }

  @Mutation(() => User, {
    nullable: true,
  })
  async updateOneUser(
    @Context() ctx: any,
    @Info() info: GraphQLResolveInfo,
    @Args() args: UpdateOneUserArgs,
  ): Promise<User | null> {
    const afterProcessEvents: ((result: any) => Promise<any>)[] = [];
    const { _count } = transformInfoIntoPrismaArgs(
      info,
      \\"User\\",
      \\"user\\",
      \\"update\\",
    );
    const transformedArgsIntoPrismaArgs = await transformArgsIntoPrismaArgs(
      info,
      args,
      ctx,
      \\"User\\",
      \\"user\\",
      \\"update\\",
      afterProcessEvents,
    );
    const otherArgs =
      _count &&
      transformCountFieldIntoSelectRelationsCount(
        _count,
        \\"User\\",
        \\"user\\",
        \\"update\\",
      );
    const result = await getPrismaFromContext(ctx).user.update({
      ...transformedArgsIntoPrismaArgs,
      ...otherArgs,
    });
    for (const afterProcessEvent of afterProcessEvents) {
      await afterProcessEvent(result);
    }

    return result;
  }

  @Mutation(() => User, {
    nullable: false,
  })
  async upsertOneUser(
    @Context() ctx: any,
    @Info() info: GraphQLResolveInfo,
    @Args() args: UpsertOneUserArgs,
  ): Promise<User> {
    const afterProcessEvents: ((result: any) => Promise<any>)[] = [];
    const { _count } = transformInfoIntoPrismaArgs(
      info,
      \\"User\\",
      \\"user\\",
      \\"upsert\\",
    );
    const transformedArgsIntoPrismaArgs = await transformArgsIntoPrismaArgs(
      info,
      args,
      ctx,
      \\"User\\",
      \\"user\\",
      \\"upsert\\",
      afterProcessEvents,
    );
    const otherArgs =
      _count &&
      transformCountFieldIntoSelectRelationsCount(
        _count,
        \\"User\\",
        \\"user\\",
        \\"upsert\\",
      );
    const result = await getPrismaFromContext(ctx).user.upsert({
      ...transformedArgsIntoPrismaArgs,
      ...otherArgs,
    });
    for (const afterProcessEvent of afterProcessEvents) {
      await afterProcessEvent(result);
    }

    return result;
  }
}
"
`;

exports[`crud when formatGeneratedCode is set to false should not format generated files for resolver classes: UserCrudResolver 1`] = `
"import { Args, ArgsType, Context, Field, Float, ID, Info, InputType, Int, Mutation, ObjectType, Parent, Query, ResolveField, Resolver, registerEnumType } from \\"@nestjs/graphql\\";
import type { GraphQLResolveInfo } from \\"graphql\\";
import { AggregateUserArgs } from \\"./args/AggregateUserArgs\\";
import { CreateManyAndReturnUserArgs } from \\"./args/CreateManyAndReturnUserArgs\\";
import { CreateManyUserArgs } from \\"./args/CreateManyUserArgs\\";
import { CreateOneUserArgs } from \\"./args/CreateOneUserArgs\\";
import { DeleteManyUserArgs } from \\"./args/DeleteManyUserArgs\\";
import { DeleteOneUserArgs } from \\"./args/DeleteOneUserArgs\\";
import { FindFirstUserArgs } from \\"./args/FindFirstUserArgs\\";
import { FindFirstUserOrThrowArgs } from \\"./args/FindFirstUserOrThrowArgs\\";
import { FindManyUserArgs } from \\"./args/FindManyUserArgs\\";
import { FindUniqueUserArgs } from \\"./args/FindUniqueUserArgs\\";
import { FindUniqueUserOrThrowArgs } from \\"./args/FindUniqueUserOrThrowArgs\\";
import { GroupByUserArgs } from \\"./args/GroupByUserArgs\\";
import { UpdateManyUserArgs } from \\"./args/UpdateManyUserArgs\\";
import { UpdateOneUserArgs } from \\"./args/UpdateOneUserArgs\\";
import { UpsertOneUserArgs } from \\"./args/UpsertOneUserArgs\\";
import { transformArgsIntoPrismaArgs, transformInfoIntoPrismaArgs, getPrismaFromContext, transformCountFieldIntoSelectRelationsCount, InlineLoader } from \\"../../../helpers\\";
import { User } from \\"../../../models/User\\";
import { AffectedRowsOutput } from \\"../../outputs/AffectedRowsOutput\\";
import { AggregateUser } from \\"../../outputs/AggregateUser\\";
import { CreateManyAndReturnUser } from \\"../../outputs/CreateManyAndReturnUser\\";
import { UserGroupBy } from \\"../../outputs/UserGroupBy\\";

@Resolver(() => User)
export class UserCrudResolver {
    @Query(() => AggregateUser, {
            nullable: false
        })
    async aggregateUser(@Context() ctx: any, @Info() info: GraphQLResolveInfo, @Args() args: AggregateUserArgs): Promise<AggregateUser> {
        const afterProcessEvents: ((result:any) => Promise<any>)[] = [];
        const transformedArgsIntoPrismaArgs = await transformArgsIntoPrismaArgs(info, args, ctx, 'User', 'user', 'aggregate', afterProcessEvents);
        const transformedInfoIntoPrismaArgs = transformInfoIntoPrismaArgs(info, 'User', 'user', 'aggregate');
        const result = await getPrismaFromContext(ctx).user.aggregate({ ...transformedArgsIntoPrismaArgs, ...transformedInfoIntoPrismaArgs, });
        for (const afterProcessEvent of afterProcessEvents){ await afterProcessEvent(result); }

        return result;
    }

    @Mutation(() => AffectedRowsOutput, {
            nullable: false
        })
    async createManyUser(@Context() ctx: any, @Info() info: GraphQLResolveInfo, @Args() args: CreateManyUserArgs): Promise<AffectedRowsOutput> {
         const afterProcessEvents: ((result:any) => Promise<any>)[] = [];
         const { _count } = transformInfoIntoPrismaArgs(info, 'User', 'user', 'createMany');
         const transformedArgsIntoPrismaArgs = await transformArgsIntoPrismaArgs(info, args, ctx, 'User', 'user', 'createMany', afterProcessEvents);
         const otherArgs = _count && transformCountFieldIntoSelectRelationsCount(_count, 'User', 'user', 'createMany');
         const result = await getPrismaFromContext(ctx).user.createMany({ ...transformedArgsIntoPrismaArgs, ...otherArgs, });
         for (const afterProcessEvent of afterProcessEvents){ await afterProcessEvent(result); }

        return result;
    }

    @Mutation(() => [CreateManyAndReturnUser], {
            nullable: false
        })
    async createManyAndReturnUser(@Context() ctx: any, @Info() info: GraphQLResolveInfo, @Args() args: CreateManyAndReturnUserArgs): Promise<CreateManyAndReturnUser[]> {
         const afterProcessEvents: ((result:any) => Promise<any>)[] = [];
         const { _count } = transformInfoIntoPrismaArgs(info, 'User', 'user', 'createManyAndReturn');
         const transformedArgsIntoPrismaArgs = await transformArgsIntoPrismaArgs(info, args, ctx, 'User', 'user', 'createManyAndReturn', afterProcessEvents);
         const otherArgs = _count && transformCountFieldIntoSelectRelationsCount(_count, 'User', 'user', 'createManyAndReturn');
         const result = await getPrismaFromContext(ctx).user.createManyAndReturn({ ...transformedArgsIntoPrismaArgs, ...otherArgs, });
         for (const afterProcessEvent of afterProcessEvents){ await afterProcessEvent(result); }

        return result;
    }

    @Mutation(() => User, {
            nullable: false
        })
    async createOneUser(@Context() ctx: any, @Info() info: GraphQLResolveInfo, @Args() args: CreateOneUserArgs): Promise<User> {
         const afterProcessEvents: ((result:any) => Promise<any>)[] = [];
         const { _count } = transformInfoIntoPrismaArgs(info, 'User', 'user', 'create');
         const transformedArgsIntoPrismaArgs = await transformArgsIntoPrismaArgs(info, args, ctx, 'User', 'user', 'create', afterProcessEvents);
         const otherArgs = _count && transformCountFieldIntoSelectRelationsCount(_count, 'User', 'user', 'create');
         const result = await getPrismaFromContext(ctx).user.create({ ...transformedArgsIntoPrismaArgs, ...otherArgs, });
         for (const afterProcessEvent of afterProcessEvents){ await afterProcessEvent(result); }

        return result;
    }

    @Mutation(() => AffectedRowsOutput, {
            nullable: false
        })
    async deleteManyUser(@Context() ctx: any, @Info() info: GraphQLResolveInfo, @Args() args: DeleteManyUserArgs): Promise<AffectedRowsOutput> {
         const afterProcessEvents: ((result:any) => Promise<any>)[] = [];
         const { _count } = transformInfoIntoPrismaArgs(info, 'User', 'user', 'deleteMany');
         const transformedArgsIntoPrismaArgs = await transformArgsIntoPrismaArgs(info, args, ctx, 'User', 'user', 'deleteMany', afterProcessEvents);
         const otherArgs = _count && transformCountFieldIntoSelectRelationsCount(_count, 'User', 'user', 'deleteMany');
         const result = await getPrismaFromContext(ctx).user.deleteMany({ ...transformedArgsIntoPrismaArgs, ...otherArgs, });
         for (const afterProcessEvent of afterProcessEvents){ await afterProcessEvent(result); }

        return result;
    }

    @Mutation(() => User, {
            nullable: true
        })
    async deleteOneUser(@Context() ctx: any, @Info() info: GraphQLResolveInfo, @Args() args: DeleteOneUserArgs): Promise<User | null> {
         const afterProcessEvents: ((result:any) => Promise<any>)[] = [];
         const { _count } = transformInfoIntoPrismaArgs(info, 'User', 'user', 'delete');
         const transformedArgsIntoPrismaArgs = await transformArgsIntoPrismaArgs(info, args, ctx, 'User', 'user', 'delete', afterProcessEvents);
         const otherArgs = _count && transformCountFieldIntoSelectRelationsCount(_count, 'User', 'user', 'delete');
         const result = await getPrismaFromContext(ctx).user.delete({ ...transformedArgsIntoPrismaArgs, ...otherArgs, });
         for (const afterProcessEvent of afterProcessEvents){ await afterProcessEvent(result); }

        return result;
    }

    @Query(() => User, {
            nullable: true
        })
    async findFirstUser(@Context() ctx: any, @Info() info: GraphQLResolveInfo, @Args() args: FindFirstUserArgs): Promise<User | null> {
         const afterProcessEvents: ((result:any) => Promise<any>)[] = [];
         const { _count } = transformInfoIntoPrismaArgs(info, 'User', 'user', 'findFirst');
         const transformedArgsIntoPrismaArgs = await transformArgsIntoPrismaArgs(info, args, ctx, 'User', 'user', 'findFirst', afterProcessEvents);
         const otherArgs = _count && transformCountFieldIntoSelectRelationsCount(_count, 'User', 'user', 'findFirst');
         const result = await getPrismaFromContext(ctx).user.findFirst({ ...transformedArgsIntoPrismaArgs, ...otherArgs, });
         for (const afterProcessEvent of afterProcessEvents){ await afterProcessEvent(result); }

        return result;
    }

    @Query(() => User, {
            nullable: true
        })
    async findFirstUserOrThrow(@Context() ctx: any, @Info() info: GraphQLResolveInfo, @Args() args: FindFirstUserOrThrowArgs): Promise<User | null> {
         const afterProcessEvents: ((result:any) => Promise<any>)[] = [];
         const { _count } = transformInfoIntoPrismaArgs(info, 'User', 'user', 'findFirstOrThrow');
         const transformedArgsIntoPrismaArgs = await transformArgsIntoPrismaArgs(info, args, ctx, 'User', 'user', 'findFirstOrThrow', afterProcessEvents);
         const otherArgs = _count && transformCountFieldIntoSelectRelationsCount(_count, 'User', 'user', 'findFirstOrThrow');
         const result = await getPrismaFromContext(ctx).user.findFirstOrThrow({ ...transformedArgsIntoPrismaArgs, ...otherArgs, });
         for (const afterProcessEvent of afterProcessEvents){ await afterProcessEvent(result); }

        return result;
    }

    @Query(() => [User], {
            nullable: false
        })
    async users(@Context() ctx: any, @Info() info: GraphQLResolveInfo, @Args() args: FindManyUserArgs): Promise<User[]> {
         const afterProcessEvents: ((result:any) => Promise<any>)[] = [];
         const { _count } = transformInfoIntoPrismaArgs(info, 'User', 'user', 'findMany');
         const transformedArgsIntoPrismaArgs = await transformArgsIntoPrismaArgs(info, args, ctx, 'User', 'user', 'findMany', afterProcessEvents);
         const otherArgs = _count && transformCountFieldIntoSelectRelationsCount(_count, 'User', 'user', 'findMany');
         const result = await getPrismaFromContext(ctx).user.findMany({ ...transformedArgsIntoPrismaArgs, ...otherArgs, });
         for (const afterProcessEvent of afterProcessEvents){ await afterProcessEvent(result); }

        return result;
    }

    @Query(() => User, {
            nullable: true
        })
    async user(@Context() ctx: any, @Info() info: GraphQLResolveInfo, @Args() args: FindUniqueUserArgs): Promise<User | null> {
         const afterProcessEvents: ((result:any) => Promise<any>)[] = [];
         const { _count } = transformInfoIntoPrismaArgs(info, 'User', 'user', 'findUnique');
         const transformedArgsIntoPrismaArgs = await transformArgsIntoPrismaArgs(info, args, ctx, 'User', 'user', 'findUnique', afterProcessEvents);
         const otherArgs = _count && transformCountFieldIntoSelectRelationsCount(_count, 'User', 'user', 'findUnique');
         const result = await getPrismaFromContext(ctx).user.findUnique({ ...transformedArgsIntoPrismaArgs, ...otherArgs, });
         for (const afterProcessEvent of afterProcessEvents){ await afterProcessEvent(result); }

        return result;
    }

    @Query(() => User, {
            nullable: true
        })
    async getUser(@Context() ctx: any, @Info() info: GraphQLResolveInfo, @Args() args: FindUniqueUserOrThrowArgs): Promise<User | null> {
         const afterProcessEvents: ((result:any) => Promise<any>)[] = [];
         const { _count } = transformInfoIntoPrismaArgs(info, 'User', 'user', 'findUniqueOrThrow');
         const transformedArgsIntoPrismaArgs = await transformArgsIntoPrismaArgs(info, args, ctx, 'User', 'user', 'findUniqueOrThrow', afterProcessEvents);
         const otherArgs = _count && transformCountFieldIntoSelectRelationsCount(_count, 'User', 'user', 'findUniqueOrThrow');
         const result = await getPrismaFromContext(ctx).user.findUniqueOrThrow({ ...transformedArgsIntoPrismaArgs, ...otherArgs, });
         for (const afterProcessEvent of afterProcessEvents){ await afterProcessEvent(result); }

        return result;
    }

    @Query(() => [UserGroupBy], {
            nullable: false
        })
    async groupByUser(@Context() ctx: any, @Info() info: GraphQLResolveInfo, @Args() args: GroupByUserArgs): Promise<UserGroupBy[]> {
        const afterProcessEvents: ((result:any) => Promise<any>)[] = [];
        const { _count, _avg, _sum, _min, _max } = transformInfoIntoPrismaArgs(info, 'User', 'user', 'groupBy');
        const transformedArgsIntoPrismaArgs = await transformArgsIntoPrismaArgs(info, args, ctx, 'User', 'user', 'groupBy', afterProcessEvents);
        const groupByArgs = Object.fromEntries( Object.entries({ _count, _avg, _sum, _min, _max }).filter(([_, v]) => v != null));
        const result = await getPrismaFromContext(ctx).user.groupBy({ ...transformedArgsIntoPrismaArgs, ...groupByArgs,});
        for (const afterProcessEvent of afterProcessEvents){ await afterProcessEvent(result); }

        return result;
    }

    @Mutation(() => AffectedRowsOutput, {
            nullable: false
        })
    async updateManyUser(@Context() ctx: any, @Info() info: GraphQLResolveInfo, @Args() args: UpdateManyUserArgs): Promise<AffectedRowsOutput> {
         const afterProcessEvents: ((result:any) => Promise<any>)[] = [];
         const { _count } = transformInfoIntoPrismaArgs(info, 'User', 'user', 'updateMany');
         const transformedArgsIntoPrismaArgs = await transformArgsIntoPrismaArgs(info, args, ctx, 'User', 'user', 'updateMany', afterProcessEvents);
         const otherArgs = _count && transformCountFieldIntoSelectRelationsCount(_count, 'User', 'user', 'updateMany');
         const result = await getPrismaFromContext(ctx).user.updateMany({ ...transformedArgsIntoPrismaArgs, ...otherArgs, });
         for (const afterProcessEvent of afterProcessEvents){ await afterProcessEvent(result); }

        return result;
    }

    @Mutation(() => User, {
            nullable: true
        })
    async updateOneUser(@Context() ctx: any, @Info() info: GraphQLResolveInfo, @Args() args: UpdateOneUserArgs): Promise<User | null> {
         const afterProcessEvents: ((result:any) => Promise<any>)[] = [];
         const { _count } = transformInfoIntoPrismaArgs(info, 'User', 'user', 'update');
         const transformedArgsIntoPrismaArgs = await transformArgsIntoPrismaArgs(info, args, ctx, 'User', 'user', 'update', afterProcessEvents);
         const otherArgs = _count && transformCountFieldIntoSelectRelationsCount(_count, 'User', 'user', 'update');
         const result = await getPrismaFromContext(ctx).user.update({ ...transformedArgsIntoPrismaArgs, ...otherArgs, });
         for (const afterProcessEvent of afterProcessEvents){ await afterProcessEvent(result); }

        return result;
    }

    @Mutation(() => User, {
            nullable: false
        })
    async upsertOneUser(@Context() ctx: any, @Info() info: GraphQLResolveInfo, @Args() args: UpsertOneUserArgs): Promise<User> {
         const afterProcessEvents: ((result:any) => Promise<any>)[] = [];
         const { _count } = transformInfoIntoPrismaArgs(info, 'User', 'user', 'upsert');
         const transformedArgsIntoPrismaArgs = await transformArgsIntoPrismaArgs(info, args, ctx, 'User', 'user', 'upsert', afterProcessEvents);
         const otherArgs = _count && transformCountFieldIntoSelectRelationsCount(_count, 'User', 'user', 'upsert');
         const result = await getPrismaFromContext(ctx).user.upsert({ ...transformedArgsIntoPrismaArgs, ...otherArgs, });
         for (const afterProcessEvent of afterProcessEvents){ await afterProcessEvent(result); }

        return result;
    }
}
"
`;

exports[`crud when model is renamed should properly generate actions resolver classes for prisma model: AggregateClientResolver 1`] = `
"import { Args, ArgsType, Context, Field, Float, ID, Info, InputType, Int, Mutation, ObjectType, Parent, Query, ResolveField, Resolver, registerEnumType } from \\"@nestjs/graphql\\";
import type { GraphQLResolveInfo } from \\"graphql\\";
import { AggregateClientArgs } from \\"./args/AggregateClientArgs\\";
import { Client } from \\"../../../models/Client\\";
import { AggregateClient } from \\"../../outputs/AggregateClient\\";
import { transformArgsIntoPrismaArgs, transformInfoIntoPrismaArgs, getPrismaFromContext, transformCountFieldIntoSelectRelationsCount, InlineLoader } from \\"../../../helpers\\";

@Resolver(() => Client)
export class AggregateClientResolver {
  @Query(() => AggregateClient, {
    nullable: false
  })
  async aggregateClient(@Context() ctx: any, @Info() info: GraphQLResolveInfo, @Args() args: AggregateClientArgs): Promise<AggregateClient> {
    const afterProcessEvents: ((result: any) => Promise<any>)[] = [];
    const transformedArgsIntoPrismaArgs = await transformArgsIntoPrismaArgs(info, args, ctx, 'User', 'user', 'aggregate', afterProcessEvents);
    const transformedInfoIntoPrismaArgs = transformInfoIntoPrismaArgs(info, 'User', 'user', 'aggregate');
    const result = await getPrismaFromContext(ctx).user.aggregate({ ...transformedArgsIntoPrismaArgs, ...transformedInfoIntoPrismaArgs, });
    for (const afterProcessEvent of afterProcessEvents) { await afterProcessEvent(result); }

    return result;
  }
}
"
`;

exports[`crud when model is renamed should properly generate actions resolver classes for prisma model: CreateManyAndReturnClientResolver 1`] = `
"import { Args, ArgsType, Context, Field, Float, ID, Info, InputType, Int, Mutation, ObjectType, Parent, Query, ResolveField, Resolver, registerEnumType } from \\"@nestjs/graphql\\";
import type { GraphQLResolveInfo } from \\"graphql\\";
import { CreateManyAndReturnClientArgs } from \\"./args/CreateManyAndReturnClientArgs\\";
import { Client } from \\"../../../models/Client\\";
import { CreateManyAndReturnClient } from \\"../../outputs/CreateManyAndReturnClient\\";
import { transformArgsIntoPrismaArgs, transformInfoIntoPrismaArgs, getPrismaFromContext, transformCountFieldIntoSelectRelationsCount, InlineLoader } from \\"../../../helpers\\";

@Resolver(() => Client)
export class CreateManyAndReturnClientResolver {
  @Mutation(() => [CreateManyAndReturnClient], {
    nullable: false
  })
  async createManyAndReturnClient(@Context() ctx: any, @Info() info: GraphQLResolveInfo, @Args() args: CreateManyAndReturnClientArgs): Promise<CreateManyAndReturnClient[]> {
    const afterProcessEvents: ((result: any) => Promise<any>)[] = [];
    const { _count } = transformInfoIntoPrismaArgs(info, 'User', 'user', 'createManyAndReturn');
    const transformedArgsIntoPrismaArgs = await transformArgsIntoPrismaArgs(info, args, ctx, 'User', 'user', 'createManyAndReturn', afterProcessEvents);
    const otherArgs = _count && transformCountFieldIntoSelectRelationsCount(_count, 'User', 'user', 'createManyAndReturn');
    const result = await getPrismaFromContext(ctx).user.createManyAndReturn({ ...transformedArgsIntoPrismaArgs, ...otherArgs, });
    for (const afterProcessEvent of afterProcessEvents) { await afterProcessEvent(result); }

    return result;
  }
}
"
`;

exports[`crud when model is renamed should properly generate actions resolver classes for prisma model: CreateManyClientResolver 1`] = `
"import { Args, ArgsType, Context, Field, Float, ID, Info, InputType, Int, Mutation, ObjectType, Parent, Query, ResolveField, Resolver, registerEnumType } from \\"@nestjs/graphql\\";
import type { GraphQLResolveInfo } from \\"graphql\\";
import { CreateManyClientArgs } from \\"./args/CreateManyClientArgs\\";
import { Client } from \\"../../../models/Client\\";
import { AffectedRowsOutput } from \\"../../outputs/AffectedRowsOutput\\";
import { transformArgsIntoPrismaArgs, transformInfoIntoPrismaArgs, getPrismaFromContext, transformCountFieldIntoSelectRelationsCount, InlineLoader } from \\"../../../helpers\\";

@Resolver(() => Client)
export class CreateManyClientResolver {
  @Mutation(() => AffectedRowsOutput, {
    nullable: false
  })
  async createManyClient(@Context() ctx: any, @Info() info: GraphQLResolveInfo, @Args() args: CreateManyClientArgs): Promise<AffectedRowsOutput> {
    const afterProcessEvents: ((result: any) => Promise<any>)[] = [];
    const { _count } = transformInfoIntoPrismaArgs(info, 'User', 'user', 'createMany');
    const transformedArgsIntoPrismaArgs = await transformArgsIntoPrismaArgs(info, args, ctx, 'User', 'user', 'createMany', afterProcessEvents);
    const otherArgs = _count && transformCountFieldIntoSelectRelationsCount(_count, 'User', 'user', 'createMany');
    const result = await getPrismaFromContext(ctx).user.createMany({ ...transformedArgsIntoPrismaArgs, ...otherArgs, });
    for (const afterProcessEvent of afterProcessEvents) { await afterProcessEvent(result); }

    return result;
  }
}
"
`;

exports[`crud when model is renamed should properly generate actions resolver classes for prisma model: CreateOneClientResolver 1`] = `
"import { Args, ArgsType, Context, Field, Float, ID, Info, InputType, Int, Mutation, ObjectType, Parent, Query, ResolveField, Resolver, registerEnumType } from \\"@nestjs/graphql\\";
import type { GraphQLResolveInfo } from \\"graphql\\";
import { CreateOneClientArgs } from \\"./args/CreateOneClientArgs\\";
import { Client } from \\"../../../models/Client\\";
import { transformArgsIntoPrismaArgs, transformInfoIntoPrismaArgs, getPrismaFromContext, transformCountFieldIntoSelectRelationsCount, InlineLoader } from \\"../../../helpers\\";

@Resolver(() => Client)
export class CreateOneClientResolver {
  @Mutation(() => Client, {
    nullable: false
  })
  async createOneClient(@Context() ctx: any, @Info() info: GraphQLResolveInfo, @Args() args: CreateOneClientArgs): Promise<Client> {
    const afterProcessEvents: ((result: any) => Promise<any>)[] = [];
    const { _count } = transformInfoIntoPrismaArgs(info, 'User', 'user', 'create');
    const transformedArgsIntoPrismaArgs = await transformArgsIntoPrismaArgs(info, args, ctx, 'User', 'user', 'create', afterProcessEvents);
    const otherArgs = _count && transformCountFieldIntoSelectRelationsCount(_count, 'User', 'user', 'create');
    const result = await getPrismaFromContext(ctx).user.create({ ...transformedArgsIntoPrismaArgs, ...otherArgs, });
    for (const afterProcessEvent of afterProcessEvents) { await afterProcessEvent(result); }

    return result;
  }
}
"
`;

exports[`crud when model is renamed should properly generate actions resolver classes for prisma model: DeleteManyClientResolver 1`] = `
"import { Args, ArgsType, Context, Field, Float, ID, Info, InputType, Int, Mutation, ObjectType, Parent, Query, ResolveField, Resolver, registerEnumType } from \\"@nestjs/graphql\\";
import type { GraphQLResolveInfo } from \\"graphql\\";
import { DeleteManyClientArgs } from \\"./args/DeleteManyClientArgs\\";
import { Client } from \\"../../../models/Client\\";
import { AffectedRowsOutput } from \\"../../outputs/AffectedRowsOutput\\";
import { transformArgsIntoPrismaArgs, transformInfoIntoPrismaArgs, getPrismaFromContext, transformCountFieldIntoSelectRelationsCount, InlineLoader } from \\"../../../helpers\\";

@Resolver(() => Client)
export class DeleteManyClientResolver {
  @Mutation(() => AffectedRowsOutput, {
    nullable: false
  })
  async deleteManyClient(@Context() ctx: any, @Info() info: GraphQLResolveInfo, @Args() args: DeleteManyClientArgs): Promise<AffectedRowsOutput> {
    const afterProcessEvents: ((result: any) => Promise<any>)[] = [];
    const { _count } = transformInfoIntoPrismaArgs(info, 'User', 'user', 'deleteMany');
    const transformedArgsIntoPrismaArgs = await transformArgsIntoPrismaArgs(info, args, ctx, 'User', 'user', 'deleteMany', afterProcessEvents);
    const otherArgs = _count && transformCountFieldIntoSelectRelationsCount(_count, 'User', 'user', 'deleteMany');
    const result = await getPrismaFromContext(ctx).user.deleteMany({ ...transformedArgsIntoPrismaArgs, ...otherArgs, });
    for (const afterProcessEvent of afterProcessEvents) { await afterProcessEvent(result); }

    return result;
  }
}
"
`;

exports[`crud when model is renamed should properly generate actions resolver classes for prisma model: DeleteOneClientResolver 1`] = `
"import { Args, ArgsType, Context, Field, Float, ID, Info, InputType, Int, Mutation, ObjectType, Parent, Query, ResolveField, Resolver, registerEnumType } from \\"@nestjs/graphql\\";
import type { GraphQLResolveInfo } from \\"graphql\\";
import { DeleteOneClientArgs } from \\"./args/DeleteOneClientArgs\\";
import { Client } from \\"../../../models/Client\\";
import { transformArgsIntoPrismaArgs, transformInfoIntoPrismaArgs, getPrismaFromContext, transformCountFieldIntoSelectRelationsCount, InlineLoader } from \\"../../../helpers\\";

@Resolver(() => Client)
export class DeleteOneClientResolver {
  @Mutation(() => Client, {
    nullable: true
  })
  async deleteOneClient(@Context() ctx: any, @Info() info: GraphQLResolveInfo, @Args() args: DeleteOneClientArgs): Promise<Client | null> {
    const afterProcessEvents: ((result: any) => Promise<any>)[] = [];
    const { _count } = transformInfoIntoPrismaArgs(info, 'User', 'user', 'delete');
    const transformedArgsIntoPrismaArgs = await transformArgsIntoPrismaArgs(info, args, ctx, 'User', 'user', 'delete', afterProcessEvents);
    const otherArgs = _count && transformCountFieldIntoSelectRelationsCount(_count, 'User', 'user', 'delete');
    const result = await getPrismaFromContext(ctx).user.delete({ ...transformedArgsIntoPrismaArgs, ...otherArgs, });
    for (const afterProcessEvent of afterProcessEvents) { await afterProcessEvent(result); }

    return result;
  }
}
"
`;

exports[`crud when model is renamed should properly generate actions resolver classes for prisma model: FindFirstClientResolver 1`] = `
"import { Args, ArgsType, Context, Field, Float, ID, Info, InputType, Int, Mutation, ObjectType, Parent, Query, ResolveField, Resolver, registerEnumType } from \\"@nestjs/graphql\\";
import type { GraphQLResolveInfo } from \\"graphql\\";
import { FindFirstClientArgs } from \\"./args/FindFirstClientArgs\\";
import { Client } from \\"../../../models/Client\\";
import { transformArgsIntoPrismaArgs, transformInfoIntoPrismaArgs, getPrismaFromContext, transformCountFieldIntoSelectRelationsCount, InlineLoader } from \\"../../../helpers\\";

@Resolver(() => Client)
export class FindFirstClientResolver {
  @Query(() => Client, {
    nullable: true
  })
  async findFirstClient(@Context() ctx: any, @Info() info: GraphQLResolveInfo, @Args() args: FindFirstClientArgs): Promise<Client | null> {
    const afterProcessEvents: ((result: any) => Promise<any>)[] = [];
    const { _count } = transformInfoIntoPrismaArgs(info, 'User', 'user', 'findFirst');
    const transformedArgsIntoPrismaArgs = await transformArgsIntoPrismaArgs(info, args, ctx, 'User', 'user', 'findFirst', afterProcessEvents);
    const otherArgs = _count && transformCountFieldIntoSelectRelationsCount(_count, 'User', 'user', 'findFirst');
    const result = await getPrismaFromContext(ctx).user.findFirst({ ...transformedArgsIntoPrismaArgs, ...otherArgs, });
    for (const afterProcessEvent of afterProcessEvents) { await afterProcessEvent(result); }

    return result;
  }
}
"
`;

exports[`crud when model is renamed should properly generate actions resolver classes for prisma model: FindManyClientResolver 1`] = `
"import { Args, ArgsType, Context, Field, Float, ID, Info, InputType, Int, Mutation, ObjectType, Parent, Query, ResolveField, Resolver, registerEnumType } from \\"@nestjs/graphql\\";
import type { GraphQLResolveInfo } from \\"graphql\\";
import { FindManyClientArgs } from \\"./args/FindManyClientArgs\\";
import { Client } from \\"../../../models/Client\\";
import { transformArgsIntoPrismaArgs, transformInfoIntoPrismaArgs, getPrismaFromContext, transformCountFieldIntoSelectRelationsCount, InlineLoader } from \\"../../../helpers\\";

@Resolver(() => Client)
export class FindManyClientResolver {
  @Query(() => [Client], {
    nullable: false
  })
  async clients(@Context() ctx: any, @Info() info: GraphQLResolveInfo, @Args() args: FindManyClientArgs): Promise<Client[]> {
    const afterProcessEvents: ((result: any) => Promise<any>)[] = [];
    const { _count } = transformInfoIntoPrismaArgs(info, 'User', 'user', 'findMany');
    const transformedArgsIntoPrismaArgs = await transformArgsIntoPrismaArgs(info, args, ctx, 'User', 'user', 'findMany', afterProcessEvents);
    const otherArgs = _count && transformCountFieldIntoSelectRelationsCount(_count, 'User', 'user', 'findMany');
    const result = await getPrismaFromContext(ctx).user.findMany({ ...transformedArgsIntoPrismaArgs, ...otherArgs, });
    for (const afterProcessEvent of afterProcessEvents) { await afterProcessEvent(result); }

    return result;
  }
}
"
`;

exports[`crud when model is renamed should properly generate actions resolver classes for prisma model: FindUniqueClientResolver 1`] = `
"import { Args, ArgsType, Context, Field, Float, ID, Info, InputType, Int, Mutation, ObjectType, Parent, Query, ResolveField, Resolver, registerEnumType } from \\"@nestjs/graphql\\";
import type { GraphQLResolveInfo } from \\"graphql\\";
import { FindUniqueClientArgs } from \\"./args/FindUniqueClientArgs\\";
import { Client } from \\"../../../models/Client\\";
import { transformArgsIntoPrismaArgs, transformInfoIntoPrismaArgs, getPrismaFromContext, transformCountFieldIntoSelectRelationsCount, InlineLoader } from \\"../../../helpers\\";

@Resolver(() => Client)
export class FindUniqueClientResolver {
  @Query(() => Client, {
    nullable: true
  })
  async client(@Context() ctx: any, @Info() info: GraphQLResolveInfo, @Args() args: FindUniqueClientArgs): Promise<Client | null> {
    const afterProcessEvents: ((result: any) => Promise<any>)[] = [];
    const { _count } = transformInfoIntoPrismaArgs(info, 'User', 'user', 'findUnique');
    const transformedArgsIntoPrismaArgs = await transformArgsIntoPrismaArgs(info, args, ctx, 'User', 'user', 'findUnique', afterProcessEvents);
    const otherArgs = _count && transformCountFieldIntoSelectRelationsCount(_count, 'User', 'user', 'findUnique');
    const result = await getPrismaFromContext(ctx).user.findUnique({ ...transformedArgsIntoPrismaArgs, ...otherArgs, });
    for (const afterProcessEvent of afterProcessEvents) { await afterProcessEvent(result); }

    return result;
  }
}
"
`;

exports[`crud when model is renamed should properly generate actions resolver classes for prisma model: GroupByClientResolver 1`] = `
"import { Args, ArgsType, Context, Field, Float, ID, Info, InputType, Int, Mutation, ObjectType, Parent, Query, ResolveField, Resolver, registerEnumType } from \\"@nestjs/graphql\\";
import type { GraphQLResolveInfo } from \\"graphql\\";
import { GroupByClientArgs } from \\"./args/GroupByClientArgs\\";
import { Client } from \\"../../../models/Client\\";
import { ClientGroupBy } from \\"../../outputs/ClientGroupBy\\";
import { transformArgsIntoPrismaArgs, transformInfoIntoPrismaArgs, getPrismaFromContext, transformCountFieldIntoSelectRelationsCount, InlineLoader } from \\"../../../helpers\\";

@Resolver(() => Client)
export class GroupByClientResolver {
  @Query(() => [ClientGroupBy], {
    nullable: false
  })
  async groupByClient(@Context() ctx: any, @Info() info: GraphQLResolveInfo, @Args() args: GroupByClientArgs): Promise<ClientGroupBy[]> {
    const afterProcessEvents: ((result: any) => Promise<any>)[] = [];
    const { _count, _avg, _sum, _min, _max } = transformInfoIntoPrismaArgs(info, 'User', 'user', 'groupBy');
    const transformedArgsIntoPrismaArgs = await transformArgsIntoPrismaArgs(info, args, ctx, 'User', 'user', 'groupBy', afterProcessEvents);
    const groupByArgs = Object.fromEntries(Object.entries({ _count, _avg, _sum, _min, _max }).filter(([_, v]) => v != null));
    const result = await getPrismaFromContext(ctx).user.groupBy({ ...transformedArgsIntoPrismaArgs, ...groupByArgs, });
    for (const afterProcessEvent of afterProcessEvents) { await afterProcessEvent(result); }

    return result;
  }
}
"
`;

exports[`crud when model is renamed should properly generate actions resolver classes for prisma model: UpdateManyClientResolver 1`] = `
"import { Args, ArgsType, Context, Field, Float, ID, Info, InputType, Int, Mutation, ObjectType, Parent, Query, ResolveField, Resolver, registerEnumType } from \\"@nestjs/graphql\\";
import type { GraphQLResolveInfo } from \\"graphql\\";
import { UpdateManyClientArgs } from \\"./args/UpdateManyClientArgs\\";
import { Client } from \\"../../../models/Client\\";
import { AffectedRowsOutput } from \\"../../outputs/AffectedRowsOutput\\";
import { transformArgsIntoPrismaArgs, transformInfoIntoPrismaArgs, getPrismaFromContext, transformCountFieldIntoSelectRelationsCount, InlineLoader } from \\"../../../helpers\\";

@Resolver(() => Client)
export class UpdateManyClientResolver {
  @Mutation(() => AffectedRowsOutput, {
    nullable: false
  })
  async updateManyClient(@Context() ctx: any, @Info() info: GraphQLResolveInfo, @Args() args: UpdateManyClientArgs): Promise<AffectedRowsOutput> {
    const afterProcessEvents: ((result: any) => Promise<any>)[] = [];
    const { _count } = transformInfoIntoPrismaArgs(info, 'User', 'user', 'updateMany');
    const transformedArgsIntoPrismaArgs = await transformArgsIntoPrismaArgs(info, args, ctx, 'User', 'user', 'updateMany', afterProcessEvents);
    const otherArgs = _count && transformCountFieldIntoSelectRelationsCount(_count, 'User', 'user', 'updateMany');
    const result = await getPrismaFromContext(ctx).user.updateMany({ ...transformedArgsIntoPrismaArgs, ...otherArgs, });
    for (const afterProcessEvent of afterProcessEvents) { await afterProcessEvent(result); }

    return result;
  }
}
"
`;

exports[`crud when model is renamed should properly generate actions resolver classes for prisma model: UpdateOneClientResolver 1`] = `
"import { Args, ArgsType, Context, Field, Float, ID, Info, InputType, Int, Mutation, ObjectType, Parent, Query, ResolveField, Resolver, registerEnumType } from \\"@nestjs/graphql\\";
import type { GraphQLResolveInfo } from \\"graphql\\";
import { UpdateOneClientArgs } from \\"./args/UpdateOneClientArgs\\";
import { Client } from \\"../../../models/Client\\";
import { transformArgsIntoPrismaArgs, transformInfoIntoPrismaArgs, getPrismaFromContext, transformCountFieldIntoSelectRelationsCount, InlineLoader } from \\"../../../helpers\\";

@Resolver(() => Client)
export class UpdateOneClientResolver {
  @Mutation(() => Client, {
    nullable: true
  })
  async updateOneClient(@Context() ctx: any, @Info() info: GraphQLResolveInfo, @Args() args: UpdateOneClientArgs): Promise<Client | null> {
    const afterProcessEvents: ((result: any) => Promise<any>)[] = [];
    const { _count } = transformInfoIntoPrismaArgs(info, 'User', 'user', 'update');
    const transformedArgsIntoPrismaArgs = await transformArgsIntoPrismaArgs(info, args, ctx, 'User', 'user', 'update', afterProcessEvents);
    const otherArgs = _count && transformCountFieldIntoSelectRelationsCount(_count, 'User', 'user', 'update');
    const result = await getPrismaFromContext(ctx).user.update({ ...transformedArgsIntoPrismaArgs, ...otherArgs, });
    for (const afterProcessEvent of afterProcessEvents) { await afterProcessEvent(result); }

    return result;
  }
}
"
`;

exports[`crud when model is renamed should properly generate actions resolver classes for prisma model: UpsertOneClientResolver 1`] = `
"import { Args, ArgsType, Context, Field, Float, ID, Info, InputType, Int, Mutation, ObjectType, Parent, Query, ResolveField, Resolver, registerEnumType } from \\"@nestjs/graphql\\";
import type { GraphQLResolveInfo } from \\"graphql\\";
import { UpsertOneClientArgs } from \\"./args/UpsertOneClientArgs\\";
import { Client } from \\"../../../models/Client\\";
import { transformArgsIntoPrismaArgs, transformInfoIntoPrismaArgs, getPrismaFromContext, transformCountFieldIntoSelectRelationsCount, InlineLoader } from \\"../../../helpers\\";

@Resolver(() => Client)
export class UpsertOneClientResolver {
  @Mutation(() => Client, {
    nullable: false
  })
  async upsertOneClient(@Context() ctx: any, @Info() info: GraphQLResolveInfo, @Args() args: UpsertOneClientArgs): Promise<Client> {
    const afterProcessEvents: ((result: any) => Promise<any>)[] = [];
    const { _count } = transformInfoIntoPrismaArgs(info, 'User', 'user', 'upsert');
    const transformedArgsIntoPrismaArgs = await transformArgsIntoPrismaArgs(info, args, ctx, 'User', 'user', 'upsert', afterProcessEvents);
    const otherArgs = _count && transformCountFieldIntoSelectRelationsCount(_count, 'User', 'user', 'upsert');
    const result = await getPrismaFromContext(ctx).user.upsert({ ...transformedArgsIntoPrismaArgs, ...otherArgs, });
    for (const afterProcessEvent of afterProcessEvents) { await afterProcessEvent(result); }

    return result;
  }
}
"
`;

exports[`crud when model is renamed should properly generate args classes for every method of crud resolver: AggregateClientArgs 1`] = `
"import { Args, ArgsType, Context, Field, Float, ID, Info, InputType, Int, Mutation, ObjectType, Parent, Query, ResolveField, Resolver, registerEnumType } from \\"@nestjs/graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { ClientOrderByWithRelationInput, ClientWhereInput, ClientWhereUniqueInput } from \\"../../../inputs\\";

@ArgsType()
export class AggregateClientArgs {
  @Field(() => ClientWhereInput, {
    nullable: true
  })
  where?: ClientWhereInput | undefined;

  @Field(() => [ClientOrderByWithRelationInput], {
    nullable: true
  })
  orderBy?: ClientOrderByWithRelationInput[] | undefined;

  @Field(() => ClientWhereUniqueInput, {
    nullable: true
  })
  cursor?: ClientWhereUniqueInput | undefined;

  @Field(() => Int, {
    nullable: true
  })
  take?: number | undefined;

  @Field(() => Int, {
    nullable: true
  })
  skip?: number | undefined;
}
"
`;

exports[`crud when model is renamed should properly generate args classes for every method of crud resolver: CreateClientArgs 1`] = `
"import { Args, ArgsType, Context, Field, Float, ID, Info, InputType, Int, Mutation, ObjectType, Parent, Query, ResolveField, Resolver, registerEnumType } from \\"@nestjs/graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { ClientCreateInput } from \\"../../../inputs\\";

@ArgsType()
export class CreateOneClientArgs {
  @Field(() => ClientCreateInput, {
    nullable: false
  })
  data!: ClientCreateInput;
}
"
`;

exports[`crud when model is renamed should properly generate args classes for every method of crud resolver: CreateManyAndReturnClientArgs 1`] = `
"import { Args, ArgsType, Context, Field, Float, ID, Info, InputType, Int, Mutation, ObjectType, Parent, Query, ResolveField, Resolver, registerEnumType } from \\"@nestjs/graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { ClientCreateManyInput } from \\"../../../inputs\\";

@ArgsType()
export class CreateManyAndReturnClientArgs {
  @Field(() => [ClientCreateManyInput], {
    nullable: false
  })
  data!: ClientCreateManyInput[];

  @Field(() => Boolean, {
    nullable: true
  })
  skipDuplicates?: boolean | undefined;
}
"
`;

exports[`crud when model is renamed should properly generate args classes for every method of crud resolver: CreateManyClientArgs 1`] = `
"import { Args, ArgsType, Context, Field, Float, ID, Info, InputType, Int, Mutation, ObjectType, Parent, Query, ResolveField, Resolver, registerEnumType } from \\"@nestjs/graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { ClientCreateManyInput } from \\"../../../inputs\\";

@ArgsType()
export class CreateManyClientArgs {
  @Field(() => [ClientCreateManyInput], {
    nullable: false
  })
  data!: ClientCreateManyInput[];

  @Field(() => Boolean, {
    nullable: true
  })
  skipDuplicates?: boolean | undefined;
}
"
`;

exports[`crud when model is renamed should properly generate args classes for every method of crud resolver: DeleteClientArgs 1`] = `
"import { Args, ArgsType, Context, Field, Float, ID, Info, InputType, Int, Mutation, ObjectType, Parent, Query, ResolveField, Resolver, registerEnumType } from \\"@nestjs/graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { ClientWhereUniqueInput } from \\"../../../inputs\\";

@ArgsType()
export class DeleteOneClientArgs {
  @Field(() => ClientWhereUniqueInput, {
    nullable: false
  })
  where!: ClientWhereUniqueInput;
}
"
`;

exports[`crud when model is renamed should properly generate args classes for every method of crud resolver: DeleteManyClientArgs 1`] = `
"import { Args, ArgsType, Context, Field, Float, ID, Info, InputType, Int, Mutation, ObjectType, Parent, Query, ResolveField, Resolver, registerEnumType } from \\"@nestjs/graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { ClientWhereInput } from \\"../../../inputs\\";

@ArgsType()
export class DeleteManyClientArgs {
  @Field(() => ClientWhereInput, {
    nullable: true
  })
  where?: ClientWhereInput | undefined;

  @Field(() => Int, {
    nullable: true
  })
  limit?: number | undefined;
}
"
`;

exports[`crud when model is renamed should properly generate args classes for every method of crud resolver: FindFirstClientArgs 1`] = `
"import { Args, ArgsType, Context, Field, Float, ID, Info, InputType, Int, Mutation, ObjectType, Parent, Query, ResolveField, Resolver, registerEnumType } from \\"@nestjs/graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { ClientOrderByWithRelationInput, ClientWhereInput, ClientWhereUniqueInput } from \\"../../../inputs\\";
import { ClientScalarFieldEnum } from \\"../../../../enums/ClientScalarFieldEnum\\";

@ArgsType()
export class FindFirstClientArgs {
  @Field(() => ClientWhereInput, {
    nullable: true
  })
  where?: ClientWhereInput | undefined;

  @Field(() => [ClientOrderByWithRelationInput], {
    nullable: true
  })
  orderBy?: ClientOrderByWithRelationInput[] | undefined;

  @Field(() => ClientWhereUniqueInput, {
    nullable: true
  })
  cursor?: ClientWhereUniqueInput | undefined;

  @Field(() => Int, {
    nullable: true
  })
  take?: number | undefined;

  @Field(() => Int, {
    nullable: true
  })
  skip?: number | undefined;

  @Field(() => [ClientScalarFieldEnum], {
    nullable: true
  })
  distinct?: Array<\\"intIdField\\" | \\"uniqueStringField\\" | \\"optionalStringField\\" | \\"dateField\\"> | undefined;
}
"
`;

exports[`crud when model is renamed should properly generate args classes for every method of crud resolver: FindManyClientArgs 1`] = `
"import { Args, ArgsType, Context, Field, Float, ID, Info, InputType, Int, Mutation, ObjectType, Parent, Query, ResolveField, Resolver, registerEnumType } from \\"@nestjs/graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { ClientOrderByWithRelationInput, ClientWhereInput, ClientWhereUniqueInput } from \\"../../../inputs\\";
import { ClientScalarFieldEnum } from \\"../../../../enums/ClientScalarFieldEnum\\";

@ArgsType()
export class FindManyClientArgs {
  @Field(() => ClientWhereInput, {
    nullable: true
  })
  where?: ClientWhereInput | undefined;

  @Field(() => [ClientOrderByWithRelationInput], {
    nullable: true
  })
  orderBy?: ClientOrderByWithRelationInput[] | undefined;

  @Field(() => ClientWhereUniqueInput, {
    nullable: true
  })
  cursor?: ClientWhereUniqueInput | undefined;

  @Field(() => Int, {
    nullable: true
  })
  take?: number | undefined;

  @Field(() => Int, {
    nullable: true
  })
  skip?: number | undefined;

  @Field(() => [ClientScalarFieldEnum], {
    nullable: true
  })
  distinct?: Array<\\"intIdField\\" | \\"uniqueStringField\\" | \\"optionalStringField\\" | \\"dateField\\"> | undefined;
}
"
`;

exports[`crud when model is renamed should properly generate args classes for every method of crud resolver: FindUniqueClientArgs 1`] = `
"import { Args, ArgsType, Context, Field, Float, ID, Info, InputType, Int, Mutation, ObjectType, Parent, Query, ResolveField, Resolver, registerEnumType } from \\"@nestjs/graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { ClientWhereUniqueInput } from \\"../../../inputs\\";

@ArgsType()
export class FindUniqueClientArgs {
  @Field(() => ClientWhereUniqueInput, {
    nullable: false
  })
  where!: ClientWhereUniqueInput;
}
"
`;

exports[`crud when model is renamed should properly generate args classes for every method of crud resolver: GroupByClientArgs 1`] = `
"import { Args, ArgsType, Context, Field, Float, ID, Info, InputType, Int, Mutation, ObjectType, Parent, Query, ResolveField, Resolver, registerEnumType } from \\"@nestjs/graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { ClientOrderByWithAggregationInput, ClientScalarWhereWithAggregatesInput, ClientWhereInput } from \\"../../../inputs\\";
import { ClientScalarFieldEnum } from \\"../../../../enums/ClientScalarFieldEnum\\";

@ArgsType()
export class GroupByClientArgs {
  @Field(() => ClientWhereInput, {
    nullable: true
  })
  where?: ClientWhereInput | undefined;

  @Field(() => [ClientOrderByWithAggregationInput], {
    nullable: true
  })
  orderBy?: ClientOrderByWithAggregationInput[] | undefined;

  @Field(() => [ClientScalarFieldEnum], {
    nullable: false
  })
  by!: Array<\\"intIdField\\" | \\"uniqueStringField\\" | \\"optionalStringField\\" | \\"dateField\\">;

  @Field(() => ClientScalarWhereWithAggregatesInput, {
    nullable: true
  })
  having?: ClientScalarWhereWithAggregatesInput | undefined;

  @Field(() => Int, {
    nullable: true
  })
  take?: number | undefined;

  @Field(() => Int, {
    nullable: true
  })
  skip?: number | undefined;
}
"
`;

exports[`crud when model is renamed should properly generate args classes for every method of crud resolver: Index 1`] = `
"export { AggregateClientArgs } from \\"./AggregateClientArgs\\";
export { CreateManyAndReturnClientArgs } from \\"./CreateManyAndReturnClientArgs\\";
export { CreateManyClientArgs } from \\"./CreateManyClientArgs\\";
export { CreateOneClientArgs } from \\"./CreateOneClientArgs\\";
export { DeleteManyClientArgs } from \\"./DeleteManyClientArgs\\";
export { DeleteOneClientArgs } from \\"./DeleteOneClientArgs\\";
export { FindFirstClientArgs } from \\"./FindFirstClientArgs\\";
export { FindFirstClientOrThrowArgs } from \\"./FindFirstClientOrThrowArgs\\";
export { FindManyClientArgs } from \\"./FindManyClientArgs\\";
export { FindUniqueClientArgs } from \\"./FindUniqueClientArgs\\";
export { FindUniqueClientOrThrowArgs } from \\"./FindUniqueClientOrThrowArgs\\";
export { GroupByClientArgs } from \\"./GroupByClientArgs\\";
export { UpdateManyClientArgs } from \\"./UpdateManyClientArgs\\";
export { UpdateOneClientArgs } from \\"./UpdateOneClientArgs\\";
export { UpsertOneClientArgs } from \\"./UpsertOneClientArgs\\";
"
`;

exports[`crud when model is renamed should properly generate args classes for every method of crud resolver: UpdateClientArgs 1`] = `
"import { Args, ArgsType, Context, Field, Float, ID, Info, InputType, Int, Mutation, ObjectType, Parent, Query, ResolveField, Resolver, registerEnumType } from \\"@nestjs/graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { ClientUpdateInput, ClientWhereUniqueInput } from \\"../../../inputs\\";

@ArgsType()
export class UpdateOneClientArgs {
  @Field(() => ClientUpdateInput, {
    nullable: false
  })
  data!: ClientUpdateInput;

  @Field(() => ClientWhereUniqueInput, {
    nullable: false
  })
  where!: ClientWhereUniqueInput;
}
"
`;

exports[`crud when model is renamed should properly generate args classes for every method of crud resolver: UpdateManyClientArgs 1`] = `
"import { Args, ArgsType, Context, Field, Float, ID, Info, InputType, Int, Mutation, ObjectType, Parent, Query, ResolveField, Resolver, registerEnumType } from \\"@nestjs/graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { ClientUpdateManyMutationInput, ClientWhereInput } from \\"../../../inputs\\";

@ArgsType()
export class UpdateManyClientArgs {
  @Field(() => ClientUpdateManyMutationInput, {
    nullable: false
  })
  data!: ClientUpdateManyMutationInput;

  @Field(() => ClientWhereInput, {
    nullable: true
  })
  where?: ClientWhereInput | undefined;

  @Field(() => Int, {
    nullable: true
  })
  limit?: number | undefined;
}
"
`;

exports[`crud when model is renamed should properly generate args classes for every method of crud resolver: UpsertClientArgs 1`] = `
"import { Args, ArgsType, Context, Field, Float, ID, Info, InputType, Int, Mutation, ObjectType, Parent, Query, ResolveField, Resolver, registerEnumType } from \\"@nestjs/graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { ClientCreateInput, ClientUpdateInput, ClientWhereUniqueInput } from \\"../../../inputs\\";

@ArgsType()
export class UpsertOneClientArgs {
  @Field(() => ClientWhereUniqueInput, {
    nullable: false
  })
  where!: ClientWhereUniqueInput;

  @Field(() => ClientCreateInput, {
    nullable: false
  })
  create!: ClientCreateInput;

  @Field(() => ClientUpdateInput, {
    nullable: false
  })
  update!: ClientUpdateInput;
}
"
`;

exports[`crud when model is renamed should properly generate resolver class for single prisma model: AggregateMainUserResolver 1`] = `
"import { Args, ArgsType, Context, Field, Float, ID, Info, InputType, Int, Mutation, ObjectType, Parent, Query, ResolveField, Resolver, registerEnumType } from \\"@nestjs/graphql\\";
import type { GraphQLResolveInfo } from \\"graphql\\";
import { AggregateMainUserArgs } from \\"./args/AggregateMainUserArgs\\";
import { MainUser } from \\"../../../models/MainUser\\";
import { AggregateMainUser } from \\"../../outputs/AggregateMainUser\\";
import { transformArgsIntoPrismaArgs, transformInfoIntoPrismaArgs, getPrismaFromContext, transformCountFieldIntoSelectRelationsCount, InlineLoader } from \\"../../../helpers\\";

@Resolver(() => MainUser)
export class AggregateMainUserResolver {
  @Query(() => AggregateMainUser, {
    nullable: false
  })
  async aggregateMainUser(@Context() ctx: any, @Info() info: GraphQLResolveInfo, @Args() args: AggregateMainUserArgs): Promise<AggregateMainUser> {
    const afterProcessEvents: ((result: any) => Promise<any>)[] = [];
    const transformedArgsIntoPrismaArgs = await transformArgsIntoPrismaArgs(info, args, ctx, 'User', 'user', 'aggregate', afterProcessEvents);
    const transformedInfoIntoPrismaArgs = transformInfoIntoPrismaArgs(info, 'User', 'user', 'aggregate');
    const result = await getPrismaFromContext(ctx).user.aggregate({ ...transformedArgsIntoPrismaArgs, ...transformedInfoIntoPrismaArgs, });
    for (const afterProcessEvent of afterProcessEvents) { await afterProcessEvent(result); }

    return result;
  }
}
"
`;

exports[`crud when model is renamed should properly generate resolver class for single prisma model: ClientCrudResolver 1`] = `
"import { Args, ArgsType, Context, Field, Float, ID, Info, InputType, Int, Mutation, ObjectType, Parent, Query, ResolveField, Resolver, registerEnumType } from \\"@nestjs/graphql\\";
import type { GraphQLResolveInfo } from \\"graphql\\";
import { AggregateClientArgs } from \\"./args/AggregateClientArgs\\";
import { CreateManyAndReturnClientArgs } from \\"./args/CreateManyAndReturnClientArgs\\";
import { CreateManyClientArgs } from \\"./args/CreateManyClientArgs\\";
import { CreateOneClientArgs } from \\"./args/CreateOneClientArgs\\";
import { DeleteManyClientArgs } from \\"./args/DeleteManyClientArgs\\";
import { DeleteOneClientArgs } from \\"./args/DeleteOneClientArgs\\";
import { FindFirstClientArgs } from \\"./args/FindFirstClientArgs\\";
import { FindFirstClientOrThrowArgs } from \\"./args/FindFirstClientOrThrowArgs\\";
import { FindManyClientArgs } from \\"./args/FindManyClientArgs\\";
import { FindUniqueClientArgs } from \\"./args/FindUniqueClientArgs\\";
import { FindUniqueClientOrThrowArgs } from \\"./args/FindUniqueClientOrThrowArgs\\";
import { GroupByClientArgs } from \\"./args/GroupByClientArgs\\";
import { UpdateManyClientArgs } from \\"./args/UpdateManyClientArgs\\";
import { UpdateOneClientArgs } from \\"./args/UpdateOneClientArgs\\";
import { UpsertOneClientArgs } from \\"./args/UpsertOneClientArgs\\";
import { transformArgsIntoPrismaArgs, transformInfoIntoPrismaArgs, getPrismaFromContext, transformCountFieldIntoSelectRelationsCount, InlineLoader } from \\"../../../helpers\\";
import { Client } from \\"../../../models/Client\\";
import { AffectedRowsOutput } from \\"../../outputs/AffectedRowsOutput\\";
import { AggregateClient } from \\"../../outputs/AggregateClient\\";
import { ClientGroupBy } from \\"../../outputs/ClientGroupBy\\";
import { CreateManyAndReturnClient } from \\"../../outputs/CreateManyAndReturnClient\\";

@Resolver(() => Client)
export class ClientCrudResolver {
  @Query(() => AggregateClient, {
    nullable: false
  })
  async aggregateClient(@Context() ctx: any, @Info() info: GraphQLResolveInfo, @Args() args: AggregateClientArgs): Promise<AggregateClient> {
    const afterProcessEvents: ((result: any) => Promise<any>)[] = [];
    const transformedArgsIntoPrismaArgs = await transformArgsIntoPrismaArgs(info, args, ctx, 'User', 'user', 'aggregate', afterProcessEvents);
    const transformedInfoIntoPrismaArgs = transformInfoIntoPrismaArgs(info, 'User', 'user', 'aggregate');
    const result = await getPrismaFromContext(ctx).user.aggregate({ ...transformedArgsIntoPrismaArgs, ...transformedInfoIntoPrismaArgs, });
    for (const afterProcessEvent of afterProcessEvents) { await afterProcessEvent(result); }

    return result;
  }

  @Mutation(() => AffectedRowsOutput, {
    nullable: false
  })
  async createManyClient(@Context() ctx: any, @Info() info: GraphQLResolveInfo, @Args() args: CreateManyClientArgs): Promise<AffectedRowsOutput> {
    const afterProcessEvents: ((result: any) => Promise<any>)[] = [];
    const { _count } = transformInfoIntoPrismaArgs(info, 'User', 'user', 'createMany');
    const transformedArgsIntoPrismaArgs = await transformArgsIntoPrismaArgs(info, args, ctx, 'User', 'user', 'createMany', afterProcessEvents);
    const otherArgs = _count && transformCountFieldIntoSelectRelationsCount(_count, 'User', 'user', 'createMany');
    const result = await getPrismaFromContext(ctx).user.createMany({ ...transformedArgsIntoPrismaArgs, ...otherArgs, });
    for (const afterProcessEvent of afterProcessEvents) { await afterProcessEvent(result); }

    return result;
  }

  @Mutation(() => [CreateManyAndReturnClient], {
    nullable: false
  })
  async createManyAndReturnClient(@Context() ctx: any, @Info() info: GraphQLResolveInfo, @Args() args: CreateManyAndReturnClientArgs): Promise<CreateManyAndReturnClient[]> {
    const afterProcessEvents: ((result: any) => Promise<any>)[] = [];
    const { _count } = transformInfoIntoPrismaArgs(info, 'User', 'user', 'createManyAndReturn');
    const transformedArgsIntoPrismaArgs = await transformArgsIntoPrismaArgs(info, args, ctx, 'User', 'user', 'createManyAndReturn', afterProcessEvents);
    const otherArgs = _count && transformCountFieldIntoSelectRelationsCount(_count, 'User', 'user', 'createManyAndReturn');
    const result = await getPrismaFromContext(ctx).user.createManyAndReturn({ ...transformedArgsIntoPrismaArgs, ...otherArgs, });
    for (const afterProcessEvent of afterProcessEvents) { await afterProcessEvent(result); }

    return result;
  }

  @Mutation(() => Client, {
    nullable: false
  })
  async createOneClient(@Context() ctx: any, @Info() info: GraphQLResolveInfo, @Args() args: CreateOneClientArgs): Promise<Client> {
    const afterProcessEvents: ((result: any) => Promise<any>)[] = [];
    const { _count } = transformInfoIntoPrismaArgs(info, 'User', 'user', 'create');
    const transformedArgsIntoPrismaArgs = await transformArgsIntoPrismaArgs(info, args, ctx, 'User', 'user', 'create', afterProcessEvents);
    const otherArgs = _count && transformCountFieldIntoSelectRelationsCount(_count, 'User', 'user', 'create');
    const result = await getPrismaFromContext(ctx).user.create({ ...transformedArgsIntoPrismaArgs, ...otherArgs, });
    for (const afterProcessEvent of afterProcessEvents) { await afterProcessEvent(result); }

    return result;
  }

  @Mutation(() => AffectedRowsOutput, {
    nullable: false
  })
  async deleteManyClient(@Context() ctx: any, @Info() info: GraphQLResolveInfo, @Args() args: DeleteManyClientArgs): Promise<AffectedRowsOutput> {
    const afterProcessEvents: ((result: any) => Promise<any>)[] = [];
    const { _count } = transformInfoIntoPrismaArgs(info, 'User', 'user', 'deleteMany');
    const transformedArgsIntoPrismaArgs = await transformArgsIntoPrismaArgs(info, args, ctx, 'User', 'user', 'deleteMany', afterProcessEvents);
    const otherArgs = _count && transformCountFieldIntoSelectRelationsCount(_count, 'User', 'user', 'deleteMany');
    const result = await getPrismaFromContext(ctx).user.deleteMany({ ...transformedArgsIntoPrismaArgs, ...otherArgs, });
    for (const afterProcessEvent of afterProcessEvents) { await afterProcessEvent(result); }

    return result;
  }

  @Mutation(() => Client, {
    nullable: true
  })
  async deleteOneClient(@Context() ctx: any, @Info() info: GraphQLResolveInfo, @Args() args: DeleteOneClientArgs): Promise<Client | null> {
    const afterProcessEvents: ((result: any) => Promise<any>)[] = [];
    const { _count } = transformInfoIntoPrismaArgs(info, 'User', 'user', 'delete');
    const transformedArgsIntoPrismaArgs = await transformArgsIntoPrismaArgs(info, args, ctx, 'User', 'user', 'delete', afterProcessEvents);
    const otherArgs = _count && transformCountFieldIntoSelectRelationsCount(_count, 'User', 'user', 'delete');
    const result = await getPrismaFromContext(ctx).user.delete({ ...transformedArgsIntoPrismaArgs, ...otherArgs, });
    for (const afterProcessEvent of afterProcessEvents) { await afterProcessEvent(result); }

    return result;
  }

  @Query(() => Client, {
    nullable: true
  })
  async findFirstClient(@Context() ctx: any, @Info() info: GraphQLResolveInfo, @Args() args: FindFirstClientArgs): Promise<Client | null> {
    const afterProcessEvents: ((result: any) => Promise<any>)[] = [];
    const { _count } = transformInfoIntoPrismaArgs(info, 'User', 'user', 'findFirst');
    const transformedArgsIntoPrismaArgs = await transformArgsIntoPrismaArgs(info, args, ctx, 'User', 'user', 'findFirst', afterProcessEvents);
    const otherArgs = _count && transformCountFieldIntoSelectRelationsCount(_count, 'User', 'user', 'findFirst');
    const result = await getPrismaFromContext(ctx).user.findFirst({ ...transformedArgsIntoPrismaArgs, ...otherArgs, });
    for (const afterProcessEvent of afterProcessEvents) { await afterProcessEvent(result); }

    return result;
  }

  @Query(() => Client, {
    nullable: true
  })
  async findFirstClientOrThrow(@Context() ctx: any, @Info() info: GraphQLResolveInfo, @Args() args: FindFirstClientOrThrowArgs): Promise<Client | null> {
    const afterProcessEvents: ((result: any) => Promise<any>)[] = [];
    const { _count } = transformInfoIntoPrismaArgs(info, 'User', 'user', 'findFirstOrThrow');
    const transformedArgsIntoPrismaArgs = await transformArgsIntoPrismaArgs(info, args, ctx, 'User', 'user', 'findFirstOrThrow', afterProcessEvents);
    const otherArgs = _count && transformCountFieldIntoSelectRelationsCount(_count, 'User', 'user', 'findFirstOrThrow');
    const result = await getPrismaFromContext(ctx).user.findFirstOrThrow({ ...transformedArgsIntoPrismaArgs, ...otherArgs, });
    for (const afterProcessEvent of afterProcessEvents) { await afterProcessEvent(result); }

    return result;
  }

  @Query(() => [Client], {
    nullable: false
  })
  async findManyClient(@Context() ctx: any, @Info() info: GraphQLResolveInfo, @Args() args: FindManyClientArgs): Promise<Client[]> {
    const afterProcessEvents: ((result: any) => Promise<any>)[] = [];
    const { _count } = transformInfoIntoPrismaArgs(info, 'User', 'user', 'findMany');
    const transformedArgsIntoPrismaArgs = await transformArgsIntoPrismaArgs(info, args, ctx, 'User', 'user', 'findMany', afterProcessEvents);
    const otherArgs = _count && transformCountFieldIntoSelectRelationsCount(_count, 'User', 'user', 'findMany');
    const result = await getPrismaFromContext(ctx).user.findMany({ ...transformedArgsIntoPrismaArgs, ...otherArgs, });
    for (const afterProcessEvent of afterProcessEvents) { await afterProcessEvent(result); }

    return result;
  }

  @Query(() => Client, {
    nullable: true
  })
  async findUniqueClient(@Context() ctx: any, @Info() info: GraphQLResolveInfo, @Args() args: FindUniqueClientArgs): Promise<Client | null> {
    const afterProcessEvents: ((result: any) => Promise<any>)[] = [];
    const { _count } = transformInfoIntoPrismaArgs(info, 'User', 'user', 'findUnique');
    const transformedArgsIntoPrismaArgs = await transformArgsIntoPrismaArgs(info, args, ctx, 'User', 'user', 'findUnique', afterProcessEvents);
    const otherArgs = _count && transformCountFieldIntoSelectRelationsCount(_count, 'User', 'user', 'findUnique');
    const result = await getPrismaFromContext(ctx).user.findUnique({ ...transformedArgsIntoPrismaArgs, ...otherArgs, });
    for (const afterProcessEvent of afterProcessEvents) { await afterProcessEvent(result); }

    return result;
  }

  @Query(() => Client, {
    nullable: true
  })
  async findUniqueClientOrThrow(@Context() ctx: any, @Info() info: GraphQLResolveInfo, @Args() args: FindUniqueClientOrThrowArgs): Promise<Client | null> {
    const afterProcessEvents: ((result: any) => Promise<any>)[] = [];
    const { _count } = transformInfoIntoPrismaArgs(info, 'User', 'user', 'findUniqueOrThrow');
    const transformedArgsIntoPrismaArgs = await transformArgsIntoPrismaArgs(info, args, ctx, 'User', 'user', 'findUniqueOrThrow', afterProcessEvents);
    const otherArgs = _count && transformCountFieldIntoSelectRelationsCount(_count, 'User', 'user', 'findUniqueOrThrow');
    const result = await getPrismaFromContext(ctx).user.findUniqueOrThrow({ ...transformedArgsIntoPrismaArgs, ...otherArgs, });
    for (const afterProcessEvent of afterProcessEvents) { await afterProcessEvent(result); }

    return result;
  }

  @Query(() => [ClientGroupBy], {
    nullable: false
  })
  async groupByClient(@Context() ctx: any, @Info() info: GraphQLResolveInfo, @Args() args: GroupByClientArgs): Promise<ClientGroupBy[]> {
    const afterProcessEvents: ((result: any) => Promise<any>)[] = [];
    const { _count, _avg, _sum, _min, _max } = transformInfoIntoPrismaArgs(info, 'User', 'user', 'groupBy');
    const transformedArgsIntoPrismaArgs = await transformArgsIntoPrismaArgs(info, args, ctx, 'User', 'user', 'groupBy', afterProcessEvents);
    const groupByArgs = Object.fromEntries(Object.entries({ _count, _avg, _sum, _min, _max }).filter(([_, v]) => v != null));
    const result = await getPrismaFromContext(ctx).user.groupBy({ ...transformedArgsIntoPrismaArgs, ...groupByArgs, });
    for (const afterProcessEvent of afterProcessEvents) { await afterProcessEvent(result); }

    return result;
  }

  @Mutation(() => AffectedRowsOutput, {
    nullable: false
  })
  async updateManyClient(@Context() ctx: any, @Info() info: GraphQLResolveInfo, @Args() args: UpdateManyClientArgs): Promise<AffectedRowsOutput> {
    const afterProcessEvents: ((result: any) => Promise<any>)[] = [];
    const { _count } = transformInfoIntoPrismaArgs(info, 'User', 'user', 'updateMany');
    const transformedArgsIntoPrismaArgs = await transformArgsIntoPrismaArgs(info, args, ctx, 'User', 'user', 'updateMany', afterProcessEvents);
    const otherArgs = _count && transformCountFieldIntoSelectRelationsCount(_count, 'User', 'user', 'updateMany');
    const result = await getPrismaFromContext(ctx).user.updateMany({ ...transformedArgsIntoPrismaArgs, ...otherArgs, });
    for (const afterProcessEvent of afterProcessEvents) { await afterProcessEvent(result); }

    return result;
  }

  @Mutation(() => Client, {
    nullable: true
  })
  async updateOneClient(@Context() ctx: any, @Info() info: GraphQLResolveInfo, @Args() args: UpdateOneClientArgs): Promise<Client | null> {
    const afterProcessEvents: ((result: any) => Promise<any>)[] = [];
    const { _count } = transformInfoIntoPrismaArgs(info, 'User', 'user', 'update');
    const transformedArgsIntoPrismaArgs = await transformArgsIntoPrismaArgs(info, args, ctx, 'User', 'user', 'update', afterProcessEvents);
    const otherArgs = _count && transformCountFieldIntoSelectRelationsCount(_count, 'User', 'user', 'update');
    const result = await getPrismaFromContext(ctx).user.update({ ...transformedArgsIntoPrismaArgs, ...otherArgs, });
    for (const afterProcessEvent of afterProcessEvents) { await afterProcessEvent(result); }

    return result;
  }

  @Mutation(() => Client, {
    nullable: false
  })
  async upsertOneClient(@Context() ctx: any, @Info() info: GraphQLResolveInfo, @Args() args: UpsertOneClientArgs): Promise<Client> {
    const afterProcessEvents: ((result: any) => Promise<any>)[] = [];
    const { _count } = transformInfoIntoPrismaArgs(info, 'User', 'user', 'upsert');
    const transformedArgsIntoPrismaArgs = await transformArgsIntoPrismaArgs(info, args, ctx, 'User', 'user', 'upsert', afterProcessEvents);
    const otherArgs = _count && transformCountFieldIntoSelectRelationsCount(_count, 'User', 'user', 'upsert');
    const result = await getPrismaFromContext(ctx).user.upsert({ ...transformedArgsIntoPrismaArgs, ...otherArgs, });
    for (const afterProcessEvent of afterProcessEvents) { await afterProcessEvent(result); }

    return result;
  }
}
"
`;

exports[`crud when model is renamed should properly generate resolver class for single prisma model: GroupByMainUserResolver 1`] = `
"import { Args, ArgsType, Context, Field, Float, ID, Info, InputType, Int, Mutation, ObjectType, Parent, Query, ResolveField, Resolver, registerEnumType } from \\"@nestjs/graphql\\";
import type { GraphQLResolveInfo } from \\"graphql\\";
import { GroupByMainUserArgs } from \\"./args/GroupByMainUserArgs\\";
import { MainUser } from \\"../../../models/MainUser\\";
import { MainUserGroupBy } from \\"../../outputs/MainUserGroupBy\\";
import { transformArgsIntoPrismaArgs, transformInfoIntoPrismaArgs, getPrismaFromContext, transformCountFieldIntoSelectRelationsCount, InlineLoader } from \\"../../../helpers\\";

@Resolver(() => MainUser)
export class GroupByMainUserResolver {
  @Query(() => [MainUserGroupBy], {
    nullable: false
  })
  async groupByMainUser(@Context() ctx: any, @Info() info: GraphQLResolveInfo, @Args() args: GroupByMainUserArgs): Promise<MainUserGroupBy[]> {
    const afterProcessEvents: ((result: any) => Promise<any>)[] = [];
    const { _count, _avg, _sum, _min, _max } = transformInfoIntoPrismaArgs(info, 'User', 'user', 'groupBy');
    const transformedArgsIntoPrismaArgs = await transformArgsIntoPrismaArgs(info, args, ctx, 'User', 'user', 'groupBy', afterProcessEvents);
    const groupByArgs = Object.fromEntries(Object.entries({ _count, _avg, _sum, _min, _max }).filter(([_, v]) => v != null));
    const result = await getPrismaFromContext(ctx).user.groupBy({ ...transformedArgsIntoPrismaArgs, ...groupByArgs, });
    for (const afterProcessEvent of afterProcessEvents) { await afterProcessEvent(result); }

    return result;
  }
}
"
`;

exports[`crud when model is renamed should properly generate resolver class for single prisma model: MainUserCrudResolver 1`] = `
"import { Args, ArgsType, Context, Field, Float, ID, Info, InputType, Int, Mutation, ObjectType, Parent, Query, ResolveField, Resolver, registerEnumType } from \\"@nestjs/graphql\\";
import type { GraphQLResolveInfo } from \\"graphql\\";
import { AggregateMainUserArgs } from \\"./args/AggregateMainUserArgs\\";
import { CreateManyAndReturnMainUserArgs } from \\"./args/CreateManyAndReturnMainUserArgs\\";
import { CreateManyMainUserArgs } from \\"./args/CreateManyMainUserArgs\\";
import { CreateOneMainUserArgs } from \\"./args/CreateOneMainUserArgs\\";
import { DeleteManyMainUserArgs } from \\"./args/DeleteManyMainUserArgs\\";
import { DeleteOneMainUserArgs } from \\"./args/DeleteOneMainUserArgs\\";
import { FindFirstMainUserArgs } from \\"./args/FindFirstMainUserArgs\\";
import { FindFirstMainUserOrThrowArgs } from \\"./args/FindFirstMainUserOrThrowArgs\\";
import { FindManyMainUserArgs } from \\"./args/FindManyMainUserArgs\\";
import { FindUniqueMainUserArgs } from \\"./args/FindUniqueMainUserArgs\\";
import { FindUniqueMainUserOrThrowArgs } from \\"./args/FindUniqueMainUserOrThrowArgs\\";
import { GroupByMainUserArgs } from \\"./args/GroupByMainUserArgs\\";
import { UpdateManyMainUserArgs } from \\"./args/UpdateManyMainUserArgs\\";
import { UpdateOneMainUserArgs } from \\"./args/UpdateOneMainUserArgs\\";
import { UpsertOneMainUserArgs } from \\"./args/UpsertOneMainUserArgs\\";
import { transformArgsIntoPrismaArgs, transformInfoIntoPrismaArgs, getPrismaFromContext, transformCountFieldIntoSelectRelationsCount, InlineLoader } from \\"../../../helpers\\";
import { MainUser } from \\"../../../models/MainUser\\";
import { AffectedRowsOutput } from \\"../../outputs/AffectedRowsOutput\\";
import { AggregateMainUser } from \\"../../outputs/AggregateMainUser\\";
import { CreateManyAndReturnMainUser } from \\"../../outputs/CreateManyAndReturnMainUser\\";
import { MainUserGroupBy } from \\"../../outputs/MainUserGroupBy\\";

@Resolver(() => MainUser)
export class MainUserCrudResolver {
  @Query(() => AggregateMainUser, {
    nullable: false
  })
  async aggregateMainUser(@Context() ctx: any, @Info() info: GraphQLResolveInfo, @Args() args: AggregateMainUserArgs): Promise<AggregateMainUser> {
    const afterProcessEvents: ((result: any) => Promise<any>)[] = [];
    const transformedArgsIntoPrismaArgs = await transformArgsIntoPrismaArgs(info, args, ctx, 'User', 'user', 'aggregate', afterProcessEvents);
    const transformedInfoIntoPrismaArgs = transformInfoIntoPrismaArgs(info, 'User', 'user', 'aggregate');
    const result = await getPrismaFromContext(ctx).user.aggregate({ ...transformedArgsIntoPrismaArgs, ...transformedInfoIntoPrismaArgs, });
    for (const afterProcessEvent of afterProcessEvents) { await afterProcessEvent(result); }

    return result;
  }

  @Mutation(() => AffectedRowsOutput, {
    nullable: false
  })
  async createManyMainUser(@Context() ctx: any, @Info() info: GraphQLResolveInfo, @Args() args: CreateManyMainUserArgs): Promise<AffectedRowsOutput> {
    const afterProcessEvents: ((result: any) => Promise<any>)[] = [];
    const { _count } = transformInfoIntoPrismaArgs(info, 'User', 'user', 'createMany');
    const transformedArgsIntoPrismaArgs = await transformArgsIntoPrismaArgs(info, args, ctx, 'User', 'user', 'createMany', afterProcessEvents);
    const otherArgs = _count && transformCountFieldIntoSelectRelationsCount(_count, 'User', 'user', 'createMany');
    const result = await getPrismaFromContext(ctx).user.createMany({ ...transformedArgsIntoPrismaArgs, ...otherArgs, });
    for (const afterProcessEvent of afterProcessEvents) { await afterProcessEvent(result); }

    return result;
  }

  @Mutation(() => [CreateManyAndReturnMainUser], {
    nullable: false
  })
  async createManyAndReturnMainUser(@Context() ctx: any, @Info() info: GraphQLResolveInfo, @Args() args: CreateManyAndReturnMainUserArgs): Promise<CreateManyAndReturnMainUser[]> {
    const afterProcessEvents: ((result: any) => Promise<any>)[] = [];
    const { _count } = transformInfoIntoPrismaArgs(info, 'User', 'user', 'createManyAndReturn');
    const transformedArgsIntoPrismaArgs = await transformArgsIntoPrismaArgs(info, args, ctx, 'User', 'user', 'createManyAndReturn', afterProcessEvents);
    const otherArgs = _count && transformCountFieldIntoSelectRelationsCount(_count, 'User', 'user', 'createManyAndReturn');
    const result = await getPrismaFromContext(ctx).user.createManyAndReturn({ ...transformedArgsIntoPrismaArgs, ...otherArgs, });
    for (const afterProcessEvent of afterProcessEvents) { await afterProcessEvent(result); }

    return result;
  }

  @Mutation(() => MainUser, {
    nullable: false
  })
  async createOneMainUser(@Context() ctx: any, @Info() info: GraphQLResolveInfo, @Args() args: CreateOneMainUserArgs): Promise<MainUser> {
    const afterProcessEvents: ((result: any) => Promise<any>)[] = [];
    const { _count } = transformInfoIntoPrismaArgs(info, 'User', 'user', 'create');
    const transformedArgsIntoPrismaArgs = await transformArgsIntoPrismaArgs(info, args, ctx, 'User', 'user', 'create', afterProcessEvents);
    const otherArgs = _count && transformCountFieldIntoSelectRelationsCount(_count, 'User', 'user', 'create');
    const result = await getPrismaFromContext(ctx).user.create({ ...transformedArgsIntoPrismaArgs, ...otherArgs, });
    for (const afterProcessEvent of afterProcessEvents) { await afterProcessEvent(result); }

    return result;
  }

  @Mutation(() => AffectedRowsOutput, {
    nullable: false
  })
  async deleteManyMainUser(@Context() ctx: any, @Info() info: GraphQLResolveInfo, @Args() args: DeleteManyMainUserArgs): Promise<AffectedRowsOutput> {
    const afterProcessEvents: ((result: any) => Promise<any>)[] = [];
    const { _count } = transformInfoIntoPrismaArgs(info, 'User', 'user', 'deleteMany');
    const transformedArgsIntoPrismaArgs = await transformArgsIntoPrismaArgs(info, args, ctx, 'User', 'user', 'deleteMany', afterProcessEvents);
    const otherArgs = _count && transformCountFieldIntoSelectRelationsCount(_count, 'User', 'user', 'deleteMany');
    const result = await getPrismaFromContext(ctx).user.deleteMany({ ...transformedArgsIntoPrismaArgs, ...otherArgs, });
    for (const afterProcessEvent of afterProcessEvents) { await afterProcessEvent(result); }

    return result;
  }

  @Mutation(() => MainUser, {
    nullable: true
  })
  async deleteOneMainUser(@Context() ctx: any, @Info() info: GraphQLResolveInfo, @Args() args: DeleteOneMainUserArgs): Promise<MainUser | null> {
    const afterProcessEvents: ((result: any) => Promise<any>)[] = [];
    const { _count } = transformInfoIntoPrismaArgs(info, 'User', 'user', 'delete');
    const transformedArgsIntoPrismaArgs = await transformArgsIntoPrismaArgs(info, args, ctx, 'User', 'user', 'delete', afterProcessEvents);
    const otherArgs = _count && transformCountFieldIntoSelectRelationsCount(_count, 'User', 'user', 'delete');
    const result = await getPrismaFromContext(ctx).user.delete({ ...transformedArgsIntoPrismaArgs, ...otherArgs, });
    for (const afterProcessEvent of afterProcessEvents) { await afterProcessEvent(result); }

    return result;
  }

  @Query(() => MainUser, {
    nullable: true
  })
  async findFirstMainUser(@Context() ctx: any, @Info() info: GraphQLResolveInfo, @Args() args: FindFirstMainUserArgs): Promise<MainUser | null> {
    const afterProcessEvents: ((result: any) => Promise<any>)[] = [];
    const { _count } = transformInfoIntoPrismaArgs(info, 'User', 'user', 'findFirst');
    const transformedArgsIntoPrismaArgs = await transformArgsIntoPrismaArgs(info, args, ctx, 'User', 'user', 'findFirst', afterProcessEvents);
    const otherArgs = _count && transformCountFieldIntoSelectRelationsCount(_count, 'User', 'user', 'findFirst');
    const result = await getPrismaFromContext(ctx).user.findFirst({ ...transformedArgsIntoPrismaArgs, ...otherArgs, });
    for (const afterProcessEvent of afterProcessEvents) { await afterProcessEvent(result); }

    return result;
  }

  @Query(() => MainUser, {
    nullable: true
  })
  async findFirstMainUserOrThrow(@Context() ctx: any, @Info() info: GraphQLResolveInfo, @Args() args: FindFirstMainUserOrThrowArgs): Promise<MainUser | null> {
    const afterProcessEvents: ((result: any) => Promise<any>)[] = [];
    const { _count } = transformInfoIntoPrismaArgs(info, 'User', 'user', 'findFirstOrThrow');
    const transformedArgsIntoPrismaArgs = await transformArgsIntoPrismaArgs(info, args, ctx, 'User', 'user', 'findFirstOrThrow', afterProcessEvents);
    const otherArgs = _count && transformCountFieldIntoSelectRelationsCount(_count, 'User', 'user', 'findFirstOrThrow');
    const result = await getPrismaFromContext(ctx).user.findFirstOrThrow({ ...transformedArgsIntoPrismaArgs, ...otherArgs, });
    for (const afterProcessEvent of afterProcessEvents) { await afterProcessEvent(result); }

    return result;
  }

  @Query(() => [MainUser], {
    nullable: false
  })
  async mainUsers(@Context() ctx: any, @Info() info: GraphQLResolveInfo, @Args() args: FindManyMainUserArgs): Promise<MainUser[]> {
    const afterProcessEvents: ((result: any) => Promise<any>)[] = [];
    const { _count } = transformInfoIntoPrismaArgs(info, 'User', 'user', 'findMany');
    const transformedArgsIntoPrismaArgs = await transformArgsIntoPrismaArgs(info, args, ctx, 'User', 'user', 'findMany', afterProcessEvents);
    const otherArgs = _count && transformCountFieldIntoSelectRelationsCount(_count, 'User', 'user', 'findMany');
    const result = await getPrismaFromContext(ctx).user.findMany({ ...transformedArgsIntoPrismaArgs, ...otherArgs, });
    for (const afterProcessEvent of afterProcessEvents) { await afterProcessEvent(result); }

    return result;
  }

  @Query(() => MainUser, {
    nullable: true
  })
  async mainUser(@Context() ctx: any, @Info() info: GraphQLResolveInfo, @Args() args: FindUniqueMainUserArgs): Promise<MainUser | null> {
    const afterProcessEvents: ((result: any) => Promise<any>)[] = [];
    const { _count } = transformInfoIntoPrismaArgs(info, 'User', 'user', 'findUnique');
    const transformedArgsIntoPrismaArgs = await transformArgsIntoPrismaArgs(info, args, ctx, 'User', 'user', 'findUnique', afterProcessEvents);
    const otherArgs = _count && transformCountFieldIntoSelectRelationsCount(_count, 'User', 'user', 'findUnique');
    const result = await getPrismaFromContext(ctx).user.findUnique({ ...transformedArgsIntoPrismaArgs, ...otherArgs, });
    for (const afterProcessEvent of afterProcessEvents) { await afterProcessEvent(result); }

    return result;
  }

  @Query(() => MainUser, {
    nullable: true
  })
  async getMainUser(@Context() ctx: any, @Info() info: GraphQLResolveInfo, @Args() args: FindUniqueMainUserOrThrowArgs): Promise<MainUser | null> {
    const afterProcessEvents: ((result: any) => Promise<any>)[] = [];
    const { _count } = transformInfoIntoPrismaArgs(info, 'User', 'user', 'findUniqueOrThrow');
    const transformedArgsIntoPrismaArgs = await transformArgsIntoPrismaArgs(info, args, ctx, 'User', 'user', 'findUniqueOrThrow', afterProcessEvents);
    const otherArgs = _count && transformCountFieldIntoSelectRelationsCount(_count, 'User', 'user', 'findUniqueOrThrow');
    const result = await getPrismaFromContext(ctx).user.findUniqueOrThrow({ ...transformedArgsIntoPrismaArgs, ...otherArgs, });
    for (const afterProcessEvent of afterProcessEvents) { await afterProcessEvent(result); }

    return result;
  }

  @Query(() => [MainUserGroupBy], {
    nullable: false
  })
  async groupByMainUser(@Context() ctx: any, @Info() info: GraphQLResolveInfo, @Args() args: GroupByMainUserArgs): Promise<MainUserGroupBy[]> {
    const afterProcessEvents: ((result: any) => Promise<any>)[] = [];
    const { _count, _avg, _sum, _min, _max } = transformInfoIntoPrismaArgs(info, 'User', 'user', 'groupBy');
    const transformedArgsIntoPrismaArgs = await transformArgsIntoPrismaArgs(info, args, ctx, 'User', 'user', 'groupBy', afterProcessEvents);
    const groupByArgs = Object.fromEntries(Object.entries({ _count, _avg, _sum, _min, _max }).filter(([_, v]) => v != null));
    const result = await getPrismaFromContext(ctx).user.groupBy({ ...transformedArgsIntoPrismaArgs, ...groupByArgs, });
    for (const afterProcessEvent of afterProcessEvents) { await afterProcessEvent(result); }

    return result;
  }

  @Mutation(() => AffectedRowsOutput, {
    nullable: false
  })
  async updateManyMainUser(@Context() ctx: any, @Info() info: GraphQLResolveInfo, @Args() args: UpdateManyMainUserArgs): Promise<AffectedRowsOutput> {
    const afterProcessEvents: ((result: any) => Promise<any>)[] = [];
    const { _count } = transformInfoIntoPrismaArgs(info, 'User', 'user', 'updateMany');
    const transformedArgsIntoPrismaArgs = await transformArgsIntoPrismaArgs(info, args, ctx, 'User', 'user', 'updateMany', afterProcessEvents);
    const otherArgs = _count && transformCountFieldIntoSelectRelationsCount(_count, 'User', 'user', 'updateMany');
    const result = await getPrismaFromContext(ctx).user.updateMany({ ...transformedArgsIntoPrismaArgs, ...otherArgs, });
    for (const afterProcessEvent of afterProcessEvents) { await afterProcessEvent(result); }

    return result;
  }

  @Mutation(() => MainUser, {
    nullable: true
  })
  async updateOneMainUser(@Context() ctx: any, @Info() info: GraphQLResolveInfo, @Args() args: UpdateOneMainUserArgs): Promise<MainUser | null> {
    const afterProcessEvents: ((result: any) => Promise<any>)[] = [];
    const { _count } = transformInfoIntoPrismaArgs(info, 'User', 'user', 'update');
    const transformedArgsIntoPrismaArgs = await transformArgsIntoPrismaArgs(info, args, ctx, 'User', 'user', 'update', afterProcessEvents);
    const otherArgs = _count && transformCountFieldIntoSelectRelationsCount(_count, 'User', 'user', 'update');
    const result = await getPrismaFromContext(ctx).user.update({ ...transformedArgsIntoPrismaArgs, ...otherArgs, });
    for (const afterProcessEvent of afterProcessEvents) { await afterProcessEvent(result); }

    return result;
  }

  @Mutation(() => MainUser, {
    nullable: false
  })
  async upsertOneMainUser(@Context() ctx: any, @Info() info: GraphQLResolveInfo, @Args() args: UpsertOneMainUserArgs): Promise<MainUser> {
    const afterProcessEvents: ((result: any) => Promise<any>)[] = [];
    const { _count } = transformInfoIntoPrismaArgs(info, 'User', 'user', 'upsert');
    const transformedArgsIntoPrismaArgs = await transformArgsIntoPrismaArgs(info, args, ctx, 'User', 'user', 'upsert', afterProcessEvents);
    const otherArgs = _count && transformCountFieldIntoSelectRelationsCount(_count, 'User', 'user', 'upsert');
    const result = await getPrismaFromContext(ctx).user.upsert({ ...transformedArgsIntoPrismaArgs, ...otherArgs, });
    for (const afterProcessEvent of afterProcessEvents) { await afterProcessEvent(result); }

    return result;
  }
}
"
`;

exports[`crud when useUncheckedScalarInputs mode is enabled should properly generate create and update args classes: CreateOneUserArgs 1`] = `
"import { Args, ArgsType, Context, Field, Float, ID, Info, InputType, Int, Mutation, ObjectType, Parent, Query, ResolveField, Resolver, registerEnumType } from \\"@nestjs/graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { UserUncheckedCreateInput } from \\"../../../inputs\\";

@ArgsType()
export class CreateOneUserArgs {
  @Field(() => UserUncheckedCreateInput, {
    nullable: false
  })
  data!: UserUncheckedCreateInput;
}
"
`;

exports[`crud when useUncheckedScalarInputs mode is enabled should properly generate create and update args classes: UpdateManyUserArgs 1`] = `
"import { Args, ArgsType, Context, Field, Float, ID, Info, InputType, Int, Mutation, ObjectType, Parent, Query, ResolveField, Resolver, registerEnumType } from \\"@nestjs/graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { UserUncheckedUpdateManyInput, UserWhereInput } from \\"../../../inputs\\";

@ArgsType()
export class UpdateManyUserArgs {
  @Field(() => UserUncheckedUpdateManyInput, {
    nullable: false
  })
  data!: UserUncheckedUpdateManyInput;

  @Field(() => UserWhereInput, {
    nullable: true
  })
  where?: UserWhereInput | undefined;

  @Field(() => Int, {
    nullable: true
  })
  limit?: number | undefined;
}
"
`;

exports[`crud when useUncheckedScalarInputs mode is enabled should properly generate create and update args classes: UpdateOneUserArgs 1`] = `
"import { Args, ArgsType, Context, Field, Float, ID, Info, InputType, Int, Mutation, ObjectType, Parent, Query, ResolveField, Resolver, registerEnumType } from \\"@nestjs/graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { UserUncheckedUpdateInput, UserWhereUniqueInput } from \\"../../../inputs\\";

@ArgsType()
export class UpdateOneUserArgs {
  @Field(() => UserUncheckedUpdateInput, {
    nullable: false
  })
  data!: UserUncheckedUpdateInput;

  @Field(() => UserWhereUniqueInput, {
    nullable: false
  })
  where!: UserWhereUniqueInput;
}
"
`;

exports[`crud when useUncheckedScalarInputs mode is enabled should properly generate create and update args classes: UpsertOneUserArgs 1`] = `
"import { Args, ArgsType, Context, Field, Float, ID, Info, InputType, Int, Mutation, ObjectType, Parent, Query, ResolveField, Resolver, registerEnumType } from \\"@nestjs/graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { UserUncheckedCreateInput, UserUncheckedUpdateInput, UserWhereUniqueInput } from \\"../../../inputs\\";

@ArgsType()
export class UpsertOneUserArgs {
  @Field(() => UserWhereUniqueInput, {
    nullable: false
  })
  where!: UserWhereUniqueInput;

  @Field(() => UserUncheckedCreateInput, {
    nullable: false
  })
  create!: UserUncheckedCreateInput;

  @Field(() => UserUncheckedUpdateInput, {
    nullable: false
  })
  update!: UserUncheckedUpdateInput;
}
"
`;
