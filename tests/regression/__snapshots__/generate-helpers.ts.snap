// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`helpers should properly emit helpers file: helpers 1`] = `
"import type { GraphQLResolveInfo } from \\"graphql\\";
import graphqlFields from \\"graphql-fields\\";
import * as DataLoader from \\"dataloader\\";

export function transformInfoIntoPrismaArgs(info: GraphQLResolveInfo, modelName?: string, collectionName?: string, prismaMethod?: string, isResolveField?: boolean): Record<string, any> {
  const fields: Record<string, any> = graphqlFields(
    // suppress GraphQLResolveInfo types issue
    info as any,
    {},
    {
      excludedFields: ['__typename'],
      processArguments: true,
    }
  );
  return transformFields(fields, modelName, collectionName, prismaMethod, isResolveField);
}

function transformFields(fields: Record<string, any>, modelName?: string, collectionName?: string, prismaMethod?: string, isResolveField?: boolean): Record<string, any> {
  return Object.fromEntries(
    Object.entries(fields)
      .map<[string, any]>(([key, value]) => {
        if (Object.keys(value).length === 0) {
          return [key, true];
        }
        if (\\"__arguments\\" in value) {
          return [key, Object.fromEntries(
            value.__arguments.map((argument: object) => {
              const [[key, { value }]] = Object.entries(argument);
              return [key, value];
            })
          )];
        }
        return [key, transformFields(value, modelName, collectionName, prismaMethod, isResolveField)];
      }),
  );
}

export function getPrismaFromContext(context: any) {
  const prismaClient = context[\\"prisma\\"];
  if (!prismaClient) {
    throw new Error(\\"Unable to find Prisma Client in GraphQL context. Please provide it under the \`context[\\\\\\"prisma\\\\\\"]\` key.\\");
  }
  return prismaClient;
}

export function transformCountFieldIntoSelectRelationsCount(_count: object, modelName?: string, collectionName?: string, prismaMethod?: string, isResolveField?: boolean) {
  return {
    include: {
      _count: {
        select: {
          ...Object.fromEntries(
            Object.entries(_count).filter(([_, v]) => v != null)
          ),
        }
      },
    },
  }
}

export let transformArgsIntoPrismaArgs = async function <TArgs = Record<string, any>, TContext = any>(info: GraphQLResolveInfo, args: TArgs, ctx: TContext, modelName?: string, collectionName?: string, prismaMethod?: string, afterProcessEvents?: ((result: any) => Promise<any>)[], isResolveField?: boolean): Promise<TArgs> {
  return args;
};

export function setTransformArgsIntoPrismaArgs(newTransformArgsIntoPrismaArgs: typeof transformArgsIntoPrismaArgs) {
  transformArgsIntoPrismaArgs = newTransformArgsIntoPrismaArgs;
}

/**
 * Simple inline dataloader factory for type-graphql resolvers
 * Creates a dataloader per request context
 */
export function InlineLoader<ID, Type>(
  createLoader: (ctx: any) => DataLoader<ID, Type>,
  _target: any,
  _propertyKey: string,
  parameterIndex: number
) {
  // This is a parameter decorator that creates dataloaders
  // The actual loader creation happens at runtime in the resolver
}

/**
 * Helper to get or create a dataloader from context
 */
export function getOrCreateLoader<ID, Type>(
  ctx: any,
  loaderKey: string,
  createLoader: () => DataLoader<ID, Type>
): DataLoader<ID, Type> {
  if (!ctx._dataloaders) {
    ctx._dataloaders = new Map();
  }
  if (!ctx._dataloaders.has(loaderKey)) {
    ctx._dataloaders.set(loaderKey, createLoader());
  }
  return ctx._dataloaders.get(loaderKey);
}






"
`;

exports[`helpers when contextPrismaKey generator option is set should properly generate \`getPrismaFromContext\`: helpers 1`] = `
"import type { GraphQLResolveInfo } from \\"graphql\\";
import graphqlFields from \\"graphql-fields\\";
import * as DataLoader from \\"dataloader\\";

export function transformInfoIntoPrismaArgs(info: GraphQLResolveInfo, modelName?: string, collectionName?: string, prismaMethod?: string, isResolveField?: boolean): Record<string, any> {
  const fields: Record<string, any> = graphqlFields(
    // suppress GraphQLResolveInfo types issue
    info as any,
    {},
    {
      excludedFields: ['__typename'],
      processArguments: true,
    }
  );
  return transformFields(fields, modelName, collectionName, prismaMethod, isResolveField);
}

function transformFields(fields: Record<string, any>, modelName?: string, collectionName?: string, prismaMethod?: string, isResolveField?: boolean): Record<string, any> {
  return Object.fromEntries(
    Object.entries(fields)
      .map<[string, any]>(([key, value]) => {
        if (Object.keys(value).length === 0) {
          return [key, true];
        }
        if (\\"__arguments\\" in value) {
          return [key, Object.fromEntries(
            value.__arguments.map((argument: object) => {
              const [[key, { value }]] = Object.entries(argument);
              return [key, value];
            })
          )];
        }
        return [key, transformFields(value, modelName, collectionName, prismaMethod, isResolveField)];
      }),
  );
}

export function getPrismaFromContext(context: any) {
  const prismaClient = context[\\"samplePrisma\\"];
  if (!prismaClient) {
    throw new Error(\\"Unable to find Prisma Client in GraphQL context. Please provide it under the \`context[\\\\\\"samplePrisma\\\\\\"]\` key.\\");
  }
  return prismaClient;
}

export function transformCountFieldIntoSelectRelationsCount(_count: object, modelName?: string, collectionName?: string, prismaMethod?: string, isResolveField?: boolean) {
  return {
    include: {
      _count: {
        select: {
          ...Object.fromEntries(
            Object.entries(_count).filter(([_, v]) => v != null)
          ),
        }
      },
    },
  }
}

export let transformArgsIntoPrismaArgs = async function <TArgs = Record<string, any>, TContext = any>(info: GraphQLResolveInfo, args: TArgs, ctx: TContext, modelName?: string, collectionName?: string, prismaMethod?: string, afterProcessEvents?: ((result: any) => Promise<any>)[], isResolveField?: boolean): Promise<TArgs> {
  return args;
};

export function setTransformArgsIntoPrismaArgs(newTransformArgsIntoPrismaArgs: typeof transformArgsIntoPrismaArgs) {
  transformArgsIntoPrismaArgs = newTransformArgsIntoPrismaArgs;
}

/**
 * Simple inline dataloader factory for type-graphql resolvers
 * Creates a dataloader per request context
 */
export function InlineLoader<ID, Type>(
  createLoader: (ctx: any) => DataLoader<ID, Type>,
  _target: any,
  _propertyKey: string,
  parameterIndex: number
) {
  // This is a parameter decorator that creates dataloaders
  // The actual loader creation happens at runtime in the resolver
}

/**
 * Helper to get or create a dataloader from context
 */
export function getOrCreateLoader<ID, Type>(
  ctx: any,
  loaderKey: string,
  createLoader: () => DataLoader<ID, Type>
): DataLoader<ID, Type> {
  if (!ctx._dataloaders) {
    ctx._dataloaders = new Map();
  }
  if (!ctx._dataloaders.has(loaderKey)) {
    ctx._dataloaders.set(loaderKey, createLoader());
  }
  return ctx._dataloaders.get(loaderKey);
}






"
`;
