// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`inputs should generate proper ScalarWhereWithAggregatesInput for model: SampleScalarWhereWithAggregatesInput 1`] = `
"import { Args, ArgsType, Context, Field, Float, ID, Info, InputType, Int, Mutation, ObjectType, Parent, Query, ResolveField, Resolver, registerEnumType } from \\"@nestjs/graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { Prisma } from \\"../../../../helpers/prisma-client-mock\\";
import { DecimalJSScalar } from \\"../../scalars\\";
import { BoolWithAggregatesFilter, DateTimeWithAggregatesFilter, FloatWithAggregatesFilter, IntWithAggregatesFilter, JsonWithAggregatesFilter, StringWithAggregatesFilter } from \\"../inputs\\";

@InputType(\\"SampleScalarWhereWithAggregatesInput\\", {})
export class SampleScalarWhereWithAggregatesInput {
  @Field(() => [SampleScalarWhereWithAggregatesInput], {
    nullable: true
  })
  AND?: SampleScalarWhereWithAggregatesInput[] | undefined;

  @Field(() => [SampleScalarWhereWithAggregatesInput], {
    nullable: true
  })
  OR?: SampleScalarWhereWithAggregatesInput[] | undefined;

  @Field(() => [SampleScalarWhereWithAggregatesInput], {
    nullable: true
  })
  NOT?: SampleScalarWhereWithAggregatesInput[] | undefined;

  @Field(() => IntWithAggregatesFilter, {
    nullable: true
  })
  idField?: IntWithAggregatesFilter | undefined;

  @Field(() => StringWithAggregatesFilter, {
    nullable: true
  })
  stringField?: StringWithAggregatesFilter | undefined;

  @Field(() => FloatWithAggregatesFilter, {
    nullable: true
  })
  floatField?: FloatWithAggregatesFilter | undefined;

  @Field(() => IntWithAggregatesFilter, {
    nullable: true
  })
  intField?: IntWithAggregatesFilter | undefined;

  @Field(() => BoolWithAggregatesFilter, {
    nullable: true
  })
  booleanField?: BoolWithAggregatesFilter | undefined;

  @Field(() => DateTimeWithAggregatesFilter, {
    nullable: true
  })
  dateField?: DateTimeWithAggregatesFilter | undefined;

  @Field(() => JsonWithAggregatesFilter, {
    nullable: true
  })
  jsonField?: JsonWithAggregatesFilter | undefined;
}
"
`;

exports[`inputs should generate proper WithAggregatesFilter for scalars: BoolWithAggregatesFilter 1`] = `
"import { Args, ArgsType, Context, Field, Float, ID, Info, InputType, Int, Mutation, ObjectType, Parent, Query, ResolveField, Resolver, registerEnumType } from \\"@nestjs/graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { Prisma } from \\"../../../../helpers/prisma-client-mock\\";
import { DecimalJSScalar } from \\"../../scalars\\";
import { NestedBoolFilter, NestedBoolWithAggregatesFilter, NestedIntFilter } from \\"../inputs\\";

@InputType(\\"BoolWithAggregatesFilter\\", {})
export class BoolWithAggregatesFilter {
  @Field(() => Boolean, {
    nullable: true
  })
  equals?: boolean | undefined;

  @Field(() => NestedBoolWithAggregatesFilter, {
    nullable: true
  })
  not?: NestedBoolWithAggregatesFilter | undefined;

  @Field(() => NestedIntFilter, {
    nullable: true
  })
  _count?: NestedIntFilter | undefined;

  @Field(() => NestedBoolFilter, {
    nullable: true
  })
  _min?: NestedBoolFilter | undefined;

  @Field(() => NestedBoolFilter, {
    nullable: true
  })
  _max?: NestedBoolFilter | undefined;
}
"
`;

exports[`inputs should generate proper WithAggregatesFilter for scalars: DateTimeWithAggregatesFilter 1`] = `
"import { Args, ArgsType, Context, Field, Float, ID, Info, InputType, Int, Mutation, ObjectType, Parent, Query, ResolveField, Resolver, registerEnumType } from \\"@nestjs/graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { Prisma } from \\"../../../../helpers/prisma-client-mock\\";
import { DecimalJSScalar } from \\"../../scalars\\";
import { NestedDateTimeFilter, NestedDateTimeWithAggregatesFilter, NestedIntFilter } from \\"../inputs\\";

@InputType(\\"DateTimeWithAggregatesFilter\\", {})
export class DateTimeWithAggregatesFilter {
  @Field(() => Date, {
    nullable: true
  })
  equals?: Date | undefined;

  @Field(() => [Date], {
    nullable: true
  })
  in?: Date[] | undefined;

  @Field(() => [Date], {
    nullable: true
  })
  notIn?: Date[] | undefined;

  @Field(() => Date, {
    nullable: true
  })
  lt?: Date | undefined;

  @Field(() => Date, {
    nullable: true
  })
  lte?: Date | undefined;

  @Field(() => Date, {
    nullable: true
  })
  gt?: Date | undefined;

  @Field(() => Date, {
    nullable: true
  })
  gte?: Date | undefined;

  @Field(() => NestedDateTimeWithAggregatesFilter, {
    nullable: true
  })
  not?: NestedDateTimeWithAggregatesFilter | undefined;

  @Field(() => NestedIntFilter, {
    nullable: true
  })
  _count?: NestedIntFilter | undefined;

  @Field(() => NestedDateTimeFilter, {
    nullable: true
  })
  _min?: NestedDateTimeFilter | undefined;

  @Field(() => NestedDateTimeFilter, {
    nullable: true
  })
  _max?: NestedDateTimeFilter | undefined;
}
"
`;

exports[`inputs should generate proper WithAggregatesFilter for scalars: FloatWithAggregatesFilter 1`] = `
"import { Args, ArgsType, Context, Field, Float, ID, Info, InputType, Int, Mutation, ObjectType, Parent, Query, ResolveField, Resolver, registerEnumType } from \\"@nestjs/graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { Prisma } from \\"../../../../helpers/prisma-client-mock\\";
import { DecimalJSScalar } from \\"../../scalars\\";
import { NestedFloatFilter, NestedFloatWithAggregatesFilter, NestedIntFilter } from \\"../inputs\\";

@InputType(\\"FloatWithAggregatesFilter\\", {})
export class FloatWithAggregatesFilter {
  @Field(() => Float, {
    nullable: true
  })
  equals?: number | undefined;

  @Field(() => [Float], {
    nullable: true
  })
  in?: number[] | undefined;

  @Field(() => [Float], {
    nullable: true
  })
  notIn?: number[] | undefined;

  @Field(() => Float, {
    nullable: true
  })
  lt?: number | undefined;

  @Field(() => Float, {
    nullable: true
  })
  lte?: number | undefined;

  @Field(() => Float, {
    nullable: true
  })
  gt?: number | undefined;

  @Field(() => Float, {
    nullable: true
  })
  gte?: number | undefined;

  @Field(() => NestedFloatWithAggregatesFilter, {
    nullable: true
  })
  not?: NestedFloatWithAggregatesFilter | undefined;

  @Field(() => NestedIntFilter, {
    nullable: true
  })
  _count?: NestedIntFilter | undefined;

  @Field(() => NestedFloatFilter, {
    nullable: true
  })
  _avg?: NestedFloatFilter | undefined;

  @Field(() => NestedFloatFilter, {
    nullable: true
  })
  _sum?: NestedFloatFilter | undefined;

  @Field(() => NestedFloatFilter, {
    nullable: true
  })
  _min?: NestedFloatFilter | undefined;

  @Field(() => NestedFloatFilter, {
    nullable: true
  })
  _max?: NestedFloatFilter | undefined;
}
"
`;

exports[`inputs should generate proper WithAggregatesFilter for scalars: IntWithAggregatesFilter 1`] = `
"import { Args, ArgsType, Context, Field, Float, ID, Info, InputType, Int, Mutation, ObjectType, Parent, Query, ResolveField, Resolver, registerEnumType } from \\"@nestjs/graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { Prisma } from \\"../../../../helpers/prisma-client-mock\\";
import { DecimalJSScalar } from \\"../../scalars\\";
import { NestedFloatFilter, NestedIntFilter, NestedIntWithAggregatesFilter } from \\"../inputs\\";

@InputType(\\"IntWithAggregatesFilter\\", {})
export class IntWithAggregatesFilter {
  @Field(() => Int, {
    nullable: true
  })
  equals?: number | undefined;

  @Field(() => [Int], {
    nullable: true
  })
  in?: number[] | undefined;

  @Field(() => [Int], {
    nullable: true
  })
  notIn?: number[] | undefined;

  @Field(() => Int, {
    nullable: true
  })
  lt?: number | undefined;

  @Field(() => Int, {
    nullable: true
  })
  lte?: number | undefined;

  @Field(() => Int, {
    nullable: true
  })
  gt?: number | undefined;

  @Field(() => Int, {
    nullable: true
  })
  gte?: number | undefined;

  @Field(() => NestedIntWithAggregatesFilter, {
    nullable: true
  })
  not?: NestedIntWithAggregatesFilter | undefined;

  @Field(() => NestedIntFilter, {
    nullable: true
  })
  _count?: NestedIntFilter | undefined;

  @Field(() => NestedFloatFilter, {
    nullable: true
  })
  _avg?: NestedFloatFilter | undefined;

  @Field(() => NestedIntFilter, {
    nullable: true
  })
  _sum?: NestedIntFilter | undefined;

  @Field(() => NestedIntFilter, {
    nullable: true
  })
  _min?: NestedIntFilter | undefined;

  @Field(() => NestedIntFilter, {
    nullable: true
  })
  _max?: NestedIntFilter | undefined;
}
"
`;

exports[`inputs should generate proper WithAggregatesFilter for scalars: JsonWithAggregatesFilter 1`] = `
"import { Args, ArgsType, Context, Field, Float, ID, Info, InputType, Int, Mutation, ObjectType, Parent, Query, ResolveField, Resolver, registerEnumType } from \\"@nestjs/graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { Prisma } from \\"../../../../helpers/prisma-client-mock\\";
import { DecimalJSScalar } from \\"../../scalars\\";
import { NestedIntFilter, NestedJsonFilter } from \\"../inputs\\";
import { QueryMode } from \\"../../enums/QueryMode\\";

@InputType(\\"JsonWithAggregatesFilter\\", {})
export class JsonWithAggregatesFilter {
  @Field(() => GraphQLScalars.JSONResolver, {
    nullable: true
  })
  equals?: Prisma.InputJsonValue | undefined;

  @Field(() => [String], {
    nullable: true
  })
  path?: string[] | undefined;

  @Field(() => QueryMode, {
    nullable: true
  })
  mode?: \\"default\\" | \\"insensitive\\" | undefined;

  @Field(() => String, {
    nullable: true
  })
  string_contains?: string | undefined;

  @Field(() => String, {
    nullable: true
  })
  string_starts_with?: string | undefined;

  @Field(() => String, {
    nullable: true
  })
  string_ends_with?: string | undefined;

  @Field(() => GraphQLScalars.JSONResolver, {
    nullable: true
  })
  array_starts_with?: Prisma.InputJsonValue | undefined;

  @Field(() => GraphQLScalars.JSONResolver, {
    nullable: true
  })
  array_ends_with?: Prisma.InputJsonValue | undefined;

  @Field(() => GraphQLScalars.JSONResolver, {
    nullable: true
  })
  array_contains?: Prisma.InputJsonValue | undefined;

  @Field(() => GraphQLScalars.JSONResolver, {
    nullable: true
  })
  lt?: Prisma.InputJsonValue | undefined;

  @Field(() => GraphQLScalars.JSONResolver, {
    nullable: true
  })
  lte?: Prisma.InputJsonValue | undefined;

  @Field(() => GraphQLScalars.JSONResolver, {
    nullable: true
  })
  gt?: Prisma.InputJsonValue | undefined;

  @Field(() => GraphQLScalars.JSONResolver, {
    nullable: true
  })
  gte?: Prisma.InputJsonValue | undefined;

  @Field(() => GraphQLScalars.JSONResolver, {
    nullable: true
  })
  not?: Prisma.InputJsonValue | undefined;

  @Field(() => NestedIntFilter, {
    nullable: true
  })
  _count?: NestedIntFilter | undefined;

  @Field(() => NestedJsonFilter, {
    nullable: true
  })
  _min?: NestedJsonFilter | undefined;

  @Field(() => NestedJsonFilter, {
    nullable: true
  })
  _max?: NestedJsonFilter | undefined;
}
"
`;

exports[`inputs should generate proper WithAggregatesFilter for scalars: StringWithAggregatesFilter 1`] = `
"import { Args, ArgsType, Context, Field, Float, ID, Info, InputType, Int, Mutation, ObjectType, Parent, Query, ResolveField, Resolver, registerEnumType } from \\"@nestjs/graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { Prisma } from \\"../../../../helpers/prisma-client-mock\\";
import { DecimalJSScalar } from \\"../../scalars\\";
import { NestedIntFilter, NestedStringFilter, NestedStringWithAggregatesFilter } from \\"../inputs\\";
import { QueryMode } from \\"../../enums/QueryMode\\";

@InputType(\\"StringWithAggregatesFilter\\", {})
export class StringWithAggregatesFilter {
  @Field(() => String, {
    nullable: true
  })
  equals?: string | undefined;

  @Field(() => [String], {
    nullable: true
  })
  in?: string[] | undefined;

  @Field(() => [String], {
    nullable: true
  })
  notIn?: string[] | undefined;

  @Field(() => String, {
    nullable: true
  })
  lt?: string | undefined;

  @Field(() => String, {
    nullable: true
  })
  lte?: string | undefined;

  @Field(() => String, {
    nullable: true
  })
  gt?: string | undefined;

  @Field(() => String, {
    nullable: true
  })
  gte?: string | undefined;

  @Field(() => String, {
    nullable: true
  })
  contains?: string | undefined;

  @Field(() => String, {
    nullable: true
  })
  startsWith?: string | undefined;

  @Field(() => String, {
    nullable: true
  })
  endsWith?: string | undefined;

  @Field(() => QueryMode, {
    nullable: true
  })
  mode?: \\"default\\" | \\"insensitive\\" | undefined;

  @Field(() => NestedStringWithAggregatesFilter, {
    nullable: true
  })
  not?: NestedStringWithAggregatesFilter | undefined;

  @Field(() => NestedIntFilter, {
    nullable: true
  })
  _count?: NestedIntFilter | undefined;

  @Field(() => NestedStringFilter, {
    nullable: true
  })
  _min?: NestedStringFilter | undefined;

  @Field(() => NestedStringFilter, {
    nullable: true
  })
  _max?: NestedStringFilter | undefined;
}
"
`;

exports[`inputs should generate proper WithAggregatesFilter for scalars: index 1`] = `
"export * from \\"./BoolFieldUpdateOperationsInput\\";
export * from \\"./BoolFilter\\";
export * from \\"./BoolWithAggregatesFilter\\";
export * from \\"./DateTimeFieldUpdateOperationsInput\\";
export * from \\"./DateTimeFilter\\";
export * from \\"./DateTimeWithAggregatesFilter\\";
export * from \\"./FloatFieldUpdateOperationsInput\\";
export * from \\"./FloatFilter\\";
export * from \\"./FloatWithAggregatesFilter\\";
export * from \\"./IntFieldUpdateOperationsInput\\";
export * from \\"./IntFilter\\";
export * from \\"./IntWithAggregatesFilter\\";
export * from \\"./JsonFilter\\";
export * from \\"./JsonWithAggregatesFilter\\";
export * from \\"./NestedBoolFilter\\";
export * from \\"./NestedBoolWithAggregatesFilter\\";
export * from \\"./NestedDateTimeFilter\\";
export * from \\"./NestedDateTimeWithAggregatesFilter\\";
export * from \\"./NestedFloatFilter\\";
export * from \\"./NestedFloatWithAggregatesFilter\\";
export * from \\"./NestedIntFilter\\";
export * from \\"./NestedIntWithAggregatesFilter\\";
export * from \\"./NestedJsonFilter\\";
export * from \\"./NestedStringFilter\\";
export * from \\"./NestedStringWithAggregatesFilter\\";
export * from \\"./SampleAvgOrderByAggregateInput\\";
export * from \\"./SampleCountOrderByAggregateInput\\";
export * from \\"./SampleCreateInput\\";
export * from \\"./SampleCreateManyInput\\";
export * from \\"./SampleMaxOrderByAggregateInput\\";
export * from \\"./SampleMinOrderByAggregateInput\\";
export * from \\"./SampleOrderByWithAggregationInput\\";
export * from \\"./SampleOrderByWithRelationInput\\";
export * from \\"./SampleScalarWhereWithAggregatesInput\\";
export * from \\"./SampleSumOrderByAggregateInput\\";
export * from \\"./SampleUpdateInput\\";
export * from \\"./SampleUpdateManyMutationInput\\";
export * from \\"./SampleWhereInput\\";
export * from \\"./SampleWhereUniqueInput\\";
export * from \\"./StringFieldUpdateOperationsInput\\";
export * from \\"./StringFilter\\";
export * from \\"./StringWithAggregatesFilter\\";
"
`;

exports[`inputs should properly generate input type class for filtering by enums values: EnumColorFilter 1`] = `
"import { Args, ArgsType, Context, Field, Float, ID, Info, InputType, Int, Mutation, ObjectType, Parent, Query, ResolveField, Resolver, registerEnumType } from \\"@nestjs/graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { Prisma } from \\"../../../../helpers/prisma-client-mock\\";
import { DecimalJSScalar } from \\"../../scalars\\";
import { NestedEnumColorFilter } from \\"../inputs\\";
import { Color } from \\"../../enums/Color\\";

@InputType(\\"EnumColorFilter\\", {})
export class EnumColorFilter {
  @Field(() => Color, {
    nullable: true
  })
  equals?: \\"RED\\" | \\"GREEN\\" | \\"BLUE\\" | undefined;

  @Field(() => [Color], {
    nullable: true
  })
  in?: Array<\\"RED\\" | \\"GREEN\\" | \\"BLUE\\"> | undefined;

  @Field(() => [Color], {
    nullable: true
  })
  notIn?: Array<\\"RED\\" | \\"GREEN\\" | \\"BLUE\\"> | undefined;

  @Field(() => NestedEnumColorFilter, {
    nullable: true
  })
  not?: NestedEnumColorFilter | undefined;
}
"
`;

exports[`inputs should properly generate input type class for filtering by enums values: NestedEnumColorFilter 1`] = `
"import { Args, ArgsType, Context, Field, Float, ID, Info, InputType, Int, Mutation, ObjectType, Parent, Query, ResolveField, Resolver, registerEnumType } from \\"@nestjs/graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { Prisma } from \\"../../../../helpers/prisma-client-mock\\";
import { DecimalJSScalar } from \\"../../scalars\\";
import { Color } from \\"../../enums/Color\\";

@InputType(\\"NestedEnumColorFilter\\", {})
export class NestedEnumColorFilter {
  @Field(() => Color, {
    nullable: true
  })
  equals?: \\"RED\\" | \\"GREEN\\" | \\"BLUE\\" | undefined;

  @Field(() => [Color], {
    nullable: true
  })
  in?: Array<\\"RED\\" | \\"GREEN\\" | \\"BLUE\\"> | undefined;

  @Field(() => [Color], {
    nullable: true
  })
  notIn?: Array<\\"RED\\" | \\"GREEN\\" | \\"BLUE\\"> | undefined;

  @Field(() => NestedEnumColorFilter, {
    nullable: true
  })
  not?: NestedEnumColorFilter | undefined;
}
"
`;

exports[`inputs should properly generate input type class for filtering by enums values: index 1`] = `
"export * from \\"./EnumColorFieldUpdateOperationsInput\\";
export * from \\"./EnumColorFilter\\";
export * from \\"./EnumColorWithAggregatesFilter\\";
export * from \\"./IntFieldUpdateOperationsInput\\";
export * from \\"./IntFilter\\";
export * from \\"./IntWithAggregatesFilter\\";
export * from \\"./NestedEnumColorFilter\\";
export * from \\"./NestedEnumColorWithAggregatesFilter\\";
export * from \\"./NestedFloatFilter\\";
export * from \\"./NestedIntFilter\\";
export * from \\"./NestedIntWithAggregatesFilter\\";
export * from \\"./SampleModelAvgOrderByAggregateInput\\";
export * from \\"./SampleModelCountOrderByAggregateInput\\";
export * from \\"./SampleModelCreateInput\\";
export * from \\"./SampleModelCreateManyInput\\";
export * from \\"./SampleModelMaxOrderByAggregateInput\\";
export * from \\"./SampleModelMinOrderByAggregateInput\\";
export * from \\"./SampleModelOrderByWithAggregationInput\\";
export * from \\"./SampleModelOrderByWithRelationInput\\";
export * from \\"./SampleModelScalarWhereWithAggregatesInput\\";
export * from \\"./SampleModelSumOrderByAggregateInput\\";
export * from \\"./SampleModelUpdateInput\\";
export * from \\"./SampleModelUpdateManyMutationInput\\";
export * from \\"./SampleModelWhereInput\\";
export * from \\"./SampleModelWhereUniqueInput\\";
"
`;

exports[`inputs should properly generate input type classes for connectOrCreate: UserCreateNestedOneWithoutPostsFieldInput 1`] = `
"import { Args, ArgsType, Context, Field, Float, ID, Info, InputType, Int, Mutation, ObjectType, Parent, Query, ResolveField, Resolver, registerEnumType } from \\"@nestjs/graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { Prisma } from \\"../../../../helpers/prisma-client-mock\\";
import { DecimalJSScalar } from \\"../../scalars\\";
import { UserCreateOrConnectWithoutPostsFieldInput, UserCreateWithoutPostsFieldInput, UserWhereUniqueInput } from \\"../inputs\\";

@InputType(\\"UserCreateNestedOneWithoutPostsFieldInput\\", {})
export class UserCreateNestedOneWithoutPostsFieldInput {
  @Field(() => UserCreateWithoutPostsFieldInput, {
    nullable: true
  })
  create?: UserCreateWithoutPostsFieldInput | undefined;

  @Field(() => UserCreateOrConnectWithoutPostsFieldInput, {
    nullable: true
  })
  connectOrCreate?: UserCreateOrConnectWithoutPostsFieldInput | undefined;

  @Field(() => UserWhereUniqueInput, {
    nullable: true
  })
  connect?: UserWhereUniqueInput | undefined;
}
"
`;

exports[`inputs should properly generate input type classes for connectOrCreate: UserCreateOrConnectWithoutPostsFieldInput 1`] = `
"import { Args, ArgsType, Context, Field, Float, ID, Info, InputType, Int, Mutation, ObjectType, Parent, Query, ResolveField, Resolver, registerEnumType } from \\"@nestjs/graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { Prisma } from \\"../../../../helpers/prisma-client-mock\\";
import { DecimalJSScalar } from \\"../../scalars\\";
import { UserCreateWithoutPostsFieldInput, UserWhereUniqueInput } from \\"../inputs\\";

@InputType(\\"UserCreateOrConnectWithoutPostsFieldInput\\", {})
export class UserCreateOrConnectWithoutPostsFieldInput {
  @Field(() => UserWhereUniqueInput, {
    nullable: false
  })
  where!: UserWhereUniqueInput;

  @Field(() => UserCreateWithoutPostsFieldInput, {
    nullable: false
  })
  create!: UserCreateWithoutPostsFieldInput;
}
"
`;

exports[`inputs should properly generate input type classes for connectOrCreate: UserUpdateOneRequiredWithoutPostsFieldNestedInput 1`] = `
"import { Args, ArgsType, Context, Field, Float, ID, Info, InputType, Int, Mutation, ObjectType, Parent, Query, ResolveField, Resolver, registerEnumType } from \\"@nestjs/graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { Prisma } from \\"../../../../helpers/prisma-client-mock\\";
import { DecimalJSScalar } from \\"../../scalars\\";
import { UserCreateOrConnectWithoutPostsFieldInput, UserCreateWithoutPostsFieldInput, UserUpdateToOneWithWhereWithoutPostsFieldInput, UserUpsertWithoutPostsFieldInput, UserWhereUniqueInput } from \\"../inputs\\";

@InputType(\\"UserUpdateOneRequiredWithoutPostsFieldNestedInput\\", {})
export class UserUpdateOneRequiredWithoutPostsFieldNestedInput {
  @Field(() => UserCreateWithoutPostsFieldInput, {
    nullable: true
  })
  create?: UserCreateWithoutPostsFieldInput | undefined;

  @Field(() => UserCreateOrConnectWithoutPostsFieldInput, {
    nullable: true
  })
  connectOrCreate?: UserCreateOrConnectWithoutPostsFieldInput | undefined;

  @Field(() => UserUpsertWithoutPostsFieldInput, {
    nullable: true
  })
  upsert?: UserUpsertWithoutPostsFieldInput | undefined;

  @Field(() => UserWhereUniqueInput, {
    nullable: true
  })
  connect?: UserWhereUniqueInput | undefined;

  @Field(() => UserUpdateToOneWithWhereWithoutPostsFieldInput, {
    nullable: true
  })
  update?: UserUpdateToOneWithWhereWithoutPostsFieldInput | undefined;
}
"
`;

exports[`inputs should properly generate input type classes for creating models and scalar fields: SampleModelCreateInput 1`] = `
"import { Args, ArgsType, Context, Field, Float, ID, Info, InputType, Int, Mutation, ObjectType, Parent, Query, ResolveField, Resolver, registerEnumType } from \\"@nestjs/graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { Prisma } from \\"../../../../helpers/prisma-client-mock\\";
import { DecimalJSScalar } from \\"../../scalars\\";
import { SampleModelCreateintArrayFieldInput, SampleModelCreatestringArrayFieldInput } from \\"../inputs\\";
import { Color } from \\"../../enums/Color\\";

@InputType(\\"SampleModelCreateInput\\", {})
export class SampleModelCreateInput {
  @Field(() => String, {
    nullable: false
  })
  stringField!: string;

  @Field(() => String, {
    nullable: true
  })
  optionalStringField?: string | undefined;

  @Field(() => Int, {
    nullable: false
  })
  intField!: number;

  @Field(() => Int, {
    nullable: true
  })
  optionalIntField?: number | undefined;

  @Field(() => Float, {
    nullable: false
  })
  floatField!: number;

  @Field(() => Float, {
    nullable: true
  })
  optionalFloatField?: number | undefined;

  @Field(() => Boolean, {
    nullable: false
  })
  booleanField!: boolean;

  @Field(() => Boolean, {
    nullable: true
  })
  optionalBooleanField?: boolean | undefined;

  @Field(() => Date, {
    nullable: false
  })
  dateField!: Date;

  @Field(() => Date, {
    nullable: true
  })
  optionalDateField?: Date | undefined;

  @Field(() => GraphQLScalars.JSONResolver, {
    nullable: false
  })
  jsonField!: Prisma.InputJsonValue;

  @Field(() => GraphQLScalars.JSONResolver, {
    nullable: true
  })
  optionalJsonField?: Prisma.InputJsonValue | undefined;

  @Field(() => Color, {
    nullable: false
  })
  enumField!: \\"RED\\" | \\"GREEN\\" | \\"BLUE\\";

  @Field(() => Color, {
    nullable: true
  })
  optionalEnumField?: \\"RED\\" | \\"GREEN\\" | \\"BLUE\\" | undefined;

  @Field(() => SampleModelCreateintArrayFieldInput, {
    nullable: true
  })
  intArrayField?: SampleModelCreateintArrayFieldInput | undefined;

  @Field(() => SampleModelCreatestringArrayFieldInput, {
    nullable: true
  })
  stringArrayField?: SampleModelCreatestringArrayFieldInput | undefined;
}
"
`;

exports[`inputs should properly generate input type classes for creating models and scalar fields: SampleModelCreateManyInput 1`] = `
"import { Args, ArgsType, Context, Field, Float, ID, Info, InputType, Int, Mutation, ObjectType, Parent, Query, ResolveField, Resolver, registerEnumType } from \\"@nestjs/graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { Prisma } from \\"../../../../helpers/prisma-client-mock\\";
import { DecimalJSScalar } from \\"../../scalars\\";
import { SampleModelCreateintArrayFieldInput, SampleModelCreatestringArrayFieldInput } from \\"../inputs\\";
import { Color } from \\"../../enums/Color\\";

@InputType(\\"SampleModelCreateManyInput\\", {})
export class SampleModelCreateManyInput {
  @Field(() => Int, {
    nullable: true
  })
  intIdField?: number | undefined;

  @Field(() => String, {
    nullable: false
  })
  stringField!: string;

  @Field(() => String, {
    nullable: true
  })
  optionalStringField?: string | undefined;

  @Field(() => Int, {
    nullable: false
  })
  intField!: number;

  @Field(() => Int, {
    nullable: true
  })
  optionalIntField?: number | undefined;

  @Field(() => Float, {
    nullable: false
  })
  floatField!: number;

  @Field(() => Float, {
    nullable: true
  })
  optionalFloatField?: number | undefined;

  @Field(() => Boolean, {
    nullable: false
  })
  booleanField!: boolean;

  @Field(() => Boolean, {
    nullable: true
  })
  optionalBooleanField?: boolean | undefined;

  @Field(() => Date, {
    nullable: false
  })
  dateField!: Date;

  @Field(() => Date, {
    nullable: true
  })
  optionalDateField?: Date | undefined;

  @Field(() => GraphQLScalars.JSONResolver, {
    nullable: false
  })
  jsonField!: Prisma.InputJsonValue;

  @Field(() => GraphQLScalars.JSONResolver, {
    nullable: true
  })
  optionalJsonField?: Prisma.InputJsonValue | undefined;

  @Field(() => Color, {
    nullable: false
  })
  enumField!: \\"RED\\" | \\"GREEN\\" | \\"BLUE\\";

  @Field(() => Color, {
    nullable: true
  })
  optionalEnumField?: \\"RED\\" | \\"GREEN\\" | \\"BLUE\\" | undefined;

  @Field(() => SampleModelCreateintArrayFieldInput, {
    nullable: true
  })
  intArrayField?: SampleModelCreateintArrayFieldInput | undefined;

  @Field(() => SampleModelCreatestringArrayFieldInput, {
    nullable: true
  })
  stringArrayField?: SampleModelCreatestringArrayFieldInput | undefined;
}
"
`;

exports[`inputs should properly generate input type classes for creating models and scalar fields: SampleModelCreateintArrayFieldInput 1`] = `
"import { Args, ArgsType, Context, Field, Float, ID, Info, InputType, Int, Mutation, ObjectType, Parent, Query, ResolveField, Resolver, registerEnumType } from \\"@nestjs/graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { Prisma } from \\"../../../../helpers/prisma-client-mock\\";
import { DecimalJSScalar } from \\"../../scalars\\";

@InputType(\\"SampleModelCreateintArrayFieldInput\\", {})
export class SampleModelCreateintArrayFieldInput {
  @Field(() => [Int], {
    nullable: false
  })
  set!: number[];
}
"
`;

exports[`inputs should properly generate input type classes for creating models and scalar fields: SampleModelCreatestringArrayFieldInput 1`] = `
"import { Args, ArgsType, Context, Field, Float, ID, Info, InputType, Int, Mutation, ObjectType, Parent, Query, ResolveField, Resolver, registerEnumType } from \\"@nestjs/graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { Prisma } from \\"../../../../helpers/prisma-client-mock\\";
import { DecimalJSScalar } from \\"../../scalars\\";

@InputType(\\"SampleModelCreatestringArrayFieldInput\\", {})
export class SampleModelCreatestringArrayFieldInput {
  @Field(() => [String], {
    nullable: false
  })
  set!: string[];
}
"
`;

exports[`inputs should properly generate input type classes for creating models and scalar fields: index 1`] = `
"export * from \\"./BoolFieldUpdateOperationsInput\\";
export * from \\"./BoolFilter\\";
export * from \\"./BoolNullableFilter\\";
export * from \\"./BoolNullableWithAggregatesFilter\\";
export * from \\"./BoolWithAggregatesFilter\\";
export * from \\"./DateTimeFieldUpdateOperationsInput\\";
export * from \\"./DateTimeFilter\\";
export * from \\"./DateTimeNullableFilter\\";
export * from \\"./DateTimeNullableWithAggregatesFilter\\";
export * from \\"./DateTimeWithAggregatesFilter\\";
export * from \\"./EnumColorFieldUpdateOperationsInput\\";
export * from \\"./EnumColorFilter\\";
export * from \\"./EnumColorNullableFilter\\";
export * from \\"./EnumColorNullableWithAggregatesFilter\\";
export * from \\"./EnumColorWithAggregatesFilter\\";
export * from \\"./FloatFieldUpdateOperationsInput\\";
export * from \\"./FloatFilter\\";
export * from \\"./FloatNullableFilter\\";
export * from \\"./FloatNullableWithAggregatesFilter\\";
export * from \\"./FloatWithAggregatesFilter\\";
export * from \\"./IntFieldUpdateOperationsInput\\";
export * from \\"./IntFilter\\";
export * from \\"./IntNullableFilter\\";
export * from \\"./IntNullableListFilter\\";
export * from \\"./IntNullableWithAggregatesFilter\\";
export * from \\"./IntWithAggregatesFilter\\";
export * from \\"./JsonFilter\\";
export * from \\"./JsonNullableFilter\\";
export * from \\"./JsonNullableWithAggregatesFilter\\";
export * from \\"./JsonWithAggregatesFilter\\";
export * from \\"./NestedBoolFilter\\";
export * from \\"./NestedBoolNullableFilter\\";
export * from \\"./NestedBoolNullableWithAggregatesFilter\\";
export * from \\"./NestedBoolWithAggregatesFilter\\";
export * from \\"./NestedDateTimeFilter\\";
export * from \\"./NestedDateTimeNullableFilter\\";
export * from \\"./NestedDateTimeNullableWithAggregatesFilter\\";
export * from \\"./NestedDateTimeWithAggregatesFilter\\";
export * from \\"./NestedEnumColorFilter\\";
export * from \\"./NestedEnumColorNullableFilter\\";
export * from \\"./NestedEnumColorNullableWithAggregatesFilter\\";
export * from \\"./NestedEnumColorWithAggregatesFilter\\";
export * from \\"./NestedFloatFilter\\";
export * from \\"./NestedFloatNullableFilter\\";
export * from \\"./NestedFloatNullableWithAggregatesFilter\\";
export * from \\"./NestedFloatWithAggregatesFilter\\";
export * from \\"./NestedIntFilter\\";
export * from \\"./NestedIntNullableFilter\\";
export * from \\"./NestedIntNullableWithAggregatesFilter\\";
export * from \\"./NestedIntWithAggregatesFilter\\";
export * from \\"./NestedJsonFilter\\";
export * from \\"./NestedJsonNullableFilter\\";
export * from \\"./NestedStringFilter\\";
export * from \\"./NestedStringNullableFilter\\";
export * from \\"./NestedStringNullableWithAggregatesFilter\\";
export * from \\"./NestedStringWithAggregatesFilter\\";
export * from \\"./NullableBoolFieldUpdateOperationsInput\\";
export * from \\"./NullableDateTimeFieldUpdateOperationsInput\\";
export * from \\"./NullableEnumColorFieldUpdateOperationsInput\\";
export * from \\"./NullableFloatFieldUpdateOperationsInput\\";
export * from \\"./NullableIntFieldUpdateOperationsInput\\";
export * from \\"./NullableStringFieldUpdateOperationsInput\\";
export * from \\"./SampleModelAvgOrderByAggregateInput\\";
export * from \\"./SampleModelCountOrderByAggregateInput\\";
export * from \\"./SampleModelCreateInput\\";
export * from \\"./SampleModelCreateManyInput\\";
export * from \\"./SampleModelCreateintArrayFieldInput\\";
export * from \\"./SampleModelCreatestringArrayFieldInput\\";
export * from \\"./SampleModelMaxOrderByAggregateInput\\";
export * from \\"./SampleModelMinOrderByAggregateInput\\";
export * from \\"./SampleModelOrderByWithAggregationInput\\";
export * from \\"./SampleModelOrderByWithRelationInput\\";
export * from \\"./SampleModelScalarWhereWithAggregatesInput\\";
export * from \\"./SampleModelSumOrderByAggregateInput\\";
export * from \\"./SampleModelUpdateInput\\";
export * from \\"./SampleModelUpdateManyMutationInput\\";
export * from \\"./SampleModelUpdateintArrayFieldInput\\";
export * from \\"./SampleModelUpdatestringArrayFieldInput\\";
export * from \\"./SampleModelWhereInput\\";
export * from \\"./SampleModelWhereUniqueInput\\";
export * from \\"./SortOrderInput\\";
export * from \\"./StringFieldUpdateOperationsInput\\";
export * from \\"./StringFilter\\";
export * from \\"./StringNullableFilter\\";
export * from \\"./StringNullableListFilter\\";
export * from \\"./StringNullableWithAggregatesFilter\\";
export * from \\"./StringWithAggregatesFilter\\";
"
`;

exports[`inputs should properly generate input type classes for filtering json fields: JsonFilter 1`] = `
"import { Args, ArgsType, Context, Field, Float, ID, Info, InputType, Int, Mutation, ObjectType, Parent, Query, ResolveField, Resolver, registerEnumType } from \\"@nestjs/graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { Prisma } from \\"../../../../helpers/prisma-client-mock\\";
import { DecimalJSScalar } from \\"../../scalars\\";
import { QueryMode } from \\"../../enums/QueryMode\\";

@InputType(\\"JsonFilter\\", {})
export class JsonFilter {
  @Field(() => GraphQLScalars.JSONResolver, {
    nullable: true
  })
  equals?: Prisma.InputJsonValue | undefined;

  @Field(() => [String], {
    nullable: true
  })
  path?: string[] | undefined;

  @Field(() => QueryMode, {
    nullable: true
  })
  mode?: \\"default\\" | \\"insensitive\\" | undefined;

  @Field(() => String, {
    nullable: true
  })
  string_contains?: string | undefined;

  @Field(() => String, {
    nullable: true
  })
  string_starts_with?: string | undefined;

  @Field(() => String, {
    nullable: true
  })
  string_ends_with?: string | undefined;

  @Field(() => GraphQLScalars.JSONResolver, {
    nullable: true
  })
  array_starts_with?: Prisma.InputJsonValue | undefined;

  @Field(() => GraphQLScalars.JSONResolver, {
    nullable: true
  })
  array_ends_with?: Prisma.InputJsonValue | undefined;

  @Field(() => GraphQLScalars.JSONResolver, {
    nullable: true
  })
  array_contains?: Prisma.InputJsonValue | undefined;

  @Field(() => GraphQLScalars.JSONResolver, {
    nullable: true
  })
  lt?: Prisma.InputJsonValue | undefined;

  @Field(() => GraphQLScalars.JSONResolver, {
    nullable: true
  })
  lte?: Prisma.InputJsonValue | undefined;

  @Field(() => GraphQLScalars.JSONResolver, {
    nullable: true
  })
  gt?: Prisma.InputJsonValue | undefined;

  @Field(() => GraphQLScalars.JSONResolver, {
    nullable: true
  })
  gte?: Prisma.InputJsonValue | undefined;

  @Field(() => GraphQLScalars.JSONResolver, {
    nullable: true
  })
  not?: Prisma.InputJsonValue | undefined;
}
"
`;

exports[`inputs should properly generate input type classes for filtering json fields: JsonWithAggregatesFilter 1`] = `
"import { Args, ArgsType, Context, Field, Float, ID, Info, InputType, Int, Mutation, ObjectType, Parent, Query, ResolveField, Resolver, registerEnumType } from \\"@nestjs/graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { Prisma } from \\"../../../../helpers/prisma-client-mock\\";
import { DecimalJSScalar } from \\"../../scalars\\";
import { NestedIntFilter, NestedJsonFilter } from \\"../inputs\\";
import { QueryMode } from \\"../../enums/QueryMode\\";

@InputType(\\"JsonWithAggregatesFilter\\", {})
export class JsonWithAggregatesFilter {
  @Field(() => GraphQLScalars.JSONResolver, {
    nullable: true
  })
  equals?: Prisma.InputJsonValue | undefined;

  @Field(() => [String], {
    nullable: true
  })
  path?: string[] | undefined;

  @Field(() => QueryMode, {
    nullable: true
  })
  mode?: \\"default\\" | \\"insensitive\\" | undefined;

  @Field(() => String, {
    nullable: true
  })
  string_contains?: string | undefined;

  @Field(() => String, {
    nullable: true
  })
  string_starts_with?: string | undefined;

  @Field(() => String, {
    nullable: true
  })
  string_ends_with?: string | undefined;

  @Field(() => GraphQLScalars.JSONResolver, {
    nullable: true
  })
  array_starts_with?: Prisma.InputJsonValue | undefined;

  @Field(() => GraphQLScalars.JSONResolver, {
    nullable: true
  })
  array_ends_with?: Prisma.InputJsonValue | undefined;

  @Field(() => GraphQLScalars.JSONResolver, {
    nullable: true
  })
  array_contains?: Prisma.InputJsonValue | undefined;

  @Field(() => GraphQLScalars.JSONResolver, {
    nullable: true
  })
  lt?: Prisma.InputJsonValue | undefined;

  @Field(() => GraphQLScalars.JSONResolver, {
    nullable: true
  })
  lte?: Prisma.InputJsonValue | undefined;

  @Field(() => GraphQLScalars.JSONResolver, {
    nullable: true
  })
  gt?: Prisma.InputJsonValue | undefined;

  @Field(() => GraphQLScalars.JSONResolver, {
    nullable: true
  })
  gte?: Prisma.InputJsonValue | undefined;

  @Field(() => GraphQLScalars.JSONResolver, {
    nullable: true
  })
  not?: Prisma.InputJsonValue | undefined;

  @Field(() => NestedIntFilter, {
    nullable: true
  })
  _count?: NestedIntFilter | undefined;

  @Field(() => NestedJsonFilter, {
    nullable: true
  })
  _min?: NestedJsonFilter | undefined;

  @Field(() => NestedJsonFilter, {
    nullable: true
  })
  _max?: NestedJsonFilter | undefined;
}
"
`;

exports[`inputs should properly generate input type classes for filtering json fields: NestedJsonFilter 1`] = `
"import { Args, ArgsType, Context, Field, Float, ID, Info, InputType, Int, Mutation, ObjectType, Parent, Query, ResolveField, Resolver, registerEnumType } from \\"@nestjs/graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { Prisma } from \\"../../../../helpers/prisma-client-mock\\";
import { DecimalJSScalar } from \\"../../scalars\\";
import { QueryMode } from \\"../../enums/QueryMode\\";

@InputType(\\"NestedJsonFilter\\", {})
export class NestedJsonFilter {
  @Field(() => GraphQLScalars.JSONResolver, {
    nullable: true
  })
  equals?: Prisma.InputJsonValue | undefined;

  @Field(() => [String], {
    nullable: true
  })
  path?: string[] | undefined;

  @Field(() => QueryMode, {
    nullable: true
  })
  mode?: \\"default\\" | \\"insensitive\\" | undefined;

  @Field(() => String, {
    nullable: true
  })
  string_contains?: string | undefined;

  @Field(() => String, {
    nullable: true
  })
  string_starts_with?: string | undefined;

  @Field(() => String, {
    nullable: true
  })
  string_ends_with?: string | undefined;

  @Field(() => GraphQLScalars.JSONResolver, {
    nullable: true
  })
  array_starts_with?: Prisma.InputJsonValue | undefined;

  @Field(() => GraphQLScalars.JSONResolver, {
    nullable: true
  })
  array_ends_with?: Prisma.InputJsonValue | undefined;

  @Field(() => GraphQLScalars.JSONResolver, {
    nullable: true
  })
  array_contains?: Prisma.InputJsonValue | undefined;

  @Field(() => GraphQLScalars.JSONResolver, {
    nullable: true
  })
  lt?: Prisma.InputJsonValue | undefined;

  @Field(() => GraphQLScalars.JSONResolver, {
    nullable: true
  })
  lte?: Prisma.InputJsonValue | undefined;

  @Field(() => GraphQLScalars.JSONResolver, {
    nullable: true
  })
  gt?: Prisma.InputJsonValue | undefined;

  @Field(() => GraphQLScalars.JSONResolver, {
    nullable: true
  })
  gte?: Prisma.InputJsonValue | undefined;

  @Field(() => GraphQLScalars.JSONResolver, {
    nullable: true
  })
  not?: Prisma.InputJsonValue | undefined;
}
"
`;

exports[`inputs should properly generate input type classes for filtering json fields: index 1`] = `
"export * from \\"./BoolFieldUpdateOperationsInput\\";
export * from \\"./BoolFilter\\";
export * from \\"./BoolWithAggregatesFilter\\";
export * from \\"./DateTimeFieldUpdateOperationsInput\\";
export * from \\"./DateTimeFilter\\";
export * from \\"./DateTimeWithAggregatesFilter\\";
export * from \\"./FloatFieldUpdateOperationsInput\\";
export * from \\"./FloatFilter\\";
export * from \\"./FloatWithAggregatesFilter\\";
export * from \\"./IntFieldUpdateOperationsInput\\";
export * from \\"./IntFilter\\";
export * from \\"./IntWithAggregatesFilter\\";
export * from \\"./JsonFilter\\";
export * from \\"./JsonWithAggregatesFilter\\";
export * from \\"./NestedBoolFilter\\";
export * from \\"./NestedBoolWithAggregatesFilter\\";
export * from \\"./NestedDateTimeFilter\\";
export * from \\"./NestedDateTimeWithAggregatesFilter\\";
export * from \\"./NestedFloatFilter\\";
export * from \\"./NestedFloatWithAggregatesFilter\\";
export * from \\"./NestedIntFilter\\";
export * from \\"./NestedIntWithAggregatesFilter\\";
export * from \\"./NestedJsonFilter\\";
export * from \\"./NestedStringFilter\\";
export * from \\"./NestedStringWithAggregatesFilter\\";
export * from \\"./SampleAvgOrderByAggregateInput\\";
export * from \\"./SampleCountOrderByAggregateInput\\";
export * from \\"./SampleCreateInput\\";
export * from \\"./SampleCreateManyInput\\";
export * from \\"./SampleMaxOrderByAggregateInput\\";
export * from \\"./SampleMinOrderByAggregateInput\\";
export * from \\"./SampleOrderByWithAggregationInput\\";
export * from \\"./SampleOrderByWithRelationInput\\";
export * from \\"./SampleScalarWhereWithAggregatesInput\\";
export * from \\"./SampleSumOrderByAggregateInput\\";
export * from \\"./SampleUpdateInput\\";
export * from \\"./SampleUpdateManyMutationInput\\";
export * from \\"./SampleWhereInput\\";
export * from \\"./SampleWhereUniqueInput\\";
export * from \\"./StringFieldUpdateOperationsInput\\";
export * from \\"./StringFilter\\";
export * from \\"./StringWithAggregatesFilter\\";
"
`;

exports[`inputs should properly generate input type classes for filtering models by fields: SampleModelWhereInput 1`] = `
"import { Args, ArgsType, Context, Field, Float, ID, Info, InputType, Int, Mutation, ObjectType, Parent, Query, ResolveField, Resolver, registerEnumType } from \\"@nestjs/graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { Prisma } from \\"../../../../helpers/prisma-client-mock\\";
import { DecimalJSScalar } from \\"../../scalars\\";
import { BoolFilter, DateTimeFilter, FloatFilter, IntFilter, JsonFilter, StringFilter, StringNullableFilter } from \\"../inputs\\";

@InputType(\\"SampleModelWhereInput\\", {})
export class SampleModelWhereInput {
  @Field(() => [SampleModelWhereInput], {
    nullable: true
  })
  AND?: SampleModelWhereInput[] | undefined;

  @Field(() => [SampleModelWhereInput], {
    nullable: true
  })
  OR?: SampleModelWhereInput[] | undefined;

  @Field(() => [SampleModelWhereInput], {
    nullable: true
  })
  NOT?: SampleModelWhereInput[] | undefined;

  @Field(() => IntFilter, {
    nullable: true
  })
  intIdField?: IntFilter | undefined;

  @Field(() => StringFilter, {
    nullable: true
  })
  stringField?: StringFilter | undefined;

  @Field(() => StringNullableFilter, {
    nullable: true
  })
  optionalStringField?: StringNullableFilter | undefined;

  @Field(() => IntFilter, {
    nullable: true
  })
  intField?: IntFilter | undefined;

  @Field(() => FloatFilter, {
    nullable: true
  })
  floatField?: FloatFilter | undefined;

  @Field(() => BoolFilter, {
    nullable: true
  })
  booleanField?: BoolFilter | undefined;

  @Field(() => DateTimeFilter, {
    nullable: true
  })
  dateField?: DateTimeFilter | undefined;

  @Field(() => JsonFilter, {
    nullable: true
  })
  jsonField?: JsonFilter | undefined;
}
"
`;

exports[`inputs should properly generate input type classes for filtering models by fields: SampleModelWhereUniqueInput 1`] = `
"import { Args, ArgsType, Context, Field, Float, ID, Info, InputType, Int, Mutation, ObjectType, Parent, Query, ResolveField, Resolver, registerEnumType } from \\"@nestjs/graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { Prisma } from \\"../../../../helpers/prisma-client-mock\\";
import { DecimalJSScalar } from \\"../../scalars\\";
import { BoolFilter, DateTimeFilter, FloatFilter, IntFilter, JsonFilter, SampleModelWhereInput, StringNullableFilter } from \\"../inputs\\";

@InputType(\\"SampleModelWhereUniqueInput\\", {})
export class SampleModelWhereUniqueInput {
  @Field(() => Int, {
    nullable: true
  })
  intIdField?: number | undefined;

  @Field(() => String, {
    nullable: true
  })
  stringField?: string | undefined;

  @Field(() => [SampleModelWhereInput], {
    nullable: true
  })
  AND?: SampleModelWhereInput[] | undefined;

  @Field(() => [SampleModelWhereInput], {
    nullable: true
  })
  OR?: SampleModelWhereInput[] | undefined;

  @Field(() => [SampleModelWhereInput], {
    nullable: true
  })
  NOT?: SampleModelWhereInput[] | undefined;

  @Field(() => StringNullableFilter, {
    nullable: true
  })
  optionalStringField?: StringNullableFilter | undefined;

  @Field(() => IntFilter, {
    nullable: true
  })
  intField?: IntFilter | undefined;

  @Field(() => FloatFilter, {
    nullable: true
  })
  floatField?: FloatFilter | undefined;

  @Field(() => BoolFilter, {
    nullable: true
  })
  booleanField?: BoolFilter | undefined;

  @Field(() => DateTimeFilter, {
    nullable: true
  })
  dateField?: DateTimeFilter | undefined;

  @Field(() => JsonFilter, {
    nullable: true
  })
  jsonField?: JsonFilter | undefined;
}
"
`;

exports[`inputs should properly generate input type classes for filtering models by fields: index 1`] = `
"export * from \\"./BoolFieldUpdateOperationsInput\\";
export * from \\"./BoolFilter\\";
export * from \\"./BoolWithAggregatesFilter\\";
export * from \\"./DateTimeFieldUpdateOperationsInput\\";
export * from \\"./DateTimeFilter\\";
export * from \\"./DateTimeWithAggregatesFilter\\";
export * from \\"./FloatFieldUpdateOperationsInput\\";
export * from \\"./FloatFilter\\";
export * from \\"./FloatWithAggregatesFilter\\";
export * from \\"./IntFieldUpdateOperationsInput\\";
export * from \\"./IntFilter\\";
export * from \\"./IntWithAggregatesFilter\\";
export * from \\"./JsonFilter\\";
export * from \\"./JsonWithAggregatesFilter\\";
export * from \\"./NestedBoolFilter\\";
export * from \\"./NestedBoolWithAggregatesFilter\\";
export * from \\"./NestedDateTimeFilter\\";
export * from \\"./NestedDateTimeWithAggregatesFilter\\";
export * from \\"./NestedFloatFilter\\";
export * from \\"./NestedFloatWithAggregatesFilter\\";
export * from \\"./NestedIntFilter\\";
export * from \\"./NestedIntNullableFilter\\";
export * from \\"./NestedIntWithAggregatesFilter\\";
export * from \\"./NestedJsonFilter\\";
export * from \\"./NestedStringFilter\\";
export * from \\"./NestedStringNullableFilter\\";
export * from \\"./NestedStringNullableWithAggregatesFilter\\";
export * from \\"./NestedStringWithAggregatesFilter\\";
export * from \\"./NullableStringFieldUpdateOperationsInput\\";
export * from \\"./SampleModelAvgOrderByAggregateInput\\";
export * from \\"./SampleModelCountOrderByAggregateInput\\";
export * from \\"./SampleModelCreateInput\\";
export * from \\"./SampleModelCreateManyInput\\";
export * from \\"./SampleModelMaxOrderByAggregateInput\\";
export * from \\"./SampleModelMinOrderByAggregateInput\\";
export * from \\"./SampleModelOrderByWithAggregationInput\\";
export * from \\"./SampleModelOrderByWithRelationInput\\";
export * from \\"./SampleModelScalarWhereWithAggregatesInput\\";
export * from \\"./SampleModelSumOrderByAggregateInput\\";
export * from \\"./SampleModelUpdateInput\\";
export * from \\"./SampleModelUpdateManyMutationInput\\";
export * from \\"./SampleModelWhereInput\\";
export * from \\"./SampleModelWhereUniqueInput\\";
export * from \\"./SortOrderInput\\";
export * from \\"./StringFieldUpdateOperationsInput\\";
export * from \\"./StringFilter\\";
export * from \\"./StringNullableFilter\\";
export * from \\"./StringNullableWithAggregatesFilter\\";
export * from \\"./StringWithAggregatesFilter\\";
"
`;

exports[`inputs should properly generate input type classes for filtering models by many to many relation fields: FirstModelOrderByWithRelationInput 1`] = `
"import { Args, ArgsType, Context, Field, Float, ID, Info, InputType, Int, Mutation, ObjectType, Parent, Query, ResolveField, Resolver, registerEnumType } from \\"@nestjs/graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { Prisma } from \\"../../../../helpers/prisma-client-mock\\";
import { DecimalJSScalar } from \\"../../scalars\\";
import { SecondModelOrderByRelationAggregateInput } from \\"../inputs\\";
import { SortOrder } from \\"../../enums/SortOrder\\";

@InputType(\\"FirstModelOrderByWithRelationInput\\", {})
export class FirstModelOrderByWithRelationInput {
  @Field(() => SortOrder, {
    nullable: true
  })
  idField?: \\"asc\\" | \\"desc\\" | undefined;

  @Field(() => SortOrder, {
    nullable: true
  })
  uniqueStringField?: \\"asc\\" | \\"desc\\" | undefined;

  @Field(() => SortOrder, {
    nullable: true
  })
  floatField?: \\"asc\\" | \\"desc\\" | undefined;

  @Field(() => SecondModelOrderByRelationAggregateInput, {
    nullable: true
  })
  secondModelsField?: SecondModelOrderByRelationAggregateInput | undefined;
}
"
`;

exports[`inputs should properly generate input type classes for filtering models by many to many relation fields: FirstModelScalarWhereInput 1`] = `
"import { Args, ArgsType, Context, Field, Float, ID, Info, InputType, Int, Mutation, ObjectType, Parent, Query, ResolveField, Resolver, registerEnumType } from \\"@nestjs/graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { Prisma } from \\"../../../../helpers/prisma-client-mock\\";
import { DecimalJSScalar } from \\"../../scalars\\";
import { FloatFilter, IntFilter, StringFilter } from \\"../inputs\\";

@InputType(\\"FirstModelScalarWhereInput\\", {})
export class FirstModelScalarWhereInput {
  @Field(() => [FirstModelScalarWhereInput], {
    nullable: true
  })
  AND?: FirstModelScalarWhereInput[] | undefined;

  @Field(() => [FirstModelScalarWhereInput], {
    nullable: true
  })
  OR?: FirstModelScalarWhereInput[] | undefined;

  @Field(() => [FirstModelScalarWhereInput], {
    nullable: true
  })
  NOT?: FirstModelScalarWhereInput[] | undefined;

  @Field(() => IntFilter, {
    nullable: true
  })
  idField?: IntFilter | undefined;

  @Field(() => StringFilter, {
    nullable: true
  })
  uniqueStringField?: StringFilter | undefined;

  @Field(() => FloatFilter, {
    nullable: true
  })
  floatField?: FloatFilter | undefined;
}
"
`;

exports[`inputs should properly generate input type classes for filtering models by many to many relation fields: FirstModelWhereInput 1`] = `
"import { Args, ArgsType, Context, Field, Float, ID, Info, InputType, Int, Mutation, ObjectType, Parent, Query, ResolveField, Resolver, registerEnumType } from \\"@nestjs/graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { Prisma } from \\"../../../../helpers/prisma-client-mock\\";
import { DecimalJSScalar } from \\"../../scalars\\";
import { FloatFilter, IntFilter, SecondModelListRelationFilter, StringFilter } from \\"../inputs\\";

@InputType(\\"FirstModelWhereInput\\", {})
export class FirstModelWhereInput {
  @Field(() => [FirstModelWhereInput], {
    nullable: true
  })
  AND?: FirstModelWhereInput[] | undefined;

  @Field(() => [FirstModelWhereInput], {
    nullable: true
  })
  OR?: FirstModelWhereInput[] | undefined;

  @Field(() => [FirstModelWhereInput], {
    nullable: true
  })
  NOT?: FirstModelWhereInput[] | undefined;

  @Field(() => IntFilter, {
    nullable: true
  })
  idField?: IntFilter | undefined;

  @Field(() => StringFilter, {
    nullable: true
  })
  uniqueStringField?: StringFilter | undefined;

  @Field(() => FloatFilter, {
    nullable: true
  })
  floatField?: FloatFilter | undefined;

  @Field(() => SecondModelListRelationFilter, {
    nullable: true
  })
  secondModelsField?: SecondModelListRelationFilter | undefined;
}
"
`;

exports[`inputs should properly generate input type classes for filtering models by many to many relation fields: FirstModelWhereUniqueInput 1`] = `
"import { Args, ArgsType, Context, Field, Float, ID, Info, InputType, Int, Mutation, ObjectType, Parent, Query, ResolveField, Resolver, registerEnumType } from \\"@nestjs/graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { Prisma } from \\"../../../../helpers/prisma-client-mock\\";
import { DecimalJSScalar } from \\"../../scalars\\";
import { FirstModelWhereInput, FloatFilter, SecondModelListRelationFilter } from \\"../inputs\\";

@InputType(\\"FirstModelWhereUniqueInput\\", {})
export class FirstModelWhereUniqueInput {
  @Field(() => Int, {
    nullable: true
  })
  idField?: number | undefined;

  @Field(() => String, {
    nullable: true
  })
  uniqueStringField?: string | undefined;

  @Field(() => [FirstModelWhereInput], {
    nullable: true
  })
  AND?: FirstModelWhereInput[] | undefined;

  @Field(() => [FirstModelWhereInput], {
    nullable: true
  })
  OR?: FirstModelWhereInput[] | undefined;

  @Field(() => [FirstModelWhereInput], {
    nullable: true
  })
  NOT?: FirstModelWhereInput[] | undefined;

  @Field(() => FloatFilter, {
    nullable: true
  })
  floatField?: FloatFilter | undefined;

  @Field(() => SecondModelListRelationFilter, {
    nullable: true
  })
  secondModelsField?: SecondModelListRelationFilter | undefined;
}
"
`;

exports[`inputs should properly generate input type classes for filtering models by many to many relation fields: index 1`] = `
"export * from \\"./FirstModelAvgOrderByAggregateInput\\";
export * from \\"./FirstModelCountOrderByAggregateInput\\";
export * from \\"./FirstModelCreateInput\\";
export * from \\"./FirstModelCreateManyInput\\";
export * from \\"./FirstModelCreateNestedManyWithoutSecondModelsFieldInput\\";
export * from \\"./FirstModelCreateOrConnectWithoutSecondModelsFieldInput\\";
export * from \\"./FirstModelCreateWithoutSecondModelsFieldInput\\";
export * from \\"./FirstModelListRelationFilter\\";
export * from \\"./FirstModelMaxOrderByAggregateInput\\";
export * from \\"./FirstModelMinOrderByAggregateInput\\";
export * from \\"./FirstModelOrderByRelationAggregateInput\\";
export * from \\"./FirstModelOrderByWithAggregationInput\\";
export * from \\"./FirstModelOrderByWithRelationInput\\";
export * from \\"./FirstModelScalarWhereInput\\";
export * from \\"./FirstModelScalarWhereWithAggregatesInput\\";
export * from \\"./FirstModelSumOrderByAggregateInput\\";
export * from \\"./FirstModelUpdateInput\\";
export * from \\"./FirstModelUpdateManyMutationInput\\";
export * from \\"./FirstModelUpdateManyWithWhereWithoutSecondModelsFieldInput\\";
export * from \\"./FirstModelUpdateManyWithoutSecondModelsFieldNestedInput\\";
export * from \\"./FirstModelUpdateWithWhereUniqueWithoutSecondModelsFieldInput\\";
export * from \\"./FirstModelUpdateWithoutSecondModelsFieldInput\\";
export * from \\"./FirstModelUpsertWithWhereUniqueWithoutSecondModelsFieldInput\\";
export * from \\"./FirstModelWhereInput\\";
export * from \\"./FirstModelWhereUniqueInput\\";
export * from \\"./FloatFieldUpdateOperationsInput\\";
export * from \\"./FloatFilter\\";
export * from \\"./FloatWithAggregatesFilter\\";
export * from \\"./IntFieldUpdateOperationsInput\\";
export * from \\"./IntFilter\\";
export * from \\"./IntWithAggregatesFilter\\";
export * from \\"./NestedFloatFilter\\";
export * from \\"./NestedFloatWithAggregatesFilter\\";
export * from \\"./NestedIntFilter\\";
export * from \\"./NestedIntWithAggregatesFilter\\";
export * from \\"./NestedStringFilter\\";
export * from \\"./NestedStringWithAggregatesFilter\\";
export * from \\"./SecondModelAvgOrderByAggregateInput\\";
export * from \\"./SecondModelCountOrderByAggregateInput\\";
export * from \\"./SecondModelCreateInput\\";
export * from \\"./SecondModelCreateManyInput\\";
export * from \\"./SecondModelCreateNestedManyWithoutFirstModelsFieldInput\\";
export * from \\"./SecondModelCreateOrConnectWithoutFirstModelsFieldInput\\";
export * from \\"./SecondModelCreateWithoutFirstModelsFieldInput\\";
export * from \\"./SecondModelListRelationFilter\\";
export * from \\"./SecondModelMaxOrderByAggregateInput\\";
export * from \\"./SecondModelMinOrderByAggregateInput\\";
export * from \\"./SecondModelOrderByRelationAggregateInput\\";
export * from \\"./SecondModelOrderByWithAggregationInput\\";
export * from \\"./SecondModelOrderByWithRelationInput\\";
export * from \\"./SecondModelScalarWhereInput\\";
export * from \\"./SecondModelScalarWhereWithAggregatesInput\\";
export * from \\"./SecondModelSumOrderByAggregateInput\\";
export * from \\"./SecondModelUpdateInput\\";
export * from \\"./SecondModelUpdateManyMutationInput\\";
export * from \\"./SecondModelUpdateManyWithWhereWithoutFirstModelsFieldInput\\";
export * from \\"./SecondModelUpdateManyWithoutFirstModelsFieldNestedInput\\";
export * from \\"./SecondModelUpdateWithWhereUniqueWithoutFirstModelsFieldInput\\";
export * from \\"./SecondModelUpdateWithoutFirstModelsFieldInput\\";
export * from \\"./SecondModelUpsertWithWhereUniqueWithoutFirstModelsFieldInput\\";
export * from \\"./SecondModelWhereInput\\";
export * from \\"./SecondModelWhereUniqueInput\\";
export * from \\"./StringFieldUpdateOperationsInput\\";
export * from \\"./StringFilter\\";
export * from \\"./StringWithAggregatesFilter\\";
"
`;

exports[`inputs should properly generate input type classes for filtering models by one to many relation fields: FirstModelOrderByWithRelationInput 1`] = `
"import { Args, ArgsType, Context, Field, Float, ID, Info, InputType, Int, Mutation, ObjectType, Parent, Query, ResolveField, Resolver, registerEnumType } from \\"@nestjs/graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { Prisma } from \\"../../../../helpers/prisma-client-mock\\";
import { DecimalJSScalar } from \\"../../scalars\\";
import { SecondModelOrderByRelationAggregateInput } from \\"../inputs\\";
import { SortOrder } from \\"../../enums/SortOrder\\";

@InputType(\\"FirstModelOrderByWithRelationInput\\", {})
export class FirstModelOrderByWithRelationInput {
  @Field(() => SortOrder, {
    nullable: true
  })
  idField?: \\"asc\\" | \\"desc\\" | undefined;

  @Field(() => SortOrder, {
    nullable: true
  })
  uniqueStringField?: \\"asc\\" | \\"desc\\" | undefined;

  @Field(() => SortOrder, {
    nullable: true
  })
  floatField?: \\"asc\\" | \\"desc\\" | undefined;

  @Field(() => SecondModelOrderByRelationAggregateInput, {
    nullable: true
  })
  secondModelsField?: SecondModelOrderByRelationAggregateInput | undefined;
}
"
`;

exports[`inputs should properly generate input type classes for filtering models by one to many relation fields: FirstModelScalarRelationFilter 1`] = `
"import { Args, ArgsType, Context, Field, Float, ID, Info, InputType, Int, Mutation, ObjectType, Parent, Query, ResolveField, Resolver, registerEnumType } from \\"@nestjs/graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { Prisma } from \\"../../../../helpers/prisma-client-mock\\";
import { DecimalJSScalar } from \\"../../scalars\\";
import { FirstModelWhereInput } from \\"../inputs\\";

@InputType(\\"FirstModelScalarRelationFilter\\", {})
export class FirstModelScalarRelationFilter {
  @Field(() => FirstModelWhereInput, {
    nullable: true
  })
  is?: FirstModelWhereInput | undefined;

  @Field(() => FirstModelWhereInput, {
    nullable: true
  })
  isNot?: FirstModelWhereInput | undefined;
}
"
`;

exports[`inputs should properly generate input type classes for filtering models by one to many relation fields: FirstModelWhereInput 1`] = `
"import { Args, ArgsType, Context, Field, Float, ID, Info, InputType, Int, Mutation, ObjectType, Parent, Query, ResolveField, Resolver, registerEnumType } from \\"@nestjs/graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { Prisma } from \\"../../../../helpers/prisma-client-mock\\";
import { DecimalJSScalar } from \\"../../scalars\\";
import { FloatFilter, IntFilter, SecondModelListRelationFilter, StringFilter } from \\"../inputs\\";

@InputType(\\"FirstModelWhereInput\\", {})
export class FirstModelWhereInput {
  @Field(() => [FirstModelWhereInput], {
    nullable: true
  })
  AND?: FirstModelWhereInput[] | undefined;

  @Field(() => [FirstModelWhereInput], {
    nullable: true
  })
  OR?: FirstModelWhereInput[] | undefined;

  @Field(() => [FirstModelWhereInput], {
    nullable: true
  })
  NOT?: FirstModelWhereInput[] | undefined;

  @Field(() => IntFilter, {
    nullable: true
  })
  idField?: IntFilter | undefined;

  @Field(() => StringFilter, {
    nullable: true
  })
  uniqueStringField?: StringFilter | undefined;

  @Field(() => FloatFilter, {
    nullable: true
  })
  floatField?: FloatFilter | undefined;

  @Field(() => SecondModelListRelationFilter, {
    nullable: true
  })
  secondModelsField?: SecondModelListRelationFilter | undefined;
}
"
`;

exports[`inputs should properly generate input type classes for filtering models by one to many relation fields: FirstModelWhereUniqueInput 1`] = `
"import { Args, ArgsType, Context, Field, Float, ID, Info, InputType, Int, Mutation, ObjectType, Parent, Query, ResolveField, Resolver, registerEnumType } from \\"@nestjs/graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { Prisma } from \\"../../../../helpers/prisma-client-mock\\";
import { DecimalJSScalar } from \\"../../scalars\\";
import { FirstModelWhereInput, FloatFilter, SecondModelListRelationFilter } from \\"../inputs\\";

@InputType(\\"FirstModelWhereUniqueInput\\", {})
export class FirstModelWhereUniqueInput {
  @Field(() => Int, {
    nullable: true
  })
  idField?: number | undefined;

  @Field(() => String, {
    nullable: true
  })
  uniqueStringField?: string | undefined;

  @Field(() => [FirstModelWhereInput], {
    nullable: true
  })
  AND?: FirstModelWhereInput[] | undefined;

  @Field(() => [FirstModelWhereInput], {
    nullable: true
  })
  OR?: FirstModelWhereInput[] | undefined;

  @Field(() => [FirstModelWhereInput], {
    nullable: true
  })
  NOT?: FirstModelWhereInput[] | undefined;

  @Field(() => FloatFilter, {
    nullable: true
  })
  floatField?: FloatFilter | undefined;

  @Field(() => SecondModelListRelationFilter, {
    nullable: true
  })
  secondModelsField?: SecondModelListRelationFilter | undefined;
}
"
`;

exports[`inputs should properly generate input type classes for filtering models by one to many relation fields: SecondModelListRelationFilter 1`] = `
"import { Args, ArgsType, Context, Field, Float, ID, Info, InputType, Int, Mutation, ObjectType, Parent, Query, ResolveField, Resolver, registerEnumType } from \\"@nestjs/graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { Prisma } from \\"../../../../helpers/prisma-client-mock\\";
import { DecimalJSScalar } from \\"../../scalars\\";
import { SecondModelWhereInput } from \\"../inputs\\";

@InputType(\\"SecondModelListRelationFilter\\", {})
export class SecondModelListRelationFilter {
  @Field(() => SecondModelWhereInput, {
    nullable: true
  })
  every?: SecondModelWhereInput | undefined;

  @Field(() => SecondModelWhereInput, {
    nullable: true
  })
  some?: SecondModelWhereInput | undefined;

  @Field(() => SecondModelWhereInput, {
    nullable: true
  })
  none?: SecondModelWhereInput | undefined;
}
"
`;

exports[`inputs should properly generate input type classes for filtering models by one to many relation fields: SecondModelOrderByWithRelationInput 1`] = `
"import { Args, ArgsType, Context, Field, Float, ID, Info, InputType, Int, Mutation, ObjectType, Parent, Query, ResolveField, Resolver, registerEnumType } from \\"@nestjs/graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { Prisma } from \\"../../../../helpers/prisma-client-mock\\";
import { DecimalJSScalar } from \\"../../scalars\\";
import { FirstModelOrderByWithRelationInput } from \\"../inputs\\";
import { SortOrder } from \\"../../enums/SortOrder\\";

@InputType(\\"SecondModelOrderByWithRelationInput\\", {})
export class SecondModelOrderByWithRelationInput {
  @Field(() => SortOrder, {
    nullable: true
  })
  idField?: \\"asc\\" | \\"desc\\" | undefined;

  @Field(() => SortOrder, {
    nullable: true
  })
  uniqueStringField?: \\"asc\\" | \\"desc\\" | undefined;

  @Field(() => SortOrder, {
    nullable: true
  })
  floatField?: \\"asc\\" | \\"desc\\" | undefined;

  @Field(() => SortOrder, {
    nullable: true
  })
  firstModelFieldId?: \\"asc\\" | \\"desc\\" | undefined;

  @Field(() => FirstModelOrderByWithRelationInput, {
    nullable: true
  })
  firstModelField?: FirstModelOrderByWithRelationInput | undefined;
}
"
`;

exports[`inputs should properly generate input type classes for filtering models by one to many relation fields: SecondModelScalarWhereInput 1`] = `
"import { Args, ArgsType, Context, Field, Float, ID, Info, InputType, Int, Mutation, ObjectType, Parent, Query, ResolveField, Resolver, registerEnumType } from \\"@nestjs/graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { Prisma } from \\"../../../../helpers/prisma-client-mock\\";
import { DecimalJSScalar } from \\"../../scalars\\";
import { FloatFilter, IntFilter, StringFilter } from \\"../inputs\\";

@InputType(\\"SecondModelScalarWhereInput\\", {})
export class SecondModelScalarWhereInput {
  @Field(() => [SecondModelScalarWhereInput], {
    nullable: true
  })
  AND?: SecondModelScalarWhereInput[] | undefined;

  @Field(() => [SecondModelScalarWhereInput], {
    nullable: true
  })
  OR?: SecondModelScalarWhereInput[] | undefined;

  @Field(() => [SecondModelScalarWhereInput], {
    nullable: true
  })
  NOT?: SecondModelScalarWhereInput[] | undefined;

  @Field(() => IntFilter, {
    nullable: true
  })
  idField?: IntFilter | undefined;

  @Field(() => StringFilter, {
    nullable: true
  })
  uniqueStringField?: StringFilter | undefined;

  @Field(() => FloatFilter, {
    nullable: true
  })
  floatField?: FloatFilter | undefined;

  @Field(() => IntFilter, {
    nullable: true
  })
  firstModelFieldId?: IntFilter | undefined;
}
"
`;

exports[`inputs should properly generate input type classes for filtering models by one to many relation fields: SecondModelWhereInput 1`] = `
"import { Args, ArgsType, Context, Field, Float, ID, Info, InputType, Int, Mutation, ObjectType, Parent, Query, ResolveField, Resolver, registerEnumType } from \\"@nestjs/graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { Prisma } from \\"../../../../helpers/prisma-client-mock\\";
import { DecimalJSScalar } from \\"../../scalars\\";
import { FirstModelScalarRelationFilter, FloatFilter, IntFilter, StringFilter } from \\"../inputs\\";

@InputType(\\"SecondModelWhereInput\\", {})
export class SecondModelWhereInput {
  @Field(() => [SecondModelWhereInput], {
    nullable: true
  })
  AND?: SecondModelWhereInput[] | undefined;

  @Field(() => [SecondModelWhereInput], {
    nullable: true
  })
  OR?: SecondModelWhereInput[] | undefined;

  @Field(() => [SecondModelWhereInput], {
    nullable: true
  })
  NOT?: SecondModelWhereInput[] | undefined;

  @Field(() => IntFilter, {
    nullable: true
  })
  idField?: IntFilter | undefined;

  @Field(() => StringFilter, {
    nullable: true
  })
  uniqueStringField?: StringFilter | undefined;

  @Field(() => FloatFilter, {
    nullable: true
  })
  floatField?: FloatFilter | undefined;

  @Field(() => IntFilter, {
    nullable: true
  })
  firstModelFieldId?: IntFilter | undefined;

  @Field(() => FirstModelScalarRelationFilter, {
    nullable: true
  })
  firstModelField?: FirstModelScalarRelationFilter | undefined;
}
"
`;

exports[`inputs should properly generate input type classes for filtering models by one to many relation fields: SecondModelWhereUniqueInput 1`] = `
"import { Args, ArgsType, Context, Field, Float, ID, Info, InputType, Int, Mutation, ObjectType, Parent, Query, ResolveField, Resolver, registerEnumType } from \\"@nestjs/graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { Prisma } from \\"../../../../helpers/prisma-client-mock\\";
import { DecimalJSScalar } from \\"../../scalars\\";
import { FirstModelScalarRelationFilter, FloatFilter, IntFilter, SecondModelWhereInput } from \\"../inputs\\";

@InputType(\\"SecondModelWhereUniqueInput\\", {})
export class SecondModelWhereUniqueInput {
  @Field(() => Int, {
    nullable: true
  })
  idField?: number | undefined;

  @Field(() => String, {
    nullable: true
  })
  uniqueStringField?: string | undefined;

  @Field(() => [SecondModelWhereInput], {
    nullable: true
  })
  AND?: SecondModelWhereInput[] | undefined;

  @Field(() => [SecondModelWhereInput], {
    nullable: true
  })
  OR?: SecondModelWhereInput[] | undefined;

  @Field(() => [SecondModelWhereInput], {
    nullable: true
  })
  NOT?: SecondModelWhereInput[] | undefined;

  @Field(() => FloatFilter, {
    nullable: true
  })
  floatField?: FloatFilter | undefined;

  @Field(() => IntFilter, {
    nullable: true
  })
  firstModelFieldId?: IntFilter | undefined;

  @Field(() => FirstModelScalarRelationFilter, {
    nullable: true
  })
  firstModelField?: FirstModelScalarRelationFilter | undefined;
}
"
`;

exports[`inputs should properly generate input type classes for filtering models by one to many relation fields: index 1`] = `
"export * from \\"./FirstModelAvgOrderByAggregateInput\\";
export * from \\"./FirstModelCountOrderByAggregateInput\\";
export * from \\"./FirstModelCreateInput\\";
export * from \\"./FirstModelCreateManyInput\\";
export * from \\"./FirstModelCreateNestedOneWithoutSecondModelsFieldInput\\";
export * from \\"./FirstModelCreateOrConnectWithoutSecondModelsFieldInput\\";
export * from \\"./FirstModelCreateWithoutSecondModelsFieldInput\\";
export * from \\"./FirstModelMaxOrderByAggregateInput\\";
export * from \\"./FirstModelMinOrderByAggregateInput\\";
export * from \\"./FirstModelOrderByWithAggregationInput\\";
export * from \\"./FirstModelOrderByWithRelationInput\\";
export * from \\"./FirstModelScalarRelationFilter\\";
export * from \\"./FirstModelScalarWhereWithAggregatesInput\\";
export * from \\"./FirstModelSumOrderByAggregateInput\\";
export * from \\"./FirstModelUpdateInput\\";
export * from \\"./FirstModelUpdateManyMutationInput\\";
export * from \\"./FirstModelUpdateOneRequiredWithoutSecondModelsFieldNestedInput\\";
export * from \\"./FirstModelUpdateToOneWithWhereWithoutSecondModelsFieldInput\\";
export * from \\"./FirstModelUpdateWithoutSecondModelsFieldInput\\";
export * from \\"./FirstModelUpsertWithoutSecondModelsFieldInput\\";
export * from \\"./FirstModelWhereInput\\";
export * from \\"./FirstModelWhereUniqueInput\\";
export * from \\"./FloatFieldUpdateOperationsInput\\";
export * from \\"./FloatFilter\\";
export * from \\"./FloatWithAggregatesFilter\\";
export * from \\"./IntFieldUpdateOperationsInput\\";
export * from \\"./IntFilter\\";
export * from \\"./IntWithAggregatesFilter\\";
export * from \\"./NestedFloatFilter\\";
export * from \\"./NestedFloatWithAggregatesFilter\\";
export * from \\"./NestedIntFilter\\";
export * from \\"./NestedIntWithAggregatesFilter\\";
export * from \\"./NestedStringFilter\\";
export * from \\"./NestedStringWithAggregatesFilter\\";
export * from \\"./SecondModelAvgOrderByAggregateInput\\";
export * from \\"./SecondModelCountOrderByAggregateInput\\";
export * from \\"./SecondModelCreateInput\\";
export * from \\"./SecondModelCreateManyFirstModelFieldInput\\";
export * from \\"./SecondModelCreateManyFirstModelFieldInputEnvelope\\";
export * from \\"./SecondModelCreateManyInput\\";
export * from \\"./SecondModelCreateNestedManyWithoutFirstModelFieldInput\\";
export * from \\"./SecondModelCreateOrConnectWithoutFirstModelFieldInput\\";
export * from \\"./SecondModelCreateWithoutFirstModelFieldInput\\";
export * from \\"./SecondModelListRelationFilter\\";
export * from \\"./SecondModelMaxOrderByAggregateInput\\";
export * from \\"./SecondModelMinOrderByAggregateInput\\";
export * from \\"./SecondModelOrderByRelationAggregateInput\\";
export * from \\"./SecondModelOrderByWithAggregationInput\\";
export * from \\"./SecondModelOrderByWithRelationInput\\";
export * from \\"./SecondModelScalarWhereInput\\";
export * from \\"./SecondModelScalarWhereWithAggregatesInput\\";
export * from \\"./SecondModelSumOrderByAggregateInput\\";
export * from \\"./SecondModelUpdateInput\\";
export * from \\"./SecondModelUpdateManyMutationInput\\";
export * from \\"./SecondModelUpdateManyWithWhereWithoutFirstModelFieldInput\\";
export * from \\"./SecondModelUpdateManyWithoutFirstModelFieldNestedInput\\";
export * from \\"./SecondModelUpdateWithWhereUniqueWithoutFirstModelFieldInput\\";
export * from \\"./SecondModelUpdateWithoutFirstModelFieldInput\\";
export * from \\"./SecondModelUpsertWithWhereUniqueWithoutFirstModelFieldInput\\";
export * from \\"./SecondModelWhereInput\\";
export * from \\"./SecondModelWhereUniqueInput\\";
export * from \\"./StringFieldUpdateOperationsInput\\";
export * from \\"./StringFilter\\";
export * from \\"./StringWithAggregatesFilter\\";
"
`;

exports[`inputs should properly generate input type classes for filtering scalar fields: BoolFilter 1`] = `
"import { Args, ArgsType, Context, Field, Float, ID, Info, InputType, Int, Mutation, ObjectType, Parent, Query, ResolveField, Resolver, registerEnumType } from \\"@nestjs/graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { Prisma } from \\"../../../../helpers/prisma-client-mock\\";
import { DecimalJSScalar } from \\"../../scalars\\";
import { NestedBoolFilter } from \\"../inputs\\";

@InputType(\\"BoolFilter\\", {})
export class BoolFilter {
  @Field(() => Boolean, {
    nullable: true
  })
  equals?: boolean | undefined;

  @Field(() => NestedBoolFilter, {
    nullable: true
  })
  not?: NestedBoolFilter | undefined;
}
"
`;

exports[`inputs should properly generate input type classes for filtering scalar fields: DateTimeFilter 1`] = `
"import { Args, ArgsType, Context, Field, Float, ID, Info, InputType, Int, Mutation, ObjectType, Parent, Query, ResolveField, Resolver, registerEnumType } from \\"@nestjs/graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { Prisma } from \\"../../../../helpers/prisma-client-mock\\";
import { DecimalJSScalar } from \\"../../scalars\\";
import { NestedDateTimeFilter } from \\"../inputs\\";

@InputType(\\"DateTimeFilter\\", {})
export class DateTimeFilter {
  @Field(() => Date, {
    nullable: true
  })
  equals?: Date | undefined;

  @Field(() => [Date], {
    nullable: true
  })
  in?: Date[] | undefined;

  @Field(() => [Date], {
    nullable: true
  })
  notIn?: Date[] | undefined;

  @Field(() => Date, {
    nullable: true
  })
  lt?: Date | undefined;

  @Field(() => Date, {
    nullable: true
  })
  lte?: Date | undefined;

  @Field(() => Date, {
    nullable: true
  })
  gt?: Date | undefined;

  @Field(() => Date, {
    nullable: true
  })
  gte?: Date | undefined;

  @Field(() => NestedDateTimeFilter, {
    nullable: true
  })
  not?: NestedDateTimeFilter | undefined;
}
"
`;

exports[`inputs should properly generate input type classes for filtering scalar fields: FloatFilter 1`] = `
"import { Args, ArgsType, Context, Field, Float, ID, Info, InputType, Int, Mutation, ObjectType, Parent, Query, ResolveField, Resolver, registerEnumType } from \\"@nestjs/graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { Prisma } from \\"../../../../helpers/prisma-client-mock\\";
import { DecimalJSScalar } from \\"../../scalars\\";
import { NestedFloatFilter } from \\"../inputs\\";

@InputType(\\"FloatFilter\\", {})
export class FloatFilter {
  @Field(() => Float, {
    nullable: true
  })
  equals?: number | undefined;

  @Field(() => [Float], {
    nullable: true
  })
  in?: number[] | undefined;

  @Field(() => [Float], {
    nullable: true
  })
  notIn?: number[] | undefined;

  @Field(() => Float, {
    nullable: true
  })
  lt?: number | undefined;

  @Field(() => Float, {
    nullable: true
  })
  lte?: number | undefined;

  @Field(() => Float, {
    nullable: true
  })
  gt?: number | undefined;

  @Field(() => Float, {
    nullable: true
  })
  gte?: number | undefined;

  @Field(() => NestedFloatFilter, {
    nullable: true
  })
  not?: NestedFloatFilter | undefined;
}
"
`;

exports[`inputs should properly generate input type classes for filtering scalar fields: IntFilter 1`] = `
"import { Args, ArgsType, Context, Field, Float, ID, Info, InputType, Int, Mutation, ObjectType, Parent, Query, ResolveField, Resolver, registerEnumType } from \\"@nestjs/graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { Prisma } from \\"../../../../helpers/prisma-client-mock\\";
import { DecimalJSScalar } from \\"../../scalars\\";
import { NestedIntFilter } from \\"../inputs\\";

@InputType(\\"IntFilter\\", {})
export class IntFilter {
  @Field(() => Int, {
    nullable: true
  })
  equals?: number | undefined;

  @Field(() => [Int], {
    nullable: true
  })
  in?: number[] | undefined;

  @Field(() => [Int], {
    nullable: true
  })
  notIn?: number[] | undefined;

  @Field(() => Int, {
    nullable: true
  })
  lt?: number | undefined;

  @Field(() => Int, {
    nullable: true
  })
  lte?: number | undefined;

  @Field(() => Int, {
    nullable: true
  })
  gt?: number | undefined;

  @Field(() => Int, {
    nullable: true
  })
  gte?: number | undefined;

  @Field(() => NestedIntFilter, {
    nullable: true
  })
  not?: NestedIntFilter | undefined;
}
"
`;

exports[`inputs should properly generate input type classes for filtering scalar fields: IntNullableListFilter 1`] = `
"import { Args, ArgsType, Context, Field, Float, ID, Info, InputType, Int, Mutation, ObjectType, Parent, Query, ResolveField, Resolver, registerEnumType } from \\"@nestjs/graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { Prisma } from \\"../../../../helpers/prisma-client-mock\\";
import { DecimalJSScalar } from \\"../../scalars\\";

@InputType(\\"IntNullableListFilter\\", {})
export class IntNullableListFilter {
  @Field(() => [Int], {
    nullable: true
  })
  equals?: number[] | undefined;

  @Field(() => Int, {
    nullable: true
  })
  has?: number | undefined;

  @Field(() => [Int], {
    nullable: true
  })
  hasEvery?: number[] | undefined;

  @Field(() => [Int], {
    nullable: true
  })
  hasSome?: number[] | undefined;

  @Field(() => Boolean, {
    nullable: true
  })
  isEmpty?: boolean | undefined;
}
"
`;

exports[`inputs should properly generate input type classes for filtering scalar fields: JsonFilter 1`] = `
"import { Args, ArgsType, Context, Field, Float, ID, Info, InputType, Int, Mutation, ObjectType, Parent, Query, ResolveField, Resolver, registerEnumType } from \\"@nestjs/graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { Prisma } from \\"../../../../helpers/prisma-client-mock\\";
import { DecimalJSScalar } from \\"../../scalars\\";
import { QueryMode } from \\"../../enums/QueryMode\\";

@InputType(\\"JsonFilter\\", {})
export class JsonFilter {
  @Field(() => GraphQLScalars.JSONResolver, {
    nullable: true
  })
  equals?: Prisma.InputJsonValue | undefined;

  @Field(() => [String], {
    nullable: true
  })
  path?: string[] | undefined;

  @Field(() => QueryMode, {
    nullable: true
  })
  mode?: \\"default\\" | \\"insensitive\\" | undefined;

  @Field(() => String, {
    nullable: true
  })
  string_contains?: string | undefined;

  @Field(() => String, {
    nullable: true
  })
  string_starts_with?: string | undefined;

  @Field(() => String, {
    nullable: true
  })
  string_ends_with?: string | undefined;

  @Field(() => GraphQLScalars.JSONResolver, {
    nullable: true
  })
  array_starts_with?: Prisma.InputJsonValue | undefined;

  @Field(() => GraphQLScalars.JSONResolver, {
    nullable: true
  })
  array_ends_with?: Prisma.InputJsonValue | undefined;

  @Field(() => GraphQLScalars.JSONResolver, {
    nullable: true
  })
  array_contains?: Prisma.InputJsonValue | undefined;

  @Field(() => GraphQLScalars.JSONResolver, {
    nullable: true
  })
  lt?: Prisma.InputJsonValue | undefined;

  @Field(() => GraphQLScalars.JSONResolver, {
    nullable: true
  })
  lte?: Prisma.InputJsonValue | undefined;

  @Field(() => GraphQLScalars.JSONResolver, {
    nullable: true
  })
  gt?: Prisma.InputJsonValue | undefined;

  @Field(() => GraphQLScalars.JSONResolver, {
    nullable: true
  })
  gte?: Prisma.InputJsonValue | undefined;

  @Field(() => GraphQLScalars.JSONResolver, {
    nullable: true
  })
  not?: Prisma.InputJsonValue | undefined;
}
"
`;

exports[`inputs should properly generate input type classes for filtering scalar fields: NestedBoolFilter 1`] = `
"import { Args, ArgsType, Context, Field, Float, ID, Info, InputType, Int, Mutation, ObjectType, Parent, Query, ResolveField, Resolver, registerEnumType } from \\"@nestjs/graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { Prisma } from \\"../../../../helpers/prisma-client-mock\\";
import { DecimalJSScalar } from \\"../../scalars\\";

@InputType(\\"NestedBoolFilter\\", {})
export class NestedBoolFilter {
  @Field(() => Boolean, {
    nullable: true
  })
  equals?: boolean | undefined;

  @Field(() => NestedBoolFilter, {
    nullable: true
  })
  not?: NestedBoolFilter | undefined;
}
"
`;

exports[`inputs should properly generate input type classes for filtering scalar fields: NestedDateTimeFilter 1`] = `
"import { Args, ArgsType, Context, Field, Float, ID, Info, InputType, Int, Mutation, ObjectType, Parent, Query, ResolveField, Resolver, registerEnumType } from \\"@nestjs/graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { Prisma } from \\"../../../../helpers/prisma-client-mock\\";
import { DecimalJSScalar } from \\"../../scalars\\";

@InputType(\\"NestedDateTimeFilter\\", {})
export class NestedDateTimeFilter {
  @Field(() => Date, {
    nullable: true
  })
  equals?: Date | undefined;

  @Field(() => [Date], {
    nullable: true
  })
  in?: Date[] | undefined;

  @Field(() => [Date], {
    nullable: true
  })
  notIn?: Date[] | undefined;

  @Field(() => Date, {
    nullable: true
  })
  lt?: Date | undefined;

  @Field(() => Date, {
    nullable: true
  })
  lte?: Date | undefined;

  @Field(() => Date, {
    nullable: true
  })
  gt?: Date | undefined;

  @Field(() => Date, {
    nullable: true
  })
  gte?: Date | undefined;

  @Field(() => NestedDateTimeFilter, {
    nullable: true
  })
  not?: NestedDateTimeFilter | undefined;
}
"
`;

exports[`inputs should properly generate input type classes for filtering scalar fields: NestedFloatFilter 1`] = `
"import { Args, ArgsType, Context, Field, Float, ID, Info, InputType, Int, Mutation, ObjectType, Parent, Query, ResolveField, Resolver, registerEnumType } from \\"@nestjs/graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { Prisma } from \\"../../../../helpers/prisma-client-mock\\";
import { DecimalJSScalar } from \\"../../scalars\\";

@InputType(\\"NestedFloatFilter\\", {})
export class NestedFloatFilter {
  @Field(() => Float, {
    nullable: true
  })
  equals?: number | undefined;

  @Field(() => [Float], {
    nullable: true
  })
  in?: number[] | undefined;

  @Field(() => [Float], {
    nullable: true
  })
  notIn?: number[] | undefined;

  @Field(() => Float, {
    nullable: true
  })
  lt?: number | undefined;

  @Field(() => Float, {
    nullable: true
  })
  lte?: number | undefined;

  @Field(() => Float, {
    nullable: true
  })
  gt?: number | undefined;

  @Field(() => Float, {
    nullable: true
  })
  gte?: number | undefined;

  @Field(() => NestedFloatFilter, {
    nullable: true
  })
  not?: NestedFloatFilter | undefined;
}
"
`;

exports[`inputs should properly generate input type classes for filtering scalar fields: NestedIntFilter 1`] = `
"import { Args, ArgsType, Context, Field, Float, ID, Info, InputType, Int, Mutation, ObjectType, Parent, Query, ResolveField, Resolver, registerEnumType } from \\"@nestjs/graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { Prisma } from \\"../../../../helpers/prisma-client-mock\\";
import { DecimalJSScalar } from \\"../../scalars\\";

@InputType(\\"NestedIntFilter\\", {})
export class NestedIntFilter {
  @Field(() => Int, {
    nullable: true
  })
  equals?: number | undefined;

  @Field(() => [Int], {
    nullable: true
  })
  in?: number[] | undefined;

  @Field(() => [Int], {
    nullable: true
  })
  notIn?: number[] | undefined;

  @Field(() => Int, {
    nullable: true
  })
  lt?: number | undefined;

  @Field(() => Int, {
    nullable: true
  })
  lte?: number | undefined;

  @Field(() => Int, {
    nullable: true
  })
  gt?: number | undefined;

  @Field(() => Int, {
    nullable: true
  })
  gte?: number | undefined;

  @Field(() => NestedIntFilter, {
    nullable: true
  })
  not?: NestedIntFilter | undefined;
}
"
`;

exports[`inputs should properly generate input type classes for filtering scalar fields: NestedJsonFilter 1`] = `
"import { Args, ArgsType, Context, Field, Float, ID, Info, InputType, Int, Mutation, ObjectType, Parent, Query, ResolveField, Resolver, registerEnumType } from \\"@nestjs/graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { Prisma } from \\"../../../../helpers/prisma-client-mock\\";
import { DecimalJSScalar } from \\"../../scalars\\";
import { QueryMode } from \\"../../enums/QueryMode\\";

@InputType(\\"NestedJsonFilter\\", {})
export class NestedJsonFilter {
  @Field(() => GraphQLScalars.JSONResolver, {
    nullable: true
  })
  equals?: Prisma.InputJsonValue | undefined;

  @Field(() => [String], {
    nullable: true
  })
  path?: string[] | undefined;

  @Field(() => QueryMode, {
    nullable: true
  })
  mode?: \\"default\\" | \\"insensitive\\" | undefined;

  @Field(() => String, {
    nullable: true
  })
  string_contains?: string | undefined;

  @Field(() => String, {
    nullable: true
  })
  string_starts_with?: string | undefined;

  @Field(() => String, {
    nullable: true
  })
  string_ends_with?: string | undefined;

  @Field(() => GraphQLScalars.JSONResolver, {
    nullable: true
  })
  array_starts_with?: Prisma.InputJsonValue | undefined;

  @Field(() => GraphQLScalars.JSONResolver, {
    nullable: true
  })
  array_ends_with?: Prisma.InputJsonValue | undefined;

  @Field(() => GraphQLScalars.JSONResolver, {
    nullable: true
  })
  array_contains?: Prisma.InputJsonValue | undefined;

  @Field(() => GraphQLScalars.JSONResolver, {
    nullable: true
  })
  lt?: Prisma.InputJsonValue | undefined;

  @Field(() => GraphQLScalars.JSONResolver, {
    nullable: true
  })
  lte?: Prisma.InputJsonValue | undefined;

  @Field(() => GraphQLScalars.JSONResolver, {
    nullable: true
  })
  gt?: Prisma.InputJsonValue | undefined;

  @Field(() => GraphQLScalars.JSONResolver, {
    nullable: true
  })
  gte?: Prisma.InputJsonValue | undefined;

  @Field(() => GraphQLScalars.JSONResolver, {
    nullable: true
  })
  not?: Prisma.InputJsonValue | undefined;
}
"
`;

exports[`inputs should properly generate input type classes for filtering scalar fields: NestedStringNullableFilter 1`] = `
"import { Args, ArgsType, Context, Field, Float, ID, Info, InputType, Int, Mutation, ObjectType, Parent, Query, ResolveField, Resolver, registerEnumType } from \\"@nestjs/graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { Prisma } from \\"../../../../helpers/prisma-client-mock\\";
import { DecimalJSScalar } from \\"../../scalars\\";

@InputType(\\"NestedStringNullableFilter\\", {})
export class NestedStringNullableFilter {
  @Field(() => String, {
    nullable: true
  })
  equals?: string | undefined;

  @Field(() => [String], {
    nullable: true
  })
  in?: string[] | undefined;

  @Field(() => [String], {
    nullable: true
  })
  notIn?: string[] | undefined;

  @Field(() => String, {
    nullable: true
  })
  lt?: string | undefined;

  @Field(() => String, {
    nullable: true
  })
  lte?: string | undefined;

  @Field(() => String, {
    nullable: true
  })
  gt?: string | undefined;

  @Field(() => String, {
    nullable: true
  })
  gte?: string | undefined;

  @Field(() => String, {
    nullable: true
  })
  contains?: string | undefined;

  @Field(() => String, {
    nullable: true
  })
  startsWith?: string | undefined;

  @Field(() => String, {
    nullable: true
  })
  endsWith?: string | undefined;

  @Field(() => NestedStringNullableFilter, {
    nullable: true
  })
  not?: NestedStringNullableFilter | undefined;
}
"
`;

exports[`inputs should properly generate input type classes for filtering scalar fields: StringFilter 1`] = `
"import { Args, ArgsType, Context, Field, Float, ID, Info, InputType, Int, Mutation, ObjectType, Parent, Query, ResolveField, Resolver, registerEnumType } from \\"@nestjs/graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { Prisma } from \\"../../../../helpers/prisma-client-mock\\";
import { DecimalJSScalar } from \\"../../scalars\\";
import { NestedStringFilter } from \\"../inputs\\";
import { QueryMode } from \\"../../enums/QueryMode\\";

@InputType(\\"StringFilter\\", {})
export class StringFilter {
  @Field(() => String, {
    nullable: true
  })
  equals?: string | undefined;

  @Field(() => [String], {
    nullable: true
  })
  in?: string[] | undefined;

  @Field(() => [String], {
    nullable: true
  })
  notIn?: string[] | undefined;

  @Field(() => String, {
    nullable: true
  })
  lt?: string | undefined;

  @Field(() => String, {
    nullable: true
  })
  lte?: string | undefined;

  @Field(() => String, {
    nullable: true
  })
  gt?: string | undefined;

  @Field(() => String, {
    nullable: true
  })
  gte?: string | undefined;

  @Field(() => String, {
    nullable: true
  })
  contains?: string | undefined;

  @Field(() => String, {
    nullable: true
  })
  startsWith?: string | undefined;

  @Field(() => String, {
    nullable: true
  })
  endsWith?: string | undefined;

  @Field(() => QueryMode, {
    nullable: true
  })
  mode?: \\"default\\" | \\"insensitive\\" | undefined;

  @Field(() => NestedStringFilter, {
    nullable: true
  })
  not?: NestedStringFilter | undefined;
}
"
`;

exports[`inputs should properly generate input type classes for filtering scalar fields: StringNullableFilter 1`] = `
"import { Args, ArgsType, Context, Field, Float, ID, Info, InputType, Int, Mutation, ObjectType, Parent, Query, ResolveField, Resolver, registerEnumType } from \\"@nestjs/graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { Prisma } from \\"../../../../helpers/prisma-client-mock\\";
import { DecimalJSScalar } from \\"../../scalars\\";
import { NestedStringNullableFilter } from \\"../inputs\\";
import { QueryMode } from \\"../../enums/QueryMode\\";

@InputType(\\"StringNullableFilter\\", {})
export class StringNullableFilter {
  @Field(() => String, {
    nullable: true
  })
  equals?: string | undefined;

  @Field(() => [String], {
    nullable: true
  })
  in?: string[] | undefined;

  @Field(() => [String], {
    nullable: true
  })
  notIn?: string[] | undefined;

  @Field(() => String, {
    nullable: true
  })
  lt?: string | undefined;

  @Field(() => String, {
    nullable: true
  })
  lte?: string | undefined;

  @Field(() => String, {
    nullable: true
  })
  gt?: string | undefined;

  @Field(() => String, {
    nullable: true
  })
  gte?: string | undefined;

  @Field(() => String, {
    nullable: true
  })
  contains?: string | undefined;

  @Field(() => String, {
    nullable: true
  })
  startsWith?: string | undefined;

  @Field(() => String, {
    nullable: true
  })
  endsWith?: string | undefined;

  @Field(() => QueryMode, {
    nullable: true
  })
  mode?: \\"default\\" | \\"insensitive\\" | undefined;

  @Field(() => NestedStringNullableFilter, {
    nullable: true
  })
  not?: NestedStringNullableFilter | undefined;
}
"
`;

exports[`inputs should properly generate input type classes for filtering scalar fields: StringNullableListFilter 1`] = `
"import { Args, ArgsType, Context, Field, Float, ID, Info, InputType, Int, Mutation, ObjectType, Parent, Query, ResolveField, Resolver, registerEnumType } from \\"@nestjs/graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { Prisma } from \\"../../../../helpers/prisma-client-mock\\";
import { DecimalJSScalar } from \\"../../scalars\\";

@InputType(\\"StringNullableListFilter\\", {})
export class StringNullableListFilter {
  @Field(() => [String], {
    nullable: true
  })
  equals?: string[] | undefined;

  @Field(() => String, {
    nullable: true
  })
  has?: string | undefined;

  @Field(() => [String], {
    nullable: true
  })
  hasEvery?: string[] | undefined;

  @Field(() => [String], {
    nullable: true
  })
  hasSome?: string[] | undefined;

  @Field(() => Boolean, {
    nullable: true
  })
  isEmpty?: boolean | undefined;
}
"
`;

exports[`inputs should properly generate input type classes for filtering scalar fields: index 1`] = `
"export * from \\"./BoolFieldUpdateOperationsInput\\";
export * from \\"./BoolFilter\\";
export * from \\"./BoolNullableFilter\\";
export * from \\"./BoolNullableWithAggregatesFilter\\";
export * from \\"./BoolWithAggregatesFilter\\";
export * from \\"./DateTimeFieldUpdateOperationsInput\\";
export * from \\"./DateTimeFilter\\";
export * from \\"./DateTimeNullableFilter\\";
export * from \\"./DateTimeNullableWithAggregatesFilter\\";
export * from \\"./DateTimeWithAggregatesFilter\\";
export * from \\"./FloatFieldUpdateOperationsInput\\";
export * from \\"./FloatFilter\\";
export * from \\"./FloatNullableFilter\\";
export * from \\"./FloatNullableWithAggregatesFilter\\";
export * from \\"./FloatWithAggregatesFilter\\";
export * from \\"./IntFieldUpdateOperationsInput\\";
export * from \\"./IntFilter\\";
export * from \\"./IntNullableFilter\\";
export * from \\"./IntNullableListFilter\\";
export * from \\"./IntNullableWithAggregatesFilter\\";
export * from \\"./IntWithAggregatesFilter\\";
export * from \\"./JsonFilter\\";
export * from \\"./JsonNullableFilter\\";
export * from \\"./JsonNullableWithAggregatesFilter\\";
export * from \\"./JsonWithAggregatesFilter\\";
export * from \\"./NestedBoolFilter\\";
export * from \\"./NestedBoolNullableFilter\\";
export * from \\"./NestedBoolNullableWithAggregatesFilter\\";
export * from \\"./NestedBoolWithAggregatesFilter\\";
export * from \\"./NestedDateTimeFilter\\";
export * from \\"./NestedDateTimeNullableFilter\\";
export * from \\"./NestedDateTimeNullableWithAggregatesFilter\\";
export * from \\"./NestedDateTimeWithAggregatesFilter\\";
export * from \\"./NestedFloatFilter\\";
export * from \\"./NestedFloatNullableFilter\\";
export * from \\"./NestedFloatNullableWithAggregatesFilter\\";
export * from \\"./NestedFloatWithAggregatesFilter\\";
export * from \\"./NestedIntFilter\\";
export * from \\"./NestedIntNullableFilter\\";
export * from \\"./NestedIntNullableWithAggregatesFilter\\";
export * from \\"./NestedIntWithAggregatesFilter\\";
export * from \\"./NestedJsonFilter\\";
export * from \\"./NestedJsonNullableFilter\\";
export * from \\"./NestedStringFilter\\";
export * from \\"./NestedStringNullableFilter\\";
export * from \\"./NestedStringNullableWithAggregatesFilter\\";
export * from \\"./NestedStringWithAggregatesFilter\\";
export * from \\"./NullableBoolFieldUpdateOperationsInput\\";
export * from \\"./NullableDateTimeFieldUpdateOperationsInput\\";
export * from \\"./NullableFloatFieldUpdateOperationsInput\\";
export * from \\"./NullableIntFieldUpdateOperationsInput\\";
export * from \\"./NullableStringFieldUpdateOperationsInput\\";
export * from \\"./SampleModelAvgOrderByAggregateInput\\";
export * from \\"./SampleModelCountOrderByAggregateInput\\";
export * from \\"./SampleModelCreateInput\\";
export * from \\"./SampleModelCreateManyInput\\";
export * from \\"./SampleModelCreateintArrayFieldInput\\";
export * from \\"./SampleModelCreatestringArrayFieldInput\\";
export * from \\"./SampleModelMaxOrderByAggregateInput\\";
export * from \\"./SampleModelMinOrderByAggregateInput\\";
export * from \\"./SampleModelOrderByWithAggregationInput\\";
export * from \\"./SampleModelOrderByWithRelationInput\\";
export * from \\"./SampleModelScalarWhereWithAggregatesInput\\";
export * from \\"./SampleModelSumOrderByAggregateInput\\";
export * from \\"./SampleModelUpdateInput\\";
export * from \\"./SampleModelUpdateManyMutationInput\\";
export * from \\"./SampleModelUpdateintArrayFieldInput\\";
export * from \\"./SampleModelUpdatestringArrayFieldInput\\";
export * from \\"./SampleModelWhereInput\\";
export * from \\"./SampleModelWhereUniqueInput\\";
export * from \\"./SortOrderInput\\";
export * from \\"./StringFieldUpdateOperationsInput\\";
export * from \\"./StringFilter\\";
export * from \\"./StringNullableFilter\\";
export * from \\"./StringNullableListFilter\\";
export * from \\"./StringNullableWithAggregatesFilter\\";
export * from \\"./StringWithAggregatesFilter\\";
"
`;

exports[`inputs should properly generate input type classes for inserting many entities: FirstModelCreateManyInput 1`] = `
"import { Args, ArgsType, Context, Field, Float, ID, Info, InputType, Int, Mutation, ObjectType, Parent, Query, ResolveField, Resolver, registerEnumType } from \\"@nestjs/graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { Prisma } from \\"../../../../helpers/prisma-client-mock\\";
import { DecimalJSScalar } from \\"../../scalars\\";

@InputType(\\"FirstModelCreateManyInput\\", {})
export class FirstModelCreateManyInput {
  @Field(() => Int, {
    nullable: true
  })
  idField?: number | undefined;

  @Field(() => String, {
    nullable: false
  })
  uniqueStringField!: string;

  @Field(() => Float, {
    nullable: false
  })
  floatField!: number;
}
"
`;

exports[`inputs should properly generate input type classes for inserting many entities: SecondModelCreateManyFirstModelFieldInput 1`] = `
"import { Args, ArgsType, Context, Field, Float, ID, Info, InputType, Int, Mutation, ObjectType, Parent, Query, ResolveField, Resolver, registerEnumType } from \\"@nestjs/graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { Prisma } from \\"../../../../helpers/prisma-client-mock\\";
import { DecimalJSScalar } from \\"../../scalars\\";

@InputType(\\"SecondModelCreateManyFirstModelFieldInput\\", {})
export class SecondModelCreateManyFirstModelFieldInput {
  @Field(() => Int, {
    nullable: true
  })
  idField?: number | undefined;

  @Field(() => String, {
    nullable: false
  })
  uniqueStringField!: string;

  @Field(() => Float, {
    nullable: false
  })
  floatField!: number;
}
"
`;

exports[`inputs should properly generate input type classes for inserting many entities: SecondModelCreateManyFirstModelFieldInputEnvelope 1`] = `
"import { Args, ArgsType, Context, Field, Float, ID, Info, InputType, Int, Mutation, ObjectType, Parent, Query, ResolveField, Resolver, registerEnumType } from \\"@nestjs/graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { Prisma } from \\"../../../../helpers/prisma-client-mock\\";
import { DecimalJSScalar } from \\"../../scalars\\";
import { SecondModelCreateManyFirstModelFieldInput } from \\"../inputs\\";

@InputType(\\"SecondModelCreateManyFirstModelFieldInputEnvelope\\", {})
export class SecondModelCreateManyFirstModelFieldInputEnvelope {
  @Field(() => [SecondModelCreateManyFirstModelFieldInput], {
    nullable: false
  })
  data!: SecondModelCreateManyFirstModelFieldInput[];

  @Field(() => Boolean, {
    nullable: true
  })
  skipDuplicates?: boolean | undefined;
}
"
`;

exports[`inputs should properly generate input type classes for inserting many entities: SecondModelCreateManyInput 1`] = `
"import { Args, ArgsType, Context, Field, Float, ID, Info, InputType, Int, Mutation, ObjectType, Parent, Query, ResolveField, Resolver, registerEnumType } from \\"@nestjs/graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { Prisma } from \\"../../../../helpers/prisma-client-mock\\";
import { DecimalJSScalar } from \\"../../scalars\\";

@InputType(\\"SecondModelCreateManyInput\\", {})
export class SecondModelCreateManyInput {
  @Field(() => Int, {
    nullable: true
  })
  idField?: number | undefined;

  @Field(() => String, {
    nullable: false
  })
  uniqueStringField!: string;

  @Field(() => Float, {
    nullable: false
  })
  floatField!: number;

  @Field(() => Int, {
    nullable: false
  })
  firstModelFieldId!: number;
}
"
`;

exports[`inputs should properly generate input type classes for inserting many entities: index 1`] = `
"export * from \\"./FirstModelAvgOrderByAggregateInput\\";
export * from \\"./FirstModelCountOrderByAggregateInput\\";
export * from \\"./FirstModelCreateInput\\";
export * from \\"./FirstModelCreateManyInput\\";
export * from \\"./FirstModelCreateNestedOneWithoutSecondModelsFieldInput\\";
export * from \\"./FirstModelCreateOrConnectWithoutSecondModelsFieldInput\\";
export * from \\"./FirstModelCreateWithoutSecondModelsFieldInput\\";
export * from \\"./FirstModelMaxOrderByAggregateInput\\";
export * from \\"./FirstModelMinOrderByAggregateInput\\";
export * from \\"./FirstModelOrderByWithAggregationInput\\";
export * from \\"./FirstModelOrderByWithRelationInput\\";
export * from \\"./FirstModelScalarRelationFilter\\";
export * from \\"./FirstModelScalarWhereWithAggregatesInput\\";
export * from \\"./FirstModelSumOrderByAggregateInput\\";
export * from \\"./FirstModelUpdateInput\\";
export * from \\"./FirstModelUpdateManyMutationInput\\";
export * from \\"./FirstModelUpdateOneRequiredWithoutSecondModelsFieldNestedInput\\";
export * from \\"./FirstModelUpdateToOneWithWhereWithoutSecondModelsFieldInput\\";
export * from \\"./FirstModelUpdateWithoutSecondModelsFieldInput\\";
export * from \\"./FirstModelUpsertWithoutSecondModelsFieldInput\\";
export * from \\"./FirstModelWhereInput\\";
export * from \\"./FirstModelWhereUniqueInput\\";
export * from \\"./FloatFieldUpdateOperationsInput\\";
export * from \\"./FloatFilter\\";
export * from \\"./FloatWithAggregatesFilter\\";
export * from \\"./IntFieldUpdateOperationsInput\\";
export * from \\"./IntFilter\\";
export * from \\"./IntWithAggregatesFilter\\";
export * from \\"./NestedFloatFilter\\";
export * from \\"./NestedFloatWithAggregatesFilter\\";
export * from \\"./NestedIntFilter\\";
export * from \\"./NestedIntWithAggregatesFilter\\";
export * from \\"./NestedStringFilter\\";
export * from \\"./NestedStringWithAggregatesFilter\\";
export * from \\"./SecondModelAvgOrderByAggregateInput\\";
export * from \\"./SecondModelCountOrderByAggregateInput\\";
export * from \\"./SecondModelCreateInput\\";
export * from \\"./SecondModelCreateManyFirstModelFieldInput\\";
export * from \\"./SecondModelCreateManyFirstModelFieldInputEnvelope\\";
export * from \\"./SecondModelCreateManyInput\\";
export * from \\"./SecondModelCreateNestedManyWithoutFirstModelFieldInput\\";
export * from \\"./SecondModelCreateOrConnectWithoutFirstModelFieldInput\\";
export * from \\"./SecondModelCreateWithoutFirstModelFieldInput\\";
export * from \\"./SecondModelListRelationFilter\\";
export * from \\"./SecondModelMaxOrderByAggregateInput\\";
export * from \\"./SecondModelMinOrderByAggregateInput\\";
export * from \\"./SecondModelOrderByRelationAggregateInput\\";
export * from \\"./SecondModelOrderByWithAggregationInput\\";
export * from \\"./SecondModelOrderByWithRelationInput\\";
export * from \\"./SecondModelScalarWhereInput\\";
export * from \\"./SecondModelScalarWhereWithAggregatesInput\\";
export * from \\"./SecondModelSumOrderByAggregateInput\\";
export * from \\"./SecondModelUpdateInput\\";
export * from \\"./SecondModelUpdateManyMutationInput\\";
export * from \\"./SecondModelUpdateManyWithWhereWithoutFirstModelFieldInput\\";
export * from \\"./SecondModelUpdateManyWithoutFirstModelFieldNestedInput\\";
export * from \\"./SecondModelUpdateWithWhereUniqueWithoutFirstModelFieldInput\\";
export * from \\"./SecondModelUpdateWithoutFirstModelFieldInput\\";
export * from \\"./SecondModelUpsertWithWhereUniqueWithoutFirstModelFieldInput\\";
export * from \\"./SecondModelWhereInput\\";
export * from \\"./SecondModelWhereUniqueInput\\";
export * from \\"./StringFieldUpdateOperationsInput\\";
export * from \\"./StringFilter\\";
export * from \\"./StringWithAggregatesFilter\\";
"
`;

exports[`inputs should properly generate input type classes for model with composite unique index: DirectorFirstNameLastNameCompoundUniqueInput 1`] = `
"import { Args, ArgsType, Context, Field, Float, ID, Info, InputType, Int, Mutation, ObjectType, Parent, Query, ResolveField, Resolver, registerEnumType } from \\"@nestjs/graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { Prisma } from \\"../../../../helpers/prisma-client-mock\\";
import { DecimalJSScalar } from \\"../../scalars\\";

@InputType(\\"DirectorFirstNameLastNameCompoundUniqueInput\\", {})
export class DirectorFirstNameLastNameCompoundUniqueInput {
  @Field(() => String, {
    nullable: false
  })
  firstName!: string;

  @Field(() => String, {
    nullable: false
  })
  lastName!: string;
}
"
`;

exports[`inputs should properly generate input type classes for model with composite unique index: DirectorOrderByWithRelationInput 1`] = `
"import { Args, ArgsType, Context, Field, Float, ID, Info, InputType, Int, Mutation, ObjectType, Parent, Query, ResolveField, Resolver, registerEnumType } from \\"@nestjs/graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { Prisma } from \\"../../../../helpers/prisma-client-mock\\";
import { DecimalJSScalar } from \\"../../scalars\\";
import { MovieOrderByRelationAggregateInput } from \\"../inputs\\";
import { SortOrder } from \\"../../enums/SortOrder\\";

@InputType(\\"DirectorOrderByWithRelationInput\\", {})
export class DirectorOrderByWithRelationInput {
  @Field(() => SortOrder, {
    nullable: true
  })
  firstName?: \\"asc\\" | \\"desc\\" | undefined;

  @Field(() => SortOrder, {
    nullable: true
  })
  lastName?: \\"asc\\" | \\"desc\\" | undefined;

  @Field(() => SortOrder, {
    nullable: true
  })
  age?: \\"asc\\" | \\"desc\\" | undefined;

  @Field(() => MovieOrderByRelationAggregateInput, {
    nullable: true
  })
  movies?: MovieOrderByRelationAggregateInput | undefined;
}
"
`;

exports[`inputs should properly generate input type classes for model with composite unique index: DirectorWhereInput 1`] = `
"import { Args, ArgsType, Context, Field, Float, ID, Info, InputType, Int, Mutation, ObjectType, Parent, Query, ResolveField, Resolver, registerEnumType } from \\"@nestjs/graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { Prisma } from \\"../../../../helpers/prisma-client-mock\\";
import { DecimalJSScalar } from \\"../../scalars\\";
import { IntFilter, MovieListRelationFilter, StringFilter } from \\"../inputs\\";

@InputType(\\"DirectorWhereInput\\", {})
export class DirectorWhereInput {
  @Field(() => [DirectorWhereInput], {
    nullable: true
  })
  AND?: DirectorWhereInput[] | undefined;

  @Field(() => [DirectorWhereInput], {
    nullable: true
  })
  OR?: DirectorWhereInput[] | undefined;

  @Field(() => [DirectorWhereInput], {
    nullable: true
  })
  NOT?: DirectorWhereInput[] | undefined;

  @Field(() => StringFilter, {
    nullable: true
  })
  firstName?: StringFilter | undefined;

  @Field(() => StringFilter, {
    nullable: true
  })
  lastName?: StringFilter | undefined;

  @Field(() => IntFilter, {
    nullable: true
  })
  age?: IntFilter | undefined;

  @Field(() => MovieListRelationFilter, {
    nullable: true
  })
  movies?: MovieListRelationFilter | undefined;
}
"
`;

exports[`inputs should properly generate input type classes for model with composite unique index: DirectorWhereUniqueInput 1`] = `
"import { Args, ArgsType, Context, Field, Float, ID, Info, InputType, Int, Mutation, ObjectType, Parent, Query, ResolveField, Resolver, registerEnumType } from \\"@nestjs/graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { Prisma } from \\"../../../../helpers/prisma-client-mock\\";
import { DecimalJSScalar } from \\"../../scalars\\";
import { DirectorFirstNameLastNameCompoundUniqueInput, DirectorWhereInput, IntFilter, MovieListRelationFilter, StringFilter } from \\"../inputs\\";

@InputType(\\"DirectorWhereUniqueInput\\", {})
export class DirectorWhereUniqueInput {
  @Field(() => DirectorFirstNameLastNameCompoundUniqueInput, {
    nullable: true
  })
  firstName_lastName?: DirectorFirstNameLastNameCompoundUniqueInput | undefined;

  @Field(() => [DirectorWhereInput], {
    nullable: true
  })
  AND?: DirectorWhereInput[] | undefined;

  @Field(() => [DirectorWhereInput], {
    nullable: true
  })
  OR?: DirectorWhereInput[] | undefined;

  @Field(() => [DirectorWhereInput], {
    nullable: true
  })
  NOT?: DirectorWhereInput[] | undefined;

  @Field(() => StringFilter, {
    nullable: true
  })
  firstName?: StringFilter | undefined;

  @Field(() => StringFilter, {
    nullable: true
  })
  lastName?: StringFilter | undefined;

  @Field(() => IntFilter, {
    nullable: true
  })
  age?: IntFilter | undefined;

  @Field(() => MovieListRelationFilter, {
    nullable: true
  })
  movies?: MovieListRelationFilter | undefined;
}
"
`;

exports[`inputs should properly generate input type classes for model with composite unique index: index 1`] = `
"export * from \\"./DirectorAvgOrderByAggregateInput\\";
export * from \\"./DirectorCountOrderByAggregateInput\\";
export * from \\"./DirectorCreateInput\\";
export * from \\"./DirectorCreateManyInput\\";
export * from \\"./DirectorCreateNestedOneWithoutMoviesInput\\";
export * from \\"./DirectorCreateOrConnectWithoutMoviesInput\\";
export * from \\"./DirectorCreateWithoutMoviesInput\\";
export * from \\"./DirectorFirstNameLastNameCompoundUniqueInput\\";
export * from \\"./DirectorMaxOrderByAggregateInput\\";
export * from \\"./DirectorMinOrderByAggregateInput\\";
export * from \\"./DirectorOrderByWithAggregationInput\\";
export * from \\"./DirectorOrderByWithRelationInput\\";
export * from \\"./DirectorScalarRelationFilter\\";
export * from \\"./DirectorScalarWhereWithAggregatesInput\\";
export * from \\"./DirectorSumOrderByAggregateInput\\";
export * from \\"./DirectorUpdateInput\\";
export * from \\"./DirectorUpdateManyMutationInput\\";
export * from \\"./DirectorUpdateOneRequiredWithoutMoviesNestedInput\\";
export * from \\"./DirectorUpdateToOneWithWhereWithoutMoviesInput\\";
export * from \\"./DirectorUpdateWithoutMoviesInput\\";
export * from \\"./DirectorUpsertWithoutMoviesInput\\";
export * from \\"./DirectorWhereInput\\";
export * from \\"./DirectorWhereUniqueInput\\";
export * from \\"./FloatFieldUpdateOperationsInput\\";
export * from \\"./FloatFilter\\";
export * from \\"./FloatWithAggregatesFilter\\";
export * from \\"./IntFieldUpdateOperationsInput\\";
export * from \\"./IntFilter\\";
export * from \\"./IntWithAggregatesFilter\\";
export * from \\"./MovieAvgOrderByAggregateInput\\";
export * from \\"./MovieCountOrderByAggregateInput\\";
export * from \\"./MovieCreateInput\\";
export * from \\"./MovieCreateManyDirectorInput\\";
export * from \\"./MovieCreateManyDirectorInputEnvelope\\";
export * from \\"./MovieCreateManyInput\\";
export * from \\"./MovieCreateNestedManyWithoutDirectorInput\\";
export * from \\"./MovieCreateOrConnectWithoutDirectorInput\\";
export * from \\"./MovieCreateWithoutDirectorInput\\";
export * from \\"./MovieDirectorFirstNameDirectorLastNameTitleCompoundUniqueInput\\";
export * from \\"./MovieListRelationFilter\\";
export * from \\"./MovieMaxOrderByAggregateInput\\";
export * from \\"./MovieMinOrderByAggregateInput\\";
export * from \\"./MovieOrderByRelationAggregateInput\\";
export * from \\"./MovieOrderByWithAggregationInput\\";
export * from \\"./MovieOrderByWithRelationInput\\";
export * from \\"./MovieScalarWhereInput\\";
export * from \\"./MovieScalarWhereWithAggregatesInput\\";
export * from \\"./MovieSumOrderByAggregateInput\\";
export * from \\"./MovieUpdateInput\\";
export * from \\"./MovieUpdateManyMutationInput\\";
export * from \\"./MovieUpdateManyWithWhereWithoutDirectorInput\\";
export * from \\"./MovieUpdateManyWithoutDirectorNestedInput\\";
export * from \\"./MovieUpdateWithWhereUniqueWithoutDirectorInput\\";
export * from \\"./MovieUpdateWithoutDirectorInput\\";
export * from \\"./MovieUpsertWithWhereUniqueWithoutDirectorInput\\";
export * from \\"./MovieWhereInput\\";
export * from \\"./MovieWhereUniqueInput\\";
export * from \\"./NestedFloatFilter\\";
export * from \\"./NestedFloatWithAggregatesFilter\\";
export * from \\"./NestedIntFilter\\";
export * from \\"./NestedIntWithAggregatesFilter\\";
export * from \\"./NestedStringFilter\\";
export * from \\"./NestedStringWithAggregatesFilter\\";
export * from \\"./StringFieldUpdateOperationsInput\\";
export * from \\"./StringFilter\\";
export * from \\"./StringWithAggregatesFilter\\";
"
`;

exports[`inputs should properly generate input type classes for model with id keys with relation: MovieDirectorFirstNameDirectorLastNameTitleCompoundUniqueInput 1`] = `
"import { Args, ArgsType, Context, Field, Float, ID, Info, InputType, Int, Mutation, ObjectType, Parent, Query, ResolveField, Resolver, registerEnumType } from \\"@nestjs/graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { Prisma } from \\"../../../../helpers/prisma-client-mock\\";
import { DecimalJSScalar } from \\"../../scalars\\";

@InputType(\\"MovieDirectorFirstNameDirectorLastNameTitleCompoundUniqueInput\\", {})
export class MovieDirectorFirstNameDirectorLastNameTitleCompoundUniqueInput {
  @Field(() => String, {
    nullable: false
  })
  directorFirstName!: string;

  @Field(() => String, {
    nullable: false
  })
  directorLastName!: string;

  @Field(() => String, {
    nullable: false
  })
  title!: string;
}
"
`;

exports[`inputs should properly generate input type classes for model with id keys with relation: MovieOrderByWithRelationInput 1`] = `
"import { Args, ArgsType, Context, Field, Float, ID, Info, InputType, Int, Mutation, ObjectType, Parent, Query, ResolveField, Resolver, registerEnumType } from \\"@nestjs/graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { Prisma } from \\"../../../../helpers/prisma-client-mock\\";
import { DecimalJSScalar } from \\"../../scalars\\";
import { DirectorOrderByWithRelationInput } from \\"../inputs\\";
import { SortOrder } from \\"../../enums/SortOrder\\";

@InputType(\\"MovieOrderByWithRelationInput\\", {})
export class MovieOrderByWithRelationInput {
  @Field(() => SortOrder, {
    nullable: true
  })
  directorFirstName?: \\"asc\\" | \\"desc\\" | undefined;

  @Field(() => SortOrder, {
    nullable: true
  })
  directorLastName?: \\"asc\\" | \\"desc\\" | undefined;

  @Field(() => SortOrder, {
    nullable: true
  })
  title?: \\"asc\\" | \\"desc\\" | undefined;

  @Field(() => SortOrder, {
    nullable: true
  })
  rating?: \\"asc\\" | \\"desc\\" | undefined;

  @Field(() => DirectorOrderByWithRelationInput, {
    nullable: true
  })
  director?: DirectorOrderByWithRelationInput | undefined;
}
"
`;

exports[`inputs should properly generate input type classes for model with id keys with relation: MovieScalarWhereInput 1`] = `
"import { Args, ArgsType, Context, Field, Float, ID, Info, InputType, Int, Mutation, ObjectType, Parent, Query, ResolveField, Resolver, registerEnumType } from \\"@nestjs/graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { Prisma } from \\"../../../../helpers/prisma-client-mock\\";
import { DecimalJSScalar } from \\"../../scalars\\";
import { FloatFilter, StringFilter } from \\"../inputs\\";

@InputType(\\"MovieScalarWhereInput\\", {})
export class MovieScalarWhereInput {
  @Field(() => [MovieScalarWhereInput], {
    nullable: true
  })
  AND?: MovieScalarWhereInput[] | undefined;

  @Field(() => [MovieScalarWhereInput], {
    nullable: true
  })
  OR?: MovieScalarWhereInput[] | undefined;

  @Field(() => [MovieScalarWhereInput], {
    nullable: true
  })
  NOT?: MovieScalarWhereInput[] | undefined;

  @Field(() => StringFilter, {
    nullable: true
  })
  directorFirstName?: StringFilter | undefined;

  @Field(() => StringFilter, {
    nullable: true
  })
  directorLastName?: StringFilter | undefined;

  @Field(() => StringFilter, {
    nullable: true
  })
  title?: StringFilter | undefined;

  @Field(() => FloatFilter, {
    nullable: true
  })
  rating?: FloatFilter | undefined;
}
"
`;

exports[`inputs should properly generate input type classes for model with id keys with relation: MovieWhereInput 1`] = `
"import { Args, ArgsType, Context, Field, Float, ID, Info, InputType, Int, Mutation, ObjectType, Parent, Query, ResolveField, Resolver, registerEnumType } from \\"@nestjs/graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { Prisma } from \\"../../../../helpers/prisma-client-mock\\";
import { DecimalJSScalar } from \\"../../scalars\\";
import { DirectorScalarRelationFilter, FloatFilter, StringFilter } from \\"../inputs\\";

@InputType(\\"MovieWhereInput\\", {})
export class MovieWhereInput {
  @Field(() => [MovieWhereInput], {
    nullable: true
  })
  AND?: MovieWhereInput[] | undefined;

  @Field(() => [MovieWhereInput], {
    nullable: true
  })
  OR?: MovieWhereInput[] | undefined;

  @Field(() => [MovieWhereInput], {
    nullable: true
  })
  NOT?: MovieWhereInput[] | undefined;

  @Field(() => StringFilter, {
    nullable: true
  })
  directorFirstName?: StringFilter | undefined;

  @Field(() => StringFilter, {
    nullable: true
  })
  directorLastName?: StringFilter | undefined;

  @Field(() => StringFilter, {
    nullable: true
  })
  title?: StringFilter | undefined;

  @Field(() => FloatFilter, {
    nullable: true
  })
  rating?: FloatFilter | undefined;

  @Field(() => DirectorScalarRelationFilter, {
    nullable: true
  })
  director?: DirectorScalarRelationFilter | undefined;
}
"
`;

exports[`inputs should properly generate input type classes for model with id keys with relation: MovieWhereUniqueInput 1`] = `
"import { Args, ArgsType, Context, Field, Float, ID, Info, InputType, Int, Mutation, ObjectType, Parent, Query, ResolveField, Resolver, registerEnumType } from \\"@nestjs/graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { Prisma } from \\"../../../../helpers/prisma-client-mock\\";
import { DecimalJSScalar } from \\"../../scalars\\";
import { DirectorScalarRelationFilter, FloatFilter, MovieDirectorFirstNameDirectorLastNameTitleCompoundUniqueInput, MovieWhereInput, StringFilter } from \\"../inputs\\";

@InputType(\\"MovieWhereUniqueInput\\", {})
export class MovieWhereUniqueInput {
  @Field(() => MovieDirectorFirstNameDirectorLastNameTitleCompoundUniqueInput, {
    nullable: true
  })
  directorFirstName_directorLastName_title?: MovieDirectorFirstNameDirectorLastNameTitleCompoundUniqueInput | undefined;

  @Field(() => [MovieWhereInput], {
    nullable: true
  })
  AND?: MovieWhereInput[] | undefined;

  @Field(() => [MovieWhereInput], {
    nullable: true
  })
  OR?: MovieWhereInput[] | undefined;

  @Field(() => [MovieWhereInput], {
    nullable: true
  })
  NOT?: MovieWhereInput[] | undefined;

  @Field(() => StringFilter, {
    nullable: true
  })
  directorFirstName?: StringFilter | undefined;

  @Field(() => StringFilter, {
    nullable: true
  })
  directorLastName?: StringFilter | undefined;

  @Field(() => StringFilter, {
    nullable: true
  })
  title?: StringFilter | undefined;

  @Field(() => FloatFilter, {
    nullable: true
  })
  rating?: FloatFilter | undefined;

  @Field(() => DirectorScalarRelationFilter, {
    nullable: true
  })
  director?: DirectorScalarRelationFilter | undefined;
}
"
`;

exports[`inputs should properly generate input type classes for model with id keys with relation: index 1`] = `
"export * from \\"./DirectorAvgOrderByAggregateInput\\";
export * from \\"./DirectorCountOrderByAggregateInput\\";
export * from \\"./DirectorCreateInput\\";
export * from \\"./DirectorCreateManyInput\\";
export * from \\"./DirectorCreateNestedOneWithoutMoviesInput\\";
export * from \\"./DirectorCreateOrConnectWithoutMoviesInput\\";
export * from \\"./DirectorCreateWithoutMoviesInput\\";
export * from \\"./DirectorFirstNameLastNameCompoundUniqueInput\\";
export * from \\"./DirectorMaxOrderByAggregateInput\\";
export * from \\"./DirectorMinOrderByAggregateInput\\";
export * from \\"./DirectorOrderByWithAggregationInput\\";
export * from \\"./DirectorOrderByWithRelationInput\\";
export * from \\"./DirectorScalarRelationFilter\\";
export * from \\"./DirectorScalarWhereWithAggregatesInput\\";
export * from \\"./DirectorSumOrderByAggregateInput\\";
export * from \\"./DirectorUpdateInput\\";
export * from \\"./DirectorUpdateManyMutationInput\\";
export * from \\"./DirectorUpdateOneRequiredWithoutMoviesNestedInput\\";
export * from \\"./DirectorUpdateToOneWithWhereWithoutMoviesInput\\";
export * from \\"./DirectorUpdateWithoutMoviesInput\\";
export * from \\"./DirectorUpsertWithoutMoviesInput\\";
export * from \\"./DirectorWhereInput\\";
export * from \\"./DirectorWhereUniqueInput\\";
export * from \\"./FloatFieldUpdateOperationsInput\\";
export * from \\"./FloatFilter\\";
export * from \\"./FloatWithAggregatesFilter\\";
export * from \\"./IntFieldUpdateOperationsInput\\";
export * from \\"./IntFilter\\";
export * from \\"./IntWithAggregatesFilter\\";
export * from \\"./MovieAvgOrderByAggregateInput\\";
export * from \\"./MovieCountOrderByAggregateInput\\";
export * from \\"./MovieCreateInput\\";
export * from \\"./MovieCreateManyDirectorInput\\";
export * from \\"./MovieCreateManyDirectorInputEnvelope\\";
export * from \\"./MovieCreateManyInput\\";
export * from \\"./MovieCreateNestedManyWithoutDirectorInput\\";
export * from \\"./MovieCreateOrConnectWithoutDirectorInput\\";
export * from \\"./MovieCreateWithoutDirectorInput\\";
export * from \\"./MovieDirectorFirstNameDirectorLastNameTitleCompoundUniqueInput\\";
export * from \\"./MovieListRelationFilter\\";
export * from \\"./MovieMaxOrderByAggregateInput\\";
export * from \\"./MovieMinOrderByAggregateInput\\";
export * from \\"./MovieOrderByRelationAggregateInput\\";
export * from \\"./MovieOrderByWithAggregationInput\\";
export * from \\"./MovieOrderByWithRelationInput\\";
export * from \\"./MovieScalarWhereInput\\";
export * from \\"./MovieScalarWhereWithAggregatesInput\\";
export * from \\"./MovieSumOrderByAggregateInput\\";
export * from \\"./MovieUpdateInput\\";
export * from \\"./MovieUpdateManyMutationInput\\";
export * from \\"./MovieUpdateManyWithWhereWithoutDirectorInput\\";
export * from \\"./MovieUpdateManyWithoutDirectorNestedInput\\";
export * from \\"./MovieUpdateWithWhereUniqueWithoutDirectorInput\\";
export * from \\"./MovieUpdateWithoutDirectorInput\\";
export * from \\"./MovieUpsertWithWhereUniqueWithoutDirectorInput\\";
export * from \\"./MovieWhereInput\\";
export * from \\"./MovieWhereUniqueInput\\";
export * from \\"./NestedFloatFilter\\";
export * from \\"./NestedFloatWithAggregatesFilter\\";
export * from \\"./NestedIntFilter\\";
export * from \\"./NestedIntWithAggregatesFilter\\";
export * from \\"./NestedStringFilter\\";
export * from \\"./NestedStringWithAggregatesFilter\\";
export * from \\"./StringFieldUpdateOperationsInput\\";
export * from \\"./StringFilter\\";
export * from \\"./StringWithAggregatesFilter\\";
"
`;

exports[`inputs should properly generate input type classes for model with native types: NativeTypeModelCreateInput 1`] = `
"import { Args, ArgsType, Context, Field, Float, ID, Info, InputType, Int, Mutation, ObjectType, Parent, Query, ResolveField, Resolver, registerEnumType } from \\"@nestjs/graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { Prisma } from \\"../../../../helpers/prisma-client-mock\\";
import { DecimalJSScalar } from \\"../../scalars\\";

@InputType(\\"NativeTypeModelCreateInput\\", {})
export class NativeTypeModelCreateInput {
  @Field(() => GraphQLScalars.BigIntResolver, {
    nullable: true
  })
  bigInt?: bigint | undefined;

  @Field(() => GraphQLScalars.ByteResolver, {
    nullable: true
  })
  byteA?: Buffer | undefined;

  @Field(() => DecimalJSScalar, {
    nullable: true
  })
  decimal?: Prisma.Decimal | undefined;
}
"
`;

exports[`inputs should properly generate input type classes for model with native types: NativeTypeModelOrderByWithRelationInput 1`] = `
"import { Args, ArgsType, Context, Field, Float, ID, Info, InputType, Int, Mutation, ObjectType, Parent, Query, ResolveField, Resolver, registerEnumType } from \\"@nestjs/graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { Prisma } from \\"../../../../helpers/prisma-client-mock\\";
import { DecimalJSScalar } from \\"../../scalars\\";
import { SortOrderInput } from \\"../inputs\\";
import { SortOrder } from \\"../../enums/SortOrder\\";

@InputType(\\"NativeTypeModelOrderByWithRelationInput\\", {})
export class NativeTypeModelOrderByWithRelationInput {
  @Field(() => SortOrder, {
    nullable: true
  })
  id?: \\"asc\\" | \\"desc\\" | undefined;

  @Field(() => SortOrderInput, {
    nullable: true
  })
  bigInt?: SortOrderInput | undefined;

  @Field(() => SortOrderInput, {
    nullable: true
  })
  byteA?: SortOrderInput | undefined;

  @Field(() => SortOrderInput, {
    nullable: true
  })
  decimal?: SortOrderInput | undefined;
}
"
`;

exports[`inputs should properly generate input type classes for model with native types: NativeTypeModelUpdateInput 1`] = `
"import { Args, ArgsType, Context, Field, Float, ID, Info, InputType, Int, Mutation, ObjectType, Parent, Query, ResolveField, Resolver, registerEnumType } from \\"@nestjs/graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { Prisma } from \\"../../../../helpers/prisma-client-mock\\";
import { DecimalJSScalar } from \\"../../scalars\\";
import { NullableBigIntFieldUpdateOperationsInput, NullableBytesFieldUpdateOperationsInput, NullableDecimalFieldUpdateOperationsInput } from \\"../inputs\\";

@InputType(\\"NativeTypeModelUpdateInput\\", {})
export class NativeTypeModelUpdateInput {
  @Field(() => NullableBigIntFieldUpdateOperationsInput, {
    nullable: true
  })
  bigInt?: NullableBigIntFieldUpdateOperationsInput | undefined;

  @Field(() => NullableBytesFieldUpdateOperationsInput, {
    nullable: true
  })
  byteA?: NullableBytesFieldUpdateOperationsInput | undefined;

  @Field(() => NullableDecimalFieldUpdateOperationsInput, {
    nullable: true
  })
  decimal?: NullableDecimalFieldUpdateOperationsInput | undefined;
}
"
`;

exports[`inputs should properly generate input type classes for model with native types: NativeTypeModelUpdateManyMutationInput 1`] = `
"import { Args, ArgsType, Context, Field, Float, ID, Info, InputType, Int, Mutation, ObjectType, Parent, Query, ResolveField, Resolver, registerEnumType } from \\"@nestjs/graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { Prisma } from \\"../../../../helpers/prisma-client-mock\\";
import { DecimalJSScalar } from \\"../../scalars\\";
import { NullableBigIntFieldUpdateOperationsInput, NullableBytesFieldUpdateOperationsInput, NullableDecimalFieldUpdateOperationsInput } from \\"../inputs\\";

@InputType(\\"NativeTypeModelUpdateManyMutationInput\\", {})
export class NativeTypeModelUpdateManyMutationInput {
  @Field(() => NullableBigIntFieldUpdateOperationsInput, {
    nullable: true
  })
  bigInt?: NullableBigIntFieldUpdateOperationsInput | undefined;

  @Field(() => NullableBytesFieldUpdateOperationsInput, {
    nullable: true
  })
  byteA?: NullableBytesFieldUpdateOperationsInput | undefined;

  @Field(() => NullableDecimalFieldUpdateOperationsInput, {
    nullable: true
  })
  decimal?: NullableDecimalFieldUpdateOperationsInput | undefined;
}
"
`;

exports[`inputs should properly generate input type classes for model with native types: NativeTypeModelWhereInput 1`] = `
"import { Args, ArgsType, Context, Field, Float, ID, Info, InputType, Int, Mutation, ObjectType, Parent, Query, ResolveField, Resolver, registerEnumType } from \\"@nestjs/graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { Prisma } from \\"../../../../helpers/prisma-client-mock\\";
import { DecimalJSScalar } from \\"../../scalars\\";
import { BigIntNullableFilter, BytesNullableFilter, DecimalNullableFilter, IntFilter } from \\"../inputs\\";

@InputType(\\"NativeTypeModelWhereInput\\", {})
export class NativeTypeModelWhereInput {
  @Field(() => [NativeTypeModelWhereInput], {
    nullable: true
  })
  AND?: NativeTypeModelWhereInput[] | undefined;

  @Field(() => [NativeTypeModelWhereInput], {
    nullable: true
  })
  OR?: NativeTypeModelWhereInput[] | undefined;

  @Field(() => [NativeTypeModelWhereInput], {
    nullable: true
  })
  NOT?: NativeTypeModelWhereInput[] | undefined;

  @Field(() => IntFilter, {
    nullable: true
  })
  id?: IntFilter | undefined;

  @Field(() => BigIntNullableFilter, {
    nullable: true
  })
  bigInt?: BigIntNullableFilter | undefined;

  @Field(() => BytesNullableFilter, {
    nullable: true
  })
  byteA?: BytesNullableFilter | undefined;

  @Field(() => DecimalNullableFilter, {
    nullable: true
  })
  decimal?: DecimalNullableFilter | undefined;
}
"
`;

exports[`inputs should properly generate input type classes for model with native types: NativeTypeModelWhereUniqueInput 1`] = `
"import { Args, ArgsType, Context, Field, Float, ID, Info, InputType, Int, Mutation, ObjectType, Parent, Query, ResolveField, Resolver, registerEnumType } from \\"@nestjs/graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { Prisma } from \\"../../../../helpers/prisma-client-mock\\";
import { DecimalJSScalar } from \\"../../scalars\\";
import { BigIntNullableFilter, BytesNullableFilter, DecimalNullableFilter, NativeTypeModelWhereInput } from \\"../inputs\\";

@InputType(\\"NativeTypeModelWhereUniqueInput\\", {})
export class NativeTypeModelWhereUniqueInput {
  @Field(() => Int, {
    nullable: true
  })
  id?: number | undefined;

  @Field(() => [NativeTypeModelWhereInput], {
    nullable: true
  })
  AND?: NativeTypeModelWhereInput[] | undefined;

  @Field(() => [NativeTypeModelWhereInput], {
    nullable: true
  })
  OR?: NativeTypeModelWhereInput[] | undefined;

  @Field(() => [NativeTypeModelWhereInput], {
    nullable: true
  })
  NOT?: NativeTypeModelWhereInput[] | undefined;

  @Field(() => BigIntNullableFilter, {
    nullable: true
  })
  bigInt?: BigIntNullableFilter | undefined;

  @Field(() => BytesNullableFilter, {
    nullable: true
  })
  byteA?: BytesNullableFilter | undefined;

  @Field(() => DecimalNullableFilter, {
    nullable: true
  })
  decimal?: DecimalNullableFilter | undefined;
}
"
`;

exports[`inputs should properly generate input type classes for model with native types: index 1`] = `
"export * from \\"./BigIntNullableFilter\\";
export * from \\"./BigIntNullableWithAggregatesFilter\\";
export * from \\"./BytesNullableFilter\\";
export * from \\"./BytesNullableWithAggregatesFilter\\";
export * from \\"./DecimalNullableFilter\\";
export * from \\"./DecimalNullableWithAggregatesFilter\\";
export * from \\"./IntFieldUpdateOperationsInput\\";
export * from \\"./IntFilter\\";
export * from \\"./IntWithAggregatesFilter\\";
export * from \\"./NativeTypeModelAvgOrderByAggregateInput\\";
export * from \\"./NativeTypeModelCountOrderByAggregateInput\\";
export * from \\"./NativeTypeModelCreateInput\\";
export * from \\"./NativeTypeModelCreateManyInput\\";
export * from \\"./NativeTypeModelMaxOrderByAggregateInput\\";
export * from \\"./NativeTypeModelMinOrderByAggregateInput\\";
export * from \\"./NativeTypeModelOrderByWithAggregationInput\\";
export * from \\"./NativeTypeModelOrderByWithRelationInput\\";
export * from \\"./NativeTypeModelScalarWhereWithAggregatesInput\\";
export * from \\"./NativeTypeModelSumOrderByAggregateInput\\";
export * from \\"./NativeTypeModelUpdateInput\\";
export * from \\"./NativeTypeModelUpdateManyMutationInput\\";
export * from \\"./NativeTypeModelWhereInput\\";
export * from \\"./NativeTypeModelWhereUniqueInput\\";
export * from \\"./NestedBigIntNullableFilter\\";
export * from \\"./NestedBigIntNullableWithAggregatesFilter\\";
export * from \\"./NestedBytesNullableFilter\\";
export * from \\"./NestedBytesNullableWithAggregatesFilter\\";
export * from \\"./NestedDecimalNullableFilter\\";
export * from \\"./NestedDecimalNullableWithAggregatesFilter\\";
export * from \\"./NestedFloatFilter\\";
export * from \\"./NestedFloatNullableFilter\\";
export * from \\"./NestedIntFilter\\";
export * from \\"./NestedIntNullableFilter\\";
export * from \\"./NestedIntWithAggregatesFilter\\";
export * from \\"./NullableBigIntFieldUpdateOperationsInput\\";
export * from \\"./NullableBytesFieldUpdateOperationsInput\\";
export * from \\"./NullableDecimalFieldUpdateOperationsInput\\";
export * from \\"./SortOrderInput\\";
"
`;

exports[`inputs should properly generate input type classes for sorting by many-to-many relation fields: FirstModelOrderByWithRelationInput 1`] = `
"import { Args, ArgsType, Context, Field, Float, ID, Info, InputType, Int, Mutation, ObjectType, Parent, Query, ResolveField, Resolver, registerEnumType } from \\"@nestjs/graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { Prisma } from \\"../../../../helpers/prisma-client-mock\\";
import { DecimalJSScalar } from \\"../../scalars\\";
import { SecondModelOrderByRelationAggregateInput } from \\"../inputs\\";
import { SortOrder } from \\"../../enums/SortOrder\\";

@InputType(\\"FirstModelOrderByWithRelationInput\\", {})
export class FirstModelOrderByWithRelationInput {
  @Field(() => SortOrder, {
    nullable: true
  })
  idField?: \\"asc\\" | \\"desc\\" | undefined;

  @Field(() => SortOrder, {
    nullable: true
  })
  uniqueStringField?: \\"asc\\" | \\"desc\\" | undefined;

  @Field(() => SortOrder, {
    nullable: true
  })
  floatField?: \\"asc\\" | \\"desc\\" | undefined;

  @Field(() => SecondModelOrderByRelationAggregateInput, {
    nullable: true
  })
  secondModelsField?: SecondModelOrderByRelationAggregateInput | undefined;
}
"
`;

exports[`inputs should properly generate input type classes for sorting by many-to-many relation fields: SampleAvgOrderByAggregateInput 1`] = `
"import { Args, ArgsType, Context, Field, Float, ID, Info, InputType, Int, Mutation, ObjectType, Parent, Query, ResolveField, Resolver, registerEnumType } from \\"@nestjs/graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { Prisma } from \\"../../../../helpers/prisma-client-mock\\";
import { DecimalJSScalar } from \\"../../scalars\\";
import { SortOrder } from \\"../../enums/SortOrder\\";

@InputType(\\"SampleAvgOrderByAggregateInput\\", {})
export class SampleAvgOrderByAggregateInput {
  @Field(() => SortOrder, {
    nullable: true
  })
  idField?: \\"asc\\" | \\"desc\\" | undefined;

  @Field(() => SortOrder, {
    nullable: true
  })
  floatField?: \\"asc\\" | \\"desc\\" | undefined;

  @Field(() => SortOrder, {
    nullable: true
  })
  intField?: \\"asc\\" | \\"desc\\" | undefined;
}
"
`;

exports[`inputs should properly generate input type classes for sorting by many-to-many relation fields: SampleCountOrderByAggregateInput 1`] = `
"import { Args, ArgsType, Context, Field, Float, ID, Info, InputType, Int, Mutation, ObjectType, Parent, Query, ResolveField, Resolver, registerEnumType } from \\"@nestjs/graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { Prisma } from \\"../../../../helpers/prisma-client-mock\\";
import { DecimalJSScalar } from \\"../../scalars\\";
import { SortOrder } from \\"../../enums/SortOrder\\";

@InputType(\\"SampleCountOrderByAggregateInput\\", {})
export class SampleCountOrderByAggregateInput {
  @Field(() => SortOrder, {
    nullable: true
  })
  idField?: \\"asc\\" | \\"desc\\" | undefined;

  @Field(() => SortOrder, {
    nullable: true
  })
  stringField?: \\"asc\\" | \\"desc\\" | undefined;

  @Field(() => SortOrder, {
    nullable: true
  })
  floatField?: \\"asc\\" | \\"desc\\" | undefined;

  @Field(() => SortOrder, {
    nullable: true
  })
  intField?: \\"asc\\" | \\"desc\\" | undefined;

  @Field(() => SortOrder, {
    nullable: true
  })
  booleanField?: \\"asc\\" | \\"desc\\" | undefined;

  @Field(() => SortOrder, {
    nullable: true
  })
  dateField?: \\"asc\\" | \\"desc\\" | undefined;

  @Field(() => SortOrder, {
    nullable: true
  })
  jsonField?: \\"asc\\" | \\"desc\\" | undefined;
}
"
`;

exports[`inputs should properly generate input type classes for sorting by many-to-many relation fields: SampleMaxOrderByAggregateInput 1`] = `
"import { Args, ArgsType, Context, Field, Float, ID, Info, InputType, Int, Mutation, ObjectType, Parent, Query, ResolveField, Resolver, registerEnumType } from \\"@nestjs/graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { Prisma } from \\"../../../../helpers/prisma-client-mock\\";
import { DecimalJSScalar } from \\"../../scalars\\";
import { SortOrder } from \\"../../enums/SortOrder\\";

@InputType(\\"SampleMaxOrderByAggregateInput\\", {})
export class SampleMaxOrderByAggregateInput {
  @Field(() => SortOrder, {
    nullable: true
  })
  idField?: \\"asc\\" | \\"desc\\" | undefined;

  @Field(() => SortOrder, {
    nullable: true
  })
  stringField?: \\"asc\\" | \\"desc\\" | undefined;

  @Field(() => SortOrder, {
    nullable: true
  })
  floatField?: \\"asc\\" | \\"desc\\" | undefined;

  @Field(() => SortOrder, {
    nullable: true
  })
  intField?: \\"asc\\" | \\"desc\\" | undefined;

  @Field(() => SortOrder, {
    nullable: true
  })
  booleanField?: \\"asc\\" | \\"desc\\" | undefined;

  @Field(() => SortOrder, {
    nullable: true
  })
  dateField?: \\"asc\\" | \\"desc\\" | undefined;
}
"
`;

exports[`inputs should properly generate input type classes for sorting by many-to-many relation fields: SampleMinOrderByAggregateInput 1`] = `
"import { Args, ArgsType, Context, Field, Float, ID, Info, InputType, Int, Mutation, ObjectType, Parent, Query, ResolveField, Resolver, registerEnumType } from \\"@nestjs/graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { Prisma } from \\"../../../../helpers/prisma-client-mock\\";
import { DecimalJSScalar } from \\"../../scalars\\";
import { SortOrder } from \\"../../enums/SortOrder\\";

@InputType(\\"SampleMinOrderByAggregateInput\\", {})
export class SampleMinOrderByAggregateInput {
  @Field(() => SortOrder, {
    nullable: true
  })
  idField?: \\"asc\\" | \\"desc\\" | undefined;

  @Field(() => SortOrder, {
    nullable: true
  })
  stringField?: \\"asc\\" | \\"desc\\" | undefined;

  @Field(() => SortOrder, {
    nullable: true
  })
  floatField?: \\"asc\\" | \\"desc\\" | undefined;

  @Field(() => SortOrder, {
    nullable: true
  })
  intField?: \\"asc\\" | \\"desc\\" | undefined;

  @Field(() => SortOrder, {
    nullable: true
  })
  booleanField?: \\"asc\\" | \\"desc\\" | undefined;

  @Field(() => SortOrder, {
    nullable: true
  })
  dateField?: \\"asc\\" | \\"desc\\" | undefined;
}
"
`;

exports[`inputs should properly generate input type classes for sorting by many-to-many relation fields: SampleOrderByWithAggregationInput 1`] = `
"import { Args, ArgsType, Context, Field, Float, ID, Info, InputType, Int, Mutation, ObjectType, Parent, Query, ResolveField, Resolver, registerEnumType } from \\"@nestjs/graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { Prisma } from \\"../../../../helpers/prisma-client-mock\\";
import { DecimalJSScalar } from \\"../../scalars\\";
import { SampleAvgOrderByAggregateInput, SampleCountOrderByAggregateInput, SampleMaxOrderByAggregateInput, SampleMinOrderByAggregateInput, SampleSumOrderByAggregateInput } from \\"../inputs\\";
import { SortOrder } from \\"../../enums/SortOrder\\";

@InputType(\\"SampleOrderByWithAggregationInput\\", {})
export class SampleOrderByWithAggregationInput {
  @Field(() => SortOrder, {
    nullable: true
  })
  idField?: \\"asc\\" | \\"desc\\" | undefined;

  @Field(() => SortOrder, {
    nullable: true
  })
  stringField?: \\"asc\\" | \\"desc\\" | undefined;

  @Field(() => SortOrder, {
    nullable: true
  })
  floatField?: \\"asc\\" | \\"desc\\" | undefined;

  @Field(() => SortOrder, {
    nullable: true
  })
  intField?: \\"asc\\" | \\"desc\\" | undefined;

  @Field(() => SortOrder, {
    nullable: true
  })
  booleanField?: \\"asc\\" | \\"desc\\" | undefined;

  @Field(() => SortOrder, {
    nullable: true
  })
  dateField?: \\"asc\\" | \\"desc\\" | undefined;

  @Field(() => SortOrder, {
    nullable: true
  })
  jsonField?: \\"asc\\" | \\"desc\\" | undefined;

  @Field(() => SampleCountOrderByAggregateInput, {
    nullable: true
  })
  _count?: SampleCountOrderByAggregateInput | undefined;

  @Field(() => SampleAvgOrderByAggregateInput, {
    nullable: true
  })
  _avg?: SampleAvgOrderByAggregateInput | undefined;

  @Field(() => SampleMaxOrderByAggregateInput, {
    nullable: true
  })
  _max?: SampleMaxOrderByAggregateInput | undefined;

  @Field(() => SampleMinOrderByAggregateInput, {
    nullable: true
  })
  _min?: SampleMinOrderByAggregateInput | undefined;

  @Field(() => SampleSumOrderByAggregateInput, {
    nullable: true
  })
  _sum?: SampleSumOrderByAggregateInput | undefined;
}
"
`;

exports[`inputs should properly generate input type classes for sorting by many-to-many relation fields: SecondModelOrderByRelationAggregateInput 1`] = `
"import { Args, ArgsType, Context, Field, Float, ID, Info, InputType, Int, Mutation, ObjectType, Parent, Query, ResolveField, Resolver, registerEnumType } from \\"@nestjs/graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { Prisma } from \\"../../../../helpers/prisma-client-mock\\";
import { DecimalJSScalar } from \\"../../scalars\\";
import { SortOrder } from \\"../../enums/SortOrder\\";

@InputType(\\"SecondModelOrderByRelationAggregateInput\\", {})
export class SecondModelOrderByRelationAggregateInput {
  @Field(() => SortOrder, {
    nullable: true
  })
  _count?: \\"asc\\" | \\"desc\\" | undefined;
}
"
`;

exports[`inputs should properly generate input type classes for sorting by many-to-many relation fields: index 1`] = `
"export * from \\"./FirstModelAvgOrderByAggregateInput\\";
export * from \\"./FirstModelCountOrderByAggregateInput\\";
export * from \\"./FirstModelCreateInput\\";
export * from \\"./FirstModelCreateManyInput\\";
export * from \\"./FirstModelCreateNestedManyWithoutSecondModelsFieldInput\\";
export * from \\"./FirstModelCreateOrConnectWithoutSecondModelsFieldInput\\";
export * from \\"./FirstModelCreateWithoutSecondModelsFieldInput\\";
export * from \\"./FirstModelListRelationFilter\\";
export * from \\"./FirstModelMaxOrderByAggregateInput\\";
export * from \\"./FirstModelMinOrderByAggregateInput\\";
export * from \\"./FirstModelOrderByRelationAggregateInput\\";
export * from \\"./FirstModelOrderByWithAggregationInput\\";
export * from \\"./FirstModelOrderByWithRelationInput\\";
export * from \\"./FirstModelScalarWhereInput\\";
export * from \\"./FirstModelScalarWhereWithAggregatesInput\\";
export * from \\"./FirstModelSumOrderByAggregateInput\\";
export * from \\"./FirstModelUpdateInput\\";
export * from \\"./FirstModelUpdateManyMutationInput\\";
export * from \\"./FirstModelUpdateManyWithWhereWithoutSecondModelsFieldInput\\";
export * from \\"./FirstModelUpdateManyWithoutSecondModelsFieldNestedInput\\";
export * from \\"./FirstModelUpdateWithWhereUniqueWithoutSecondModelsFieldInput\\";
export * from \\"./FirstModelUpdateWithoutSecondModelsFieldInput\\";
export * from \\"./FirstModelUpsertWithWhereUniqueWithoutSecondModelsFieldInput\\";
export * from \\"./FirstModelWhereInput\\";
export * from \\"./FirstModelWhereUniqueInput\\";
export * from \\"./FloatFieldUpdateOperationsInput\\";
export * from \\"./FloatFilter\\";
export * from \\"./FloatWithAggregatesFilter\\";
export * from \\"./IntFieldUpdateOperationsInput\\";
export * from \\"./IntFilter\\";
export * from \\"./IntWithAggregatesFilter\\";
export * from \\"./NestedFloatFilter\\";
export * from \\"./NestedFloatWithAggregatesFilter\\";
export * from \\"./NestedIntFilter\\";
export * from \\"./NestedIntWithAggregatesFilter\\";
export * from \\"./NestedStringFilter\\";
export * from \\"./NestedStringWithAggregatesFilter\\";
export * from \\"./SecondModelAvgOrderByAggregateInput\\";
export * from \\"./SecondModelCountOrderByAggregateInput\\";
export * from \\"./SecondModelCreateInput\\";
export * from \\"./SecondModelCreateManyInput\\";
export * from \\"./SecondModelCreateNestedManyWithoutFirstModelsFieldInput\\";
export * from \\"./SecondModelCreateOrConnectWithoutFirstModelsFieldInput\\";
export * from \\"./SecondModelCreateWithoutFirstModelsFieldInput\\";
export * from \\"./SecondModelListRelationFilter\\";
export * from \\"./SecondModelMaxOrderByAggregateInput\\";
export * from \\"./SecondModelMinOrderByAggregateInput\\";
export * from \\"./SecondModelOrderByRelationAggregateInput\\";
export * from \\"./SecondModelOrderByWithAggregationInput\\";
export * from \\"./SecondModelOrderByWithRelationInput\\";
export * from \\"./SecondModelScalarWhereInput\\";
export * from \\"./SecondModelScalarWhereWithAggregatesInput\\";
export * from \\"./SecondModelSumOrderByAggregateInput\\";
export * from \\"./SecondModelUpdateInput\\";
export * from \\"./SecondModelUpdateManyMutationInput\\";
export * from \\"./SecondModelUpdateManyWithWhereWithoutFirstModelsFieldInput\\";
export * from \\"./SecondModelUpdateManyWithoutFirstModelsFieldNestedInput\\";
export * from \\"./SecondModelUpdateWithWhereUniqueWithoutFirstModelsFieldInput\\";
export * from \\"./SecondModelUpdateWithoutFirstModelsFieldInput\\";
export * from \\"./SecondModelUpsertWithWhereUniqueWithoutFirstModelsFieldInput\\";
export * from \\"./SecondModelWhereInput\\";
export * from \\"./SecondModelWhereUniqueInput\\";
export * from \\"./StringFieldUpdateOperationsInput\\";
export * from \\"./StringFilter\\";
export * from \\"./StringWithAggregatesFilter\\";
"
`;

exports[`inputs should properly generate input type classes for sorting by many-to-many relation fields: index 2`] = `
"export * from \\"./BoolFieldUpdateOperationsInput\\";
export * from \\"./BoolFilter\\";
export * from \\"./BoolWithAggregatesFilter\\";
export * from \\"./DateTimeFieldUpdateOperationsInput\\";
export * from \\"./DateTimeFilter\\";
export * from \\"./DateTimeWithAggregatesFilter\\";
export * from \\"./FloatFieldUpdateOperationsInput\\";
export * from \\"./FloatFilter\\";
export * from \\"./FloatWithAggregatesFilter\\";
export * from \\"./IntFieldUpdateOperationsInput\\";
export * from \\"./IntFilter\\";
export * from \\"./IntWithAggregatesFilter\\";
export * from \\"./JsonFilter\\";
export * from \\"./JsonWithAggregatesFilter\\";
export * from \\"./NestedBoolFilter\\";
export * from \\"./NestedBoolWithAggregatesFilter\\";
export * from \\"./NestedDateTimeFilter\\";
export * from \\"./NestedDateTimeWithAggregatesFilter\\";
export * from \\"./NestedFloatFilter\\";
export * from \\"./NestedFloatWithAggregatesFilter\\";
export * from \\"./NestedIntFilter\\";
export * from \\"./NestedIntWithAggregatesFilter\\";
export * from \\"./NestedJsonFilter\\";
export * from \\"./NestedStringFilter\\";
export * from \\"./NestedStringWithAggregatesFilter\\";
export * from \\"./SampleAvgOrderByAggregateInput\\";
export * from \\"./SampleCountOrderByAggregateInput\\";
export * from \\"./SampleCreateInput\\";
export * from \\"./SampleCreateManyInput\\";
export * from \\"./SampleMaxOrderByAggregateInput\\";
export * from \\"./SampleMinOrderByAggregateInput\\";
export * from \\"./SampleOrderByWithAggregationInput\\";
export * from \\"./SampleOrderByWithRelationInput\\";
export * from \\"./SampleScalarWhereWithAggregatesInput\\";
export * from \\"./SampleSumOrderByAggregateInput\\";
export * from \\"./SampleUpdateInput\\";
export * from \\"./SampleUpdateManyMutationInput\\";
export * from \\"./SampleWhereInput\\";
export * from \\"./SampleWhereUniqueInput\\";
export * from \\"./StringFieldUpdateOperationsInput\\";
export * from \\"./StringFilter\\";
export * from \\"./StringWithAggregatesFilter\\";
"
`;

exports[`inputs should properly generate input type classes for sorting by one-to-many relation fields: FirstModelOrderByWithRelationInput 1`] = `
"import { Args, ArgsType, Context, Field, Float, ID, Info, InputType, Int, Mutation, ObjectType, Parent, Query, ResolveField, Resolver, registerEnumType } from \\"@nestjs/graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { Prisma } from \\"../../../../helpers/prisma-client-mock\\";
import { DecimalJSScalar } from \\"../../scalars\\";
import { SecondModelOrderByRelationAggregateInput } from \\"../inputs\\";
import { SortOrder } from \\"../../enums/SortOrder\\";

@InputType(\\"FirstModelOrderByWithRelationInput\\", {})
export class FirstModelOrderByWithRelationInput {
  @Field(() => SortOrder, {
    nullable: true
  })
  idField?: \\"asc\\" | \\"desc\\" | undefined;

  @Field(() => SortOrder, {
    nullable: true
  })
  uniqueStringField?: \\"asc\\" | \\"desc\\" | undefined;

  @Field(() => SortOrder, {
    nullable: true
  })
  floatField?: \\"asc\\" | \\"desc\\" | undefined;

  @Field(() => SecondModelOrderByRelationAggregateInput, {
    nullable: true
  })
  secondModelsField?: SecondModelOrderByRelationAggregateInput | undefined;
}
"
`;

exports[`inputs should properly generate input type classes for sorting by one-to-many relation fields: SecondModelOrderByRelationAggregateInput 1`] = `
"import { Args, ArgsType, Context, Field, Float, ID, Info, InputType, Int, Mutation, ObjectType, Parent, Query, ResolveField, Resolver, registerEnumType } from \\"@nestjs/graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { Prisma } from \\"../../../../helpers/prisma-client-mock\\";
import { DecimalJSScalar } from \\"../../scalars\\";
import { SortOrder } from \\"../../enums/SortOrder\\";

@InputType(\\"SecondModelOrderByRelationAggregateInput\\", {})
export class SecondModelOrderByRelationAggregateInput {
  @Field(() => SortOrder, {
    nullable: true
  })
  _count?: \\"asc\\" | \\"desc\\" | undefined;
}
"
`;

exports[`inputs should properly generate input type classes for sorting by one-to-many relation fields: SecondModelOrderByWithRelationInput 1`] = `
"import { Args, ArgsType, Context, Field, Float, ID, Info, InputType, Int, Mutation, ObjectType, Parent, Query, ResolveField, Resolver, registerEnumType } from \\"@nestjs/graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { Prisma } from \\"../../../../helpers/prisma-client-mock\\";
import { DecimalJSScalar } from \\"../../scalars\\";
import { FirstModelOrderByWithRelationInput } from \\"../inputs\\";
import { SortOrder } from \\"../../enums/SortOrder\\";

@InputType(\\"SecondModelOrderByWithRelationInput\\", {})
export class SecondModelOrderByWithRelationInput {
  @Field(() => SortOrder, {
    nullable: true
  })
  idField?: \\"asc\\" | \\"desc\\" | undefined;

  @Field(() => SortOrder, {
    nullable: true
  })
  uniqueStringField?: \\"asc\\" | \\"desc\\" | undefined;

  @Field(() => SortOrder, {
    nullable: true
  })
  floatField?: \\"asc\\" | \\"desc\\" | undefined;

  @Field(() => SortOrder, {
    nullable: true
  })
  firstModelFieldId?: \\"asc\\" | \\"desc\\" | undefined;

  @Field(() => FirstModelOrderByWithRelationInput, {
    nullable: true
  })
  firstModelField?: FirstModelOrderByWithRelationInput | undefined;
}
"
`;

exports[`inputs should properly generate input type classes for sorting by one-to-many relation fields: index 1`] = `
"export * from \\"./FirstModelAvgOrderByAggregateInput\\";
export * from \\"./FirstModelCountOrderByAggregateInput\\";
export * from \\"./FirstModelCreateInput\\";
export * from \\"./FirstModelCreateManyInput\\";
export * from \\"./FirstModelCreateNestedOneWithoutSecondModelsFieldInput\\";
export * from \\"./FirstModelCreateOrConnectWithoutSecondModelsFieldInput\\";
export * from \\"./FirstModelCreateWithoutSecondModelsFieldInput\\";
export * from \\"./FirstModelMaxOrderByAggregateInput\\";
export * from \\"./FirstModelMinOrderByAggregateInput\\";
export * from \\"./FirstModelOrderByWithAggregationInput\\";
export * from \\"./FirstModelOrderByWithRelationInput\\";
export * from \\"./FirstModelScalarRelationFilter\\";
export * from \\"./FirstModelScalarWhereWithAggregatesInput\\";
export * from \\"./FirstModelSumOrderByAggregateInput\\";
export * from \\"./FirstModelUpdateInput\\";
export * from \\"./FirstModelUpdateManyMutationInput\\";
export * from \\"./FirstModelUpdateOneRequiredWithoutSecondModelsFieldNestedInput\\";
export * from \\"./FirstModelUpdateToOneWithWhereWithoutSecondModelsFieldInput\\";
export * from \\"./FirstModelUpdateWithoutSecondModelsFieldInput\\";
export * from \\"./FirstModelUpsertWithoutSecondModelsFieldInput\\";
export * from \\"./FirstModelWhereInput\\";
export * from \\"./FirstModelWhereUniqueInput\\";
export * from \\"./FloatFieldUpdateOperationsInput\\";
export * from \\"./FloatFilter\\";
export * from \\"./FloatWithAggregatesFilter\\";
export * from \\"./IntFieldUpdateOperationsInput\\";
export * from \\"./IntFilter\\";
export * from \\"./IntWithAggregatesFilter\\";
export * from \\"./NestedFloatFilter\\";
export * from \\"./NestedFloatWithAggregatesFilter\\";
export * from \\"./NestedIntFilter\\";
export * from \\"./NestedIntWithAggregatesFilter\\";
export * from \\"./NestedStringFilter\\";
export * from \\"./NestedStringWithAggregatesFilter\\";
export * from \\"./SecondModelAvgOrderByAggregateInput\\";
export * from \\"./SecondModelCountOrderByAggregateInput\\";
export * from \\"./SecondModelCreateInput\\";
export * from \\"./SecondModelCreateManyFirstModelFieldInput\\";
export * from \\"./SecondModelCreateManyFirstModelFieldInputEnvelope\\";
export * from \\"./SecondModelCreateManyInput\\";
export * from \\"./SecondModelCreateNestedManyWithoutFirstModelFieldInput\\";
export * from \\"./SecondModelCreateOrConnectWithoutFirstModelFieldInput\\";
export * from \\"./SecondModelCreateWithoutFirstModelFieldInput\\";
export * from \\"./SecondModelListRelationFilter\\";
export * from \\"./SecondModelMaxOrderByAggregateInput\\";
export * from \\"./SecondModelMinOrderByAggregateInput\\";
export * from \\"./SecondModelOrderByRelationAggregateInput\\";
export * from \\"./SecondModelOrderByWithAggregationInput\\";
export * from \\"./SecondModelOrderByWithRelationInput\\";
export * from \\"./SecondModelScalarWhereInput\\";
export * from \\"./SecondModelScalarWhereWithAggregatesInput\\";
export * from \\"./SecondModelSumOrderByAggregateInput\\";
export * from \\"./SecondModelUpdateInput\\";
export * from \\"./SecondModelUpdateManyMutationInput\\";
export * from \\"./SecondModelUpdateManyWithWhereWithoutFirstModelFieldInput\\";
export * from \\"./SecondModelUpdateManyWithoutFirstModelFieldNestedInput\\";
export * from \\"./SecondModelUpdateWithWhereUniqueWithoutFirstModelFieldInput\\";
export * from \\"./SecondModelUpdateWithoutFirstModelFieldInput\\";
export * from \\"./SecondModelUpsertWithWhereUniqueWithoutFirstModelFieldInput\\";
export * from \\"./SecondModelWhereInput\\";
export * from \\"./SecondModelWhereUniqueInput\\";
export * from \\"./StringFieldUpdateOperationsInput\\";
export * from \\"./StringFilter\\";
export * from \\"./StringWithAggregatesFilter\\";
"
`;

exports[`inputs should properly generate input type classes for updating scalar fields in postgres schema: SampleModelCreateInput 1`] = `
"import { Args, ArgsType, Context, Field, Float, ID, Info, InputType, Int, Mutation, ObjectType, Parent, Query, ResolveField, Resolver, registerEnumType } from \\"@nestjs/graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { Prisma } from \\"../../../../helpers/prisma-client-mock\\";
import { DecimalJSScalar } from \\"../../scalars\\";
import { SampleNestedTypeCreateInput } from \\"../inputs\\";
import { Color } from \\"../../enums/Color\\";

@InputType(\\"SampleModelCreateInput\\", {})
export class SampleModelCreateInput {
  @Field(() => String, {
    nullable: true
  })
  intIdField?: string | undefined;

  @Field(() => String, {
    nullable: false
  })
  stringField!: string;

  @Field(() => String, {
    nullable: true
  })
  optionalStringField?: string | undefined;

  @Field(() => Int, {
    nullable: false
  })
  intField!: number;

  @Field(() => Int, {
    nullable: true
  })
  optionalIntField?: number | undefined;

  @Field(() => Float, {
    nullable: false
  })
  floatField!: number;

  @Field(() => Float, {
    nullable: true
  })
  optionalFloatField?: number | undefined;

  @Field(() => Boolean, {
    nullable: false
  })
  booleanField!: boolean;

  @Field(() => Boolean, {
    nullable: true
  })
  optionalBooleanField?: boolean | undefined;

  @Field(() => Date, {
    nullable: false
  })
  dateField!: Date;

  @Field(() => Date, {
    nullable: true
  })
  optionalDateField?: Date | undefined;

  @Field(() => GraphQLScalars.JSONResolver, {
    nullable: false
  })
  jsonField!: Prisma.InputJsonValue;

  @Field(() => GraphQLScalars.JSONResolver, {
    nullable: true
  })
  optionalJsonField?: Prisma.InputJsonValue | undefined;

  @Field(() => Color, {
    nullable: false
  })
  enumField!: \\"RED\\" | \\"GREEN\\" | \\"BLUE\\";

  @Field(() => Color, {
    nullable: true
  })
  optionalEnumField?: \\"RED\\" | \\"GREEN\\" | \\"BLUE\\" | undefined;

  @Field(() => [Int], {
    nullable: true
  })
  intArrayField?: number[] | undefined;

  @Field(() => [String], {
    nullable: true
  })
  stringArrayField?: string[] | undefined;

  @Field(() => SampleNestedTypeCreateInput, {
    nullable: false
  })
  nestedModelField!: SampleNestedTypeCreateInput;
}
"
`;

exports[`inputs should properly generate input type classes for updating scalar fields in postgres schema: SampleModelCreateManyInput 1`] = `
"import { Args, ArgsType, Context, Field, Float, ID, Info, InputType, Int, Mutation, ObjectType, Parent, Query, ResolveField, Resolver, registerEnumType } from \\"@nestjs/graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { Prisma } from \\"../../../../helpers/prisma-client-mock\\";
import { DecimalJSScalar } from \\"../../scalars\\";
import { SampleNestedTypeCreateInput } from \\"../inputs\\";
import { Color } from \\"../../enums/Color\\";

@InputType(\\"SampleModelCreateManyInput\\", {})
export class SampleModelCreateManyInput {
  @Field(() => String, {
    nullable: true
  })
  intIdField?: string | undefined;

  @Field(() => String, {
    nullable: false
  })
  stringField!: string;

  @Field(() => String, {
    nullable: true
  })
  optionalStringField?: string | undefined;

  @Field(() => Int, {
    nullable: false
  })
  intField!: number;

  @Field(() => Int, {
    nullable: true
  })
  optionalIntField?: number | undefined;

  @Field(() => Float, {
    nullable: false
  })
  floatField!: number;

  @Field(() => Float, {
    nullable: true
  })
  optionalFloatField?: number | undefined;

  @Field(() => Boolean, {
    nullable: false
  })
  booleanField!: boolean;

  @Field(() => Boolean, {
    nullable: true
  })
  optionalBooleanField?: boolean | undefined;

  @Field(() => Date, {
    nullable: false
  })
  dateField!: Date;

  @Field(() => Date, {
    nullable: true
  })
  optionalDateField?: Date | undefined;

  @Field(() => GraphQLScalars.JSONResolver, {
    nullable: false
  })
  jsonField!: Prisma.InputJsonValue;

  @Field(() => GraphQLScalars.JSONResolver, {
    nullable: true
  })
  optionalJsonField?: Prisma.InputJsonValue | undefined;

  @Field(() => Color, {
    nullable: false
  })
  enumField!: \\"RED\\" | \\"GREEN\\" | \\"BLUE\\";

  @Field(() => Color, {
    nullable: true
  })
  optionalEnumField?: \\"RED\\" | \\"GREEN\\" | \\"BLUE\\" | undefined;

  @Field(() => [Int], {
    nullable: true
  })
  intArrayField?: number[] | undefined;

  @Field(() => [String], {
    nullable: true
  })
  stringArrayField?: string[] | undefined;

  @Field(() => SampleNestedTypeCreateInput, {
    nullable: false
  })
  nestedModelField!: SampleNestedTypeCreateInput;
}
"
`;

exports[`inputs should properly generate input type classes for updating scalar fields in postgres schema: SampleModelUpdateInput 1`] = `
"import { Args, ArgsType, Context, Field, Float, ID, Info, InputType, Int, Mutation, ObjectType, Parent, Query, ResolveField, Resolver, registerEnumType } from \\"@nestjs/graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { Prisma } from \\"../../../../helpers/prisma-client-mock\\";
import { DecimalJSScalar } from \\"../../scalars\\";
import { SampleNestedTypeCreateInput } from \\"../inputs\\";
import { Color } from \\"../../enums/Color\\";

@InputType(\\"SampleModelUpdateInput\\", {})
export class SampleModelUpdateInput {
  @Field(() => String, {
    nullable: true
  })
  stringField?: string | undefined;

  @Field(() => String, {
    nullable: true
  })
  optionalStringField?: string | undefined;

  @Field(() => Int, {
    nullable: true
  })
  intField?: number | undefined;

  @Field(() => Int, {
    nullable: true
  })
  optionalIntField?: number | undefined;

  @Field(() => Float, {
    nullable: true
  })
  floatField?: number | undefined;

  @Field(() => Float, {
    nullable: true
  })
  optionalFloatField?: number | undefined;

  @Field(() => Boolean, {
    nullable: true
  })
  booleanField?: boolean | undefined;

  @Field(() => Boolean, {
    nullable: true
  })
  optionalBooleanField?: boolean | undefined;

  @Field(() => Date, {
    nullable: true
  })
  dateField?: Date | undefined;

  @Field(() => Date, {
    nullable: true
  })
  optionalDateField?: Date | undefined;

  @Field(() => GraphQLScalars.JSONResolver, {
    nullable: true
  })
  jsonField?: Prisma.InputJsonValue | undefined;

  @Field(() => GraphQLScalars.JSONResolver, {
    nullable: true
  })
  optionalJsonField?: Prisma.InputJsonValue | undefined;

  @Field(() => Color, {
    nullable: true
  })
  enumField?: \\"RED\\" | \\"GREEN\\" | \\"BLUE\\" | undefined;

  @Field(() => Color, {
    nullable: true
  })
  optionalEnumField?: \\"RED\\" | \\"GREEN\\" | \\"BLUE\\" | undefined;

  @Field(() => [Int], {
    nullable: true
  })
  intArrayField?: number[] | undefined;

  @Field(() => [String], {
    nullable: true
  })
  stringArrayField?: string[] | undefined;

  @Field(() => SampleNestedTypeCreateInput, {
    nullable: true
  })
  nestedModelField?: SampleNestedTypeCreateInput | undefined;
}
"
`;

exports[`inputs should properly generate input type classes for updating scalar fields in postgres schema: SampleModelUpdateManyMutationInput 1`] = `
"import { Args, ArgsType, Context, Field, Float, ID, Info, InputType, Int, Mutation, ObjectType, Parent, Query, ResolveField, Resolver, registerEnumType } from \\"@nestjs/graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { Prisma } from \\"../../../../helpers/prisma-client-mock\\";
import { DecimalJSScalar } from \\"../../scalars\\";
import { SampleNestedTypeCreateInput } from \\"../inputs\\";
import { Color } from \\"../../enums/Color\\";

@InputType(\\"SampleModelUpdateManyMutationInput\\", {})
export class SampleModelUpdateManyMutationInput {
  @Field(() => String, {
    nullable: true
  })
  stringField?: string | undefined;

  @Field(() => String, {
    nullable: true
  })
  optionalStringField?: string | undefined;

  @Field(() => Int, {
    nullable: true
  })
  intField?: number | undefined;

  @Field(() => Int, {
    nullable: true
  })
  optionalIntField?: number | undefined;

  @Field(() => Float, {
    nullable: true
  })
  floatField?: number | undefined;

  @Field(() => Float, {
    nullable: true
  })
  optionalFloatField?: number | undefined;

  @Field(() => Boolean, {
    nullable: true
  })
  booleanField?: boolean | undefined;

  @Field(() => Boolean, {
    nullable: true
  })
  optionalBooleanField?: boolean | undefined;

  @Field(() => Date, {
    nullable: true
  })
  dateField?: Date | undefined;

  @Field(() => Date, {
    nullable: true
  })
  optionalDateField?: Date | undefined;

  @Field(() => GraphQLScalars.JSONResolver, {
    nullable: true
  })
  jsonField?: Prisma.InputJsonValue | undefined;

  @Field(() => GraphQLScalars.JSONResolver, {
    nullable: true
  })
  optionalJsonField?: Prisma.InputJsonValue | undefined;

  @Field(() => Color, {
    nullable: true
  })
  enumField?: \\"RED\\" | \\"GREEN\\" | \\"BLUE\\" | undefined;

  @Field(() => Color, {
    nullable: true
  })
  optionalEnumField?: \\"RED\\" | \\"GREEN\\" | \\"BLUE\\" | undefined;

  @Field(() => [Int], {
    nullable: true
  })
  intArrayField?: number[] | undefined;

  @Field(() => [String], {
    nullable: true
  })
  stringArrayField?: string[] | undefined;

  @Field(() => SampleNestedTypeCreateInput, {
    nullable: true
  })
  nestedModelField?: SampleNestedTypeCreateInput | undefined;
}
"
`;

exports[`inputs should properly generate input type classes for updating scalar fields in postgres schema: SampleNestedTypeCreateInput 1`] = `
"import { Args, ArgsType, Context, Field, Float, ID, Info, InputType, Int, Mutation, ObjectType, Parent, Query, ResolveField, Resolver, registerEnumType } from \\"@nestjs/graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { Prisma } from \\"../../../../helpers/prisma-client-mock\\";
import { DecimalJSScalar } from \\"../../scalars\\";

@InputType(\\"SampleNestedTypeCreateInput\\", {})
export class SampleNestedTypeCreateInput {
  @Field(() => String, {
    nullable: false
  })
  stringField!: string;

  @Field(() => [String], {
    nullable: true
  })
  stringArrayField?: string[] | undefined;

  @Field(() => Int, {
    nullable: false
  })
  intField!: number;

  @Field(() => [Int], {
    nullable: true
  })
  intArrayField?: number[] | undefined;
}
"
`;

exports[`inputs should properly generate input type classes for updating scalar fields in postgres schema: SampleNestedTypeUpdateInput 1`] = `
"import { Args, ArgsType, Context, Field, Float, ID, Info, InputType, Int, Mutation, ObjectType, Parent, Query, ResolveField, Resolver, registerEnumType } from \\"@nestjs/graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { Prisma } from \\"../../../../helpers/prisma-client-mock\\";
import { DecimalJSScalar } from \\"../../scalars\\";

@InputType(\\"SampleNestedTypeUpdateInput\\", {})
export class SampleNestedTypeUpdateInput {
  @Field(() => String, {
    nullable: true
  })
  stringField?: string | undefined;

  @Field(() => [String], {
    nullable: true
  })
  stringArrayField?: string[] | undefined;

  @Field(() => Int, {
    nullable: true
  })
  intField?: number | undefined;

  @Field(() => [Int], {
    nullable: true
  })
  intArrayField?: number[] | undefined;
}
"
`;

exports[`inputs should properly generate input type classes for updating scalar fields in postgres schema: index 1`] = `
"export * from \\"./BoolFieldUpdateOperationsInput\\";
export * from \\"./BoolFilter\\";
export * from \\"./BoolNullableFilter\\";
export * from \\"./BoolNullableWithAggregatesFilter\\";
export * from \\"./BoolWithAggregatesFilter\\";
export * from \\"./DateTimeFieldUpdateOperationsInput\\";
export * from \\"./DateTimeFilter\\";
export * from \\"./DateTimeNullableFilter\\";
export * from \\"./DateTimeNullableWithAggregatesFilter\\";
export * from \\"./DateTimeWithAggregatesFilter\\";
export * from \\"./EnumColorFieldUpdateOperationsInput\\";
export * from \\"./EnumColorFilter\\";
export * from \\"./EnumColorNullableFilter\\";
export * from \\"./EnumColorNullableWithAggregatesFilter\\";
export * from \\"./EnumColorWithAggregatesFilter\\";
export * from \\"./FloatFieldUpdateOperationsInput\\";
export * from \\"./FloatFilter\\";
export * from \\"./FloatNullableFilter\\";
export * from \\"./FloatNullableWithAggregatesFilter\\";
export * from \\"./FloatWithAggregatesFilter\\";
export * from \\"./IntFieldUpdateOperationsInput\\";
export * from \\"./IntFilter\\";
export * from \\"./IntNullableFilter\\";
export * from \\"./IntNullableListFilter\\";
export * from \\"./IntNullableWithAggregatesFilter\\";
export * from \\"./IntWithAggregatesFilter\\";
export * from \\"./JsonFilter\\";
export * from \\"./JsonNullableFilter\\";
export * from \\"./JsonNullableWithAggregatesFilter\\";
export * from \\"./JsonWithAggregatesFilter\\";
export * from \\"./NestedBoolFilter\\";
export * from \\"./NestedBoolNullableFilter\\";
export * from \\"./NestedBoolNullableWithAggregatesFilter\\";
export * from \\"./NestedBoolWithAggregatesFilter\\";
export * from \\"./NestedDateTimeFilter\\";
export * from \\"./NestedDateTimeNullableFilter\\";
export * from \\"./NestedDateTimeNullableWithAggregatesFilter\\";
export * from \\"./NestedDateTimeWithAggregatesFilter\\";
export * from \\"./NestedEnumColorFilter\\";
export * from \\"./NestedEnumColorNullableFilter\\";
export * from \\"./NestedEnumColorNullableWithAggregatesFilter\\";
export * from \\"./NestedEnumColorWithAggregatesFilter\\";
export * from \\"./NestedFloatFilter\\";
export * from \\"./NestedFloatNullableFilter\\";
export * from \\"./NestedFloatNullableWithAggregatesFilter\\";
export * from \\"./NestedFloatWithAggregatesFilter\\";
export * from \\"./NestedIntFilter\\";
export * from \\"./NestedIntNullableFilter\\";
export * from \\"./NestedIntNullableWithAggregatesFilter\\";
export * from \\"./NestedIntWithAggregatesFilter\\";
export * from \\"./NestedJsonFilter\\";
export * from \\"./NestedJsonNullableFilter\\";
export * from \\"./NestedStringFilter\\";
export * from \\"./NestedStringNullableFilter\\";
export * from \\"./NestedStringNullableWithAggregatesFilter\\";
export * from \\"./NestedStringWithAggregatesFilter\\";
export * from \\"./NullableBoolFieldUpdateOperationsInput\\";
export * from \\"./NullableDateTimeFieldUpdateOperationsInput\\";
export * from \\"./NullableEnumColorFieldUpdateOperationsInput\\";
export * from \\"./NullableFloatFieldUpdateOperationsInput\\";
export * from \\"./NullableIntFieldUpdateOperationsInput\\";
export * from \\"./NullableStringFieldUpdateOperationsInput\\";
export * from \\"./SampleModelAvgOrderByAggregateInput\\";
export * from \\"./SampleModelCountOrderByAggregateInput\\";
export * from \\"./SampleModelCreateInput\\";
export * from \\"./SampleModelCreateManyInput\\";
export * from \\"./SampleModelCreateintArrayFieldInput\\";
export * from \\"./SampleModelCreatestringArrayFieldInput\\";
export * from \\"./SampleModelMaxOrderByAggregateInput\\";
export * from \\"./SampleModelMinOrderByAggregateInput\\";
export * from \\"./SampleModelOrderByWithAggregationInput\\";
export * from \\"./SampleModelOrderByWithRelationInput\\";
export * from \\"./SampleModelScalarWhereWithAggregatesInput\\";
export * from \\"./SampleModelSumOrderByAggregateInput\\";
export * from \\"./SampleModelUpdateInput\\";
export * from \\"./SampleModelUpdateManyMutationInput\\";
export * from \\"./SampleModelUpdateintArrayFieldInput\\";
export * from \\"./SampleModelUpdatestringArrayFieldInput\\";
export * from \\"./SampleModelWhereInput\\";
export * from \\"./SampleModelWhereUniqueInput\\";
export * from \\"./SampleNestedTypeCompositeFilter\\";
export * from \\"./SampleNestedTypeCreateEnvelopeInput\\";
export * from \\"./SampleNestedTypeCreateInput\\";
export * from \\"./SampleNestedTypeCreateintArrayFieldInput\\";
export * from \\"./SampleNestedTypeCreatestringArrayFieldInput\\";
export * from \\"./SampleNestedTypeObjectEqualityInput\\";
export * from \\"./SampleNestedTypeOrderByInput\\";
export * from \\"./SampleNestedTypeUpdateEnvelopeInput\\";
export * from \\"./SampleNestedTypeUpdateInput\\";
export * from \\"./SampleNestedTypeUpdateintArrayFieldInput\\";
export * from \\"./SampleNestedTypeUpdatestringArrayFieldInput\\";
export * from \\"./SampleNestedTypeWhereInput\\";
export * from \\"./StringFieldUpdateOperationsInput\\";
export * from \\"./StringFilter\\";
export * from \\"./StringNullableFilter\\";
export * from \\"./StringNullableListFilter\\";
export * from \\"./StringNullableWithAggregatesFilter\\";
export * from \\"./StringWithAggregatesFilter\\";
"
`;

exports[`inputs should properly generate input type classes for updating scalar fields: BoolFieldUpdateOperationsInput 1`] = `
"import { Args, ArgsType, Context, Field, Float, ID, Info, InputType, Int, Mutation, ObjectType, Parent, Query, ResolveField, Resolver, registerEnumType } from \\"@nestjs/graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { Prisma } from \\"../../../../helpers/prisma-client-mock\\";
import { DecimalJSScalar } from \\"../../scalars\\";

@InputType(\\"BoolFieldUpdateOperationsInput\\", {})
export class BoolFieldUpdateOperationsInput {
  @Field(() => Boolean, {
    nullable: true
  })
  set?: boolean | undefined;
}
"
`;

exports[`inputs should properly generate input type classes for updating scalar fields: DateTimeFieldUpdateOperationsInput 1`] = `
"import { Args, ArgsType, Context, Field, Float, ID, Info, InputType, Int, Mutation, ObjectType, Parent, Query, ResolveField, Resolver, registerEnumType } from \\"@nestjs/graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { Prisma } from \\"../../../../helpers/prisma-client-mock\\";
import { DecimalJSScalar } from \\"../../scalars\\";

@InputType(\\"DateTimeFieldUpdateOperationsInput\\", {})
export class DateTimeFieldUpdateOperationsInput {
  @Field(() => Date, {
    nullable: true
  })
  set?: Date | undefined;
}
"
`;

exports[`inputs should properly generate input type classes for updating scalar fields: EnumColorFieldUpdateOperationsInput 1`] = `
"import { Args, ArgsType, Context, Field, Float, ID, Info, InputType, Int, Mutation, ObjectType, Parent, Query, ResolveField, Resolver, registerEnumType } from \\"@nestjs/graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { Prisma } from \\"../../../../helpers/prisma-client-mock\\";
import { DecimalJSScalar } from \\"../../scalars\\";
import { Color } from \\"../../enums/Color\\";

@InputType(\\"EnumColorFieldUpdateOperationsInput\\", {})
export class EnumColorFieldUpdateOperationsInput {
  @Field(() => Color, {
    nullable: true
  })
  set?: \\"RED\\" | \\"GREEN\\" | \\"BLUE\\" | undefined;
}
"
`;

exports[`inputs should properly generate input type classes for updating scalar fields: FloatFieldUpdateOperationsInput 1`] = `
"import { Args, ArgsType, Context, Field, Float, ID, Info, InputType, Int, Mutation, ObjectType, Parent, Query, ResolveField, Resolver, registerEnumType } from \\"@nestjs/graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { Prisma } from \\"../../../../helpers/prisma-client-mock\\";
import { DecimalJSScalar } from \\"../../scalars\\";

@InputType(\\"FloatFieldUpdateOperationsInput\\", {})
export class FloatFieldUpdateOperationsInput {
  @Field(() => Float, {
    nullable: true
  })
  set?: number | undefined;

  @Field(() => Float, {
    nullable: true
  })
  increment?: number | undefined;

  @Field(() => Float, {
    nullable: true
  })
  decrement?: number | undefined;

  @Field(() => Float, {
    nullable: true
  })
  multiply?: number | undefined;

  @Field(() => Float, {
    nullable: true
  })
  divide?: number | undefined;
}
"
`;

exports[`inputs should properly generate input type classes for updating scalar fields: IntFieldUpdateOperationsInput 1`] = `
"import { Args, ArgsType, Context, Field, Float, ID, Info, InputType, Int, Mutation, ObjectType, Parent, Query, ResolveField, Resolver, registerEnumType } from \\"@nestjs/graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { Prisma } from \\"../../../../helpers/prisma-client-mock\\";
import { DecimalJSScalar } from \\"../../scalars\\";

@InputType(\\"IntFieldUpdateOperationsInput\\", {})
export class IntFieldUpdateOperationsInput {
  @Field(() => Int, {
    nullable: true
  })
  set?: number | undefined;

  @Field(() => Int, {
    nullable: true
  })
  increment?: number | undefined;

  @Field(() => Int, {
    nullable: true
  })
  decrement?: number | undefined;

  @Field(() => Int, {
    nullable: true
  })
  multiply?: number | undefined;

  @Field(() => Int, {
    nullable: true
  })
  divide?: number | undefined;
}
"
`;

exports[`inputs should properly generate input type classes for updating scalar fields: SampleModelUpdateInput 1`] = `
"import { Args, ArgsType, Context, Field, Float, ID, Info, InputType, Int, Mutation, ObjectType, Parent, Query, ResolveField, Resolver, registerEnumType } from \\"@nestjs/graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { Prisma } from \\"../../../../helpers/prisma-client-mock\\";
import { DecimalJSScalar } from \\"../../scalars\\";
import { BoolFieldUpdateOperationsInput, DateTimeFieldUpdateOperationsInput, EnumColorFieldUpdateOperationsInput, FloatFieldUpdateOperationsInput, IntFieldUpdateOperationsInput, NullableBoolFieldUpdateOperationsInput, NullableDateTimeFieldUpdateOperationsInput, NullableEnumColorFieldUpdateOperationsInput, NullableFloatFieldUpdateOperationsInput, NullableIntFieldUpdateOperationsInput, NullableStringFieldUpdateOperationsInput, SampleModelUpdateintArrayFieldInput, SampleModelUpdatestringArrayFieldInput, StringFieldUpdateOperationsInput } from \\"../inputs\\";

@InputType(\\"SampleModelUpdateInput\\", {})
export class SampleModelUpdateInput {
  @Field(() => StringFieldUpdateOperationsInput, {
    nullable: true
  })
  stringField?: StringFieldUpdateOperationsInput | undefined;

  @Field(() => NullableStringFieldUpdateOperationsInput, {
    nullable: true
  })
  optionalStringField?: NullableStringFieldUpdateOperationsInput | undefined;

  @Field(() => IntFieldUpdateOperationsInput, {
    nullable: true
  })
  intField?: IntFieldUpdateOperationsInput | undefined;

  @Field(() => NullableIntFieldUpdateOperationsInput, {
    nullable: true
  })
  optionalIntField?: NullableIntFieldUpdateOperationsInput | undefined;

  @Field(() => FloatFieldUpdateOperationsInput, {
    nullable: true
  })
  floatField?: FloatFieldUpdateOperationsInput | undefined;

  @Field(() => NullableFloatFieldUpdateOperationsInput, {
    nullable: true
  })
  optionalFloatField?: NullableFloatFieldUpdateOperationsInput | undefined;

  @Field(() => BoolFieldUpdateOperationsInput, {
    nullable: true
  })
  booleanField?: BoolFieldUpdateOperationsInput | undefined;

  @Field(() => NullableBoolFieldUpdateOperationsInput, {
    nullable: true
  })
  optionalBooleanField?: NullableBoolFieldUpdateOperationsInput | undefined;

  @Field(() => DateTimeFieldUpdateOperationsInput, {
    nullable: true
  })
  dateField?: DateTimeFieldUpdateOperationsInput | undefined;

  @Field(() => NullableDateTimeFieldUpdateOperationsInput, {
    nullable: true
  })
  optionalDateField?: NullableDateTimeFieldUpdateOperationsInput | undefined;

  @Field(() => GraphQLScalars.JSONResolver, {
    nullable: true
  })
  jsonField?: Prisma.InputJsonValue | undefined;

  @Field(() => GraphQLScalars.JSONResolver, {
    nullable: true
  })
  optionalJsonField?: Prisma.InputJsonValue | undefined;

  @Field(() => EnumColorFieldUpdateOperationsInput, {
    nullable: true
  })
  enumField?: EnumColorFieldUpdateOperationsInput | undefined;

  @Field(() => NullableEnumColorFieldUpdateOperationsInput, {
    nullable: true
  })
  optionalEnumField?: NullableEnumColorFieldUpdateOperationsInput | undefined;

  @Field(() => SampleModelUpdateintArrayFieldInput, {
    nullable: true
  })
  intArrayField?: SampleModelUpdateintArrayFieldInput | undefined;

  @Field(() => SampleModelUpdatestringArrayFieldInput, {
    nullable: true
  })
  stringArrayField?: SampleModelUpdatestringArrayFieldInput | undefined;
}
"
`;

exports[`inputs should properly generate input type classes for updating scalar fields: SampleModelUpdateManyMutationInput 1`] = `
"import { Args, ArgsType, Context, Field, Float, ID, Info, InputType, Int, Mutation, ObjectType, Parent, Query, ResolveField, Resolver, registerEnumType } from \\"@nestjs/graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { Prisma } from \\"../../../../helpers/prisma-client-mock\\";
import { DecimalJSScalar } from \\"../../scalars\\";
import { BoolFieldUpdateOperationsInput, DateTimeFieldUpdateOperationsInput, EnumColorFieldUpdateOperationsInput, FloatFieldUpdateOperationsInput, IntFieldUpdateOperationsInput, NullableBoolFieldUpdateOperationsInput, NullableDateTimeFieldUpdateOperationsInput, NullableEnumColorFieldUpdateOperationsInput, NullableFloatFieldUpdateOperationsInput, NullableIntFieldUpdateOperationsInput, NullableStringFieldUpdateOperationsInput, SampleModelUpdateintArrayFieldInput, SampleModelUpdatestringArrayFieldInput, StringFieldUpdateOperationsInput } from \\"../inputs\\";

@InputType(\\"SampleModelUpdateManyMutationInput\\", {})
export class SampleModelUpdateManyMutationInput {
  @Field(() => StringFieldUpdateOperationsInput, {
    nullable: true
  })
  stringField?: StringFieldUpdateOperationsInput | undefined;

  @Field(() => NullableStringFieldUpdateOperationsInput, {
    nullable: true
  })
  optionalStringField?: NullableStringFieldUpdateOperationsInput | undefined;

  @Field(() => IntFieldUpdateOperationsInput, {
    nullable: true
  })
  intField?: IntFieldUpdateOperationsInput | undefined;

  @Field(() => NullableIntFieldUpdateOperationsInput, {
    nullable: true
  })
  optionalIntField?: NullableIntFieldUpdateOperationsInput | undefined;

  @Field(() => FloatFieldUpdateOperationsInput, {
    nullable: true
  })
  floatField?: FloatFieldUpdateOperationsInput | undefined;

  @Field(() => NullableFloatFieldUpdateOperationsInput, {
    nullable: true
  })
  optionalFloatField?: NullableFloatFieldUpdateOperationsInput | undefined;

  @Field(() => BoolFieldUpdateOperationsInput, {
    nullable: true
  })
  booleanField?: BoolFieldUpdateOperationsInput | undefined;

  @Field(() => NullableBoolFieldUpdateOperationsInput, {
    nullable: true
  })
  optionalBooleanField?: NullableBoolFieldUpdateOperationsInput | undefined;

  @Field(() => DateTimeFieldUpdateOperationsInput, {
    nullable: true
  })
  dateField?: DateTimeFieldUpdateOperationsInput | undefined;

  @Field(() => NullableDateTimeFieldUpdateOperationsInput, {
    nullable: true
  })
  optionalDateField?: NullableDateTimeFieldUpdateOperationsInput | undefined;

  @Field(() => GraphQLScalars.JSONResolver, {
    nullable: true
  })
  jsonField?: Prisma.InputJsonValue | undefined;

  @Field(() => GraphQLScalars.JSONResolver, {
    nullable: true
  })
  optionalJsonField?: Prisma.InputJsonValue | undefined;

  @Field(() => EnumColorFieldUpdateOperationsInput, {
    nullable: true
  })
  enumField?: EnumColorFieldUpdateOperationsInput | undefined;

  @Field(() => NullableEnumColorFieldUpdateOperationsInput, {
    nullable: true
  })
  optionalEnumField?: NullableEnumColorFieldUpdateOperationsInput | undefined;

  @Field(() => SampleModelUpdateintArrayFieldInput, {
    nullable: true
  })
  intArrayField?: SampleModelUpdateintArrayFieldInput | undefined;

  @Field(() => SampleModelUpdatestringArrayFieldInput, {
    nullable: true
  })
  stringArrayField?: SampleModelUpdatestringArrayFieldInput | undefined;
}
"
`;

exports[`inputs should properly generate input type classes for updating scalar fields: SampleModelUpdateintArrayFieldInput 1`] = `
"import { Args, ArgsType, Context, Field, Float, ID, Info, InputType, Int, Mutation, ObjectType, Parent, Query, ResolveField, Resolver, registerEnumType } from \\"@nestjs/graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { Prisma } from \\"../../../../helpers/prisma-client-mock\\";
import { DecimalJSScalar } from \\"../../scalars\\";

@InputType(\\"SampleModelUpdateintArrayFieldInput\\", {})
export class SampleModelUpdateintArrayFieldInput {
  @Field(() => [Int], {
    nullable: true
  })
  set?: number[] | undefined;

  @Field(() => [Int], {
    nullable: true
  })
  push?: number[] | undefined;
}
"
`;

exports[`inputs should properly generate input type classes for updating scalar fields: SampleModelUpdatestringArrayFieldInput 1`] = `
"import { Args, ArgsType, Context, Field, Float, ID, Info, InputType, Int, Mutation, ObjectType, Parent, Query, ResolveField, Resolver, registerEnumType } from \\"@nestjs/graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { Prisma } from \\"../../../../helpers/prisma-client-mock\\";
import { DecimalJSScalar } from \\"../../scalars\\";

@InputType(\\"SampleModelUpdatestringArrayFieldInput\\", {})
export class SampleModelUpdatestringArrayFieldInput {
  @Field(() => [String], {
    nullable: true
  })
  set?: string[] | undefined;

  @Field(() => [String], {
    nullable: true
  })
  push?: string[] | undefined;
}
"
`;

exports[`inputs should properly generate input type classes for updating scalar fields: StringFieldUpdateOperationsInput 1`] = `
"import { Args, ArgsType, Context, Field, Float, ID, Info, InputType, Int, Mutation, ObjectType, Parent, Query, ResolveField, Resolver, registerEnumType } from \\"@nestjs/graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { Prisma } from \\"../../../../helpers/prisma-client-mock\\";
import { DecimalJSScalar } from \\"../../scalars\\";

@InputType(\\"StringFieldUpdateOperationsInput\\", {})
export class StringFieldUpdateOperationsInput {
  @Field(() => String, {
    nullable: true
  })
  set?: string | undefined;
}
"
`;

exports[`inputs should properly generate input type classes for updating scalar fields: index 1`] = `
"export * from \\"./BoolFieldUpdateOperationsInput\\";
export * from \\"./BoolFilter\\";
export * from \\"./BoolNullableFilter\\";
export * from \\"./BoolNullableWithAggregatesFilter\\";
export * from \\"./BoolWithAggregatesFilter\\";
export * from \\"./DateTimeFieldUpdateOperationsInput\\";
export * from \\"./DateTimeFilter\\";
export * from \\"./DateTimeNullableFilter\\";
export * from \\"./DateTimeNullableWithAggregatesFilter\\";
export * from \\"./DateTimeWithAggregatesFilter\\";
export * from \\"./EnumColorFieldUpdateOperationsInput\\";
export * from \\"./EnumColorFilter\\";
export * from \\"./EnumColorNullableFilter\\";
export * from \\"./EnumColorNullableWithAggregatesFilter\\";
export * from \\"./EnumColorWithAggregatesFilter\\";
export * from \\"./FloatFieldUpdateOperationsInput\\";
export * from \\"./FloatFilter\\";
export * from \\"./FloatNullableFilter\\";
export * from \\"./FloatNullableWithAggregatesFilter\\";
export * from \\"./FloatWithAggregatesFilter\\";
export * from \\"./IntFieldUpdateOperationsInput\\";
export * from \\"./IntFilter\\";
export * from \\"./IntNullableFilter\\";
export * from \\"./IntNullableListFilter\\";
export * from \\"./IntNullableWithAggregatesFilter\\";
export * from \\"./IntWithAggregatesFilter\\";
export * from \\"./JsonFilter\\";
export * from \\"./JsonNullableFilter\\";
export * from \\"./JsonNullableWithAggregatesFilter\\";
export * from \\"./JsonWithAggregatesFilter\\";
export * from \\"./NestedBoolFilter\\";
export * from \\"./NestedBoolNullableFilter\\";
export * from \\"./NestedBoolNullableWithAggregatesFilter\\";
export * from \\"./NestedBoolWithAggregatesFilter\\";
export * from \\"./NestedDateTimeFilter\\";
export * from \\"./NestedDateTimeNullableFilter\\";
export * from \\"./NestedDateTimeNullableWithAggregatesFilter\\";
export * from \\"./NestedDateTimeWithAggregatesFilter\\";
export * from \\"./NestedEnumColorFilter\\";
export * from \\"./NestedEnumColorNullableFilter\\";
export * from \\"./NestedEnumColorNullableWithAggregatesFilter\\";
export * from \\"./NestedEnumColorWithAggregatesFilter\\";
export * from \\"./NestedFloatFilter\\";
export * from \\"./NestedFloatNullableFilter\\";
export * from \\"./NestedFloatNullableWithAggregatesFilter\\";
export * from \\"./NestedFloatWithAggregatesFilter\\";
export * from \\"./NestedIntFilter\\";
export * from \\"./NestedIntNullableFilter\\";
export * from \\"./NestedIntNullableWithAggregatesFilter\\";
export * from \\"./NestedIntWithAggregatesFilter\\";
export * from \\"./NestedJsonFilter\\";
export * from \\"./NestedJsonNullableFilter\\";
export * from \\"./NestedStringFilter\\";
export * from \\"./NestedStringNullableFilter\\";
export * from \\"./NestedStringNullableWithAggregatesFilter\\";
export * from \\"./NestedStringWithAggregatesFilter\\";
export * from \\"./NullableBoolFieldUpdateOperationsInput\\";
export * from \\"./NullableDateTimeFieldUpdateOperationsInput\\";
export * from \\"./NullableEnumColorFieldUpdateOperationsInput\\";
export * from \\"./NullableFloatFieldUpdateOperationsInput\\";
export * from \\"./NullableIntFieldUpdateOperationsInput\\";
export * from \\"./NullableStringFieldUpdateOperationsInput\\";
export * from \\"./SampleModelAvgOrderByAggregateInput\\";
export * from \\"./SampleModelCountOrderByAggregateInput\\";
export * from \\"./SampleModelCreateInput\\";
export * from \\"./SampleModelCreateManyInput\\";
export * from \\"./SampleModelCreateintArrayFieldInput\\";
export * from \\"./SampleModelCreatestringArrayFieldInput\\";
export * from \\"./SampleModelMaxOrderByAggregateInput\\";
export * from \\"./SampleModelMinOrderByAggregateInput\\";
export * from \\"./SampleModelOrderByWithAggregationInput\\";
export * from \\"./SampleModelOrderByWithRelationInput\\";
export * from \\"./SampleModelScalarWhereWithAggregatesInput\\";
export * from \\"./SampleModelSumOrderByAggregateInput\\";
export * from \\"./SampleModelUpdateInput\\";
export * from \\"./SampleModelUpdateManyMutationInput\\";
export * from \\"./SampleModelUpdateintArrayFieldInput\\";
export * from \\"./SampleModelUpdatestringArrayFieldInput\\";
export * from \\"./SampleModelWhereInput\\";
export * from \\"./SampleModelWhereUniqueInput\\";
export * from \\"./SortOrderInput\\";
export * from \\"./StringFieldUpdateOperationsInput\\";
export * from \\"./StringFilter\\";
export * from \\"./StringNullableFilter\\";
export * from \\"./StringNullableListFilter\\";
export * from \\"./StringNullableWithAggregatesFilter\\";
export * from \\"./StringWithAggregatesFilter\\";
"
`;

exports[`inputs should properly generate input type classes with SortOrderInput type fields: FirstModelOrderByWithAggregationInput 1`] = `
"import { Args, ArgsType, Context, Field, Float, ID, Info, InputType, Int, Mutation, ObjectType, Parent, Query, ResolveField, Resolver, registerEnumType } from \\"@nestjs/graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { Prisma } from \\"../../../../helpers/prisma-client-mock\\";
import { DecimalJSScalar } from \\"../../scalars\\";
import { FirstModelAvgOrderByAggregateInput, FirstModelCountOrderByAggregateInput, FirstModelMaxOrderByAggregateInput, FirstModelMinOrderByAggregateInput, FirstModelSumOrderByAggregateInput, SortOrderInput } from \\"../inputs\\";
import { SortOrder } from \\"../../enums/SortOrder\\";

@InputType(\\"FirstModelOrderByWithAggregationInput\\", {})
export class FirstModelOrderByWithAggregationInput {
  @Field(() => SortOrder, {
    nullable: true
  })
  idField?: \\"asc\\" | \\"desc\\" | undefined;

  @Field(() => SortOrder, {
    nullable: true
  })
  uniqueStringField?: \\"asc\\" | \\"desc\\" | undefined;

  @Field(() => SortOrderInput, {
    nullable: true
  })
  optionalFloatField?: SortOrderInput | undefined;

  @Field(() => FirstModelCountOrderByAggregateInput, {
    nullable: true
  })
  _count?: FirstModelCountOrderByAggregateInput | undefined;

  @Field(() => FirstModelAvgOrderByAggregateInput, {
    nullable: true
  })
  _avg?: FirstModelAvgOrderByAggregateInput | undefined;

  @Field(() => FirstModelMaxOrderByAggregateInput, {
    nullable: true
  })
  _max?: FirstModelMaxOrderByAggregateInput | undefined;

  @Field(() => FirstModelMinOrderByAggregateInput, {
    nullable: true
  })
  _min?: FirstModelMinOrderByAggregateInput | undefined;

  @Field(() => FirstModelSumOrderByAggregateInput, {
    nullable: true
  })
  _sum?: FirstModelSumOrderByAggregateInput | undefined;
}
"
`;

exports[`inputs should properly generate input type classes with SortOrderInput type fields: FirstModelUpdateOneRequiredWithoutSecondModelsFieldNestedInput 1`] = `
"import { Args, ArgsType, Context, Field, Float, ID, Info, InputType, Int, Mutation, ObjectType, Parent, Query, ResolveField, Resolver, registerEnumType } from \\"@nestjs/graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { Prisma } from \\"../../../../helpers/prisma-client-mock\\";
import { DecimalJSScalar } from \\"../../scalars\\";
import { FirstModelCreateOrConnectWithoutSecondModelsFieldInput, FirstModelCreateWithoutSecondModelsFieldInput, FirstModelUpdateToOneWithWhereWithoutSecondModelsFieldInput, FirstModelUpsertWithoutSecondModelsFieldInput, FirstModelWhereUniqueInput } from \\"../inputs\\";

@InputType(\\"FirstModelUpdateOneRequiredWithoutSecondModelsFieldNestedInput\\", {})
export class FirstModelUpdateOneRequiredWithoutSecondModelsFieldNestedInput {
  @Field(() => FirstModelCreateWithoutSecondModelsFieldInput, {
    nullable: true
  })
  create?: FirstModelCreateWithoutSecondModelsFieldInput | undefined;

  @Field(() => FirstModelCreateOrConnectWithoutSecondModelsFieldInput, {
    nullable: true
  })
  connectOrCreate?: FirstModelCreateOrConnectWithoutSecondModelsFieldInput | undefined;

  @Field(() => FirstModelUpsertWithoutSecondModelsFieldInput, {
    nullable: true
  })
  upsert?: FirstModelUpsertWithoutSecondModelsFieldInput | undefined;

  @Field(() => FirstModelWhereUniqueInput, {
    nullable: true
  })
  connect?: FirstModelWhereUniqueInput | undefined;

  @Field(() => FirstModelUpdateToOneWithWhereWithoutSecondModelsFieldInput, {
    nullable: true
  })
  update?: FirstModelUpdateToOneWithWhereWithoutSecondModelsFieldInput | undefined;
}
"
`;

exports[`inputs should properly generate input type classes with SortOrderInput type fields: FirstModelUpdateToOneWithWhereWithoutSecondModelsFieldInput 1`] = `
"import { Args, ArgsType, Context, Field, Float, ID, Info, InputType, Int, Mutation, ObjectType, Parent, Query, ResolveField, Resolver, registerEnumType } from \\"@nestjs/graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { Prisma } from \\"../../../../helpers/prisma-client-mock\\";
import { DecimalJSScalar } from \\"../../scalars\\";
import { FirstModelUpdateWithoutSecondModelsFieldInput, FirstModelWhereInput } from \\"../inputs\\";

@InputType(\\"FirstModelUpdateToOneWithWhereWithoutSecondModelsFieldInput\\", {})
export class FirstModelUpdateToOneWithWhereWithoutSecondModelsFieldInput {
  @Field(() => FirstModelWhereInput, {
    nullable: true
  })
  where?: FirstModelWhereInput | undefined;

  @Field(() => FirstModelUpdateWithoutSecondModelsFieldInput, {
    nullable: false
  })
  data!: FirstModelUpdateWithoutSecondModelsFieldInput;
}
"
`;

exports[`inputs should properly generate input type classes with SortOrderInput type fields: FirstModelWhereUniqueInput 1`] = `
"import { Args, ArgsType, Context, Field, Float, ID, Info, InputType, Int, Mutation, ObjectType, Parent, Query, ResolveField, Resolver, registerEnumType } from \\"@nestjs/graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { Prisma } from \\"../../../../helpers/prisma-client-mock\\";
import { DecimalJSScalar } from \\"../../scalars\\";
import { FirstModelWhereInput, FloatNullableFilter, SecondModelListRelationFilter } from \\"../inputs\\";

@InputType(\\"FirstModelWhereUniqueInput\\", {})
export class FirstModelWhereUniqueInput {
  @Field(() => Int, {
    nullable: true
  })
  idField?: number | undefined;

  @Field(() => String, {
    nullable: true
  })
  uniqueStringField?: string | undefined;

  @Field(() => [FirstModelWhereInput], {
    nullable: true
  })
  AND?: FirstModelWhereInput[] | undefined;

  @Field(() => [FirstModelWhereInput], {
    nullable: true
  })
  OR?: FirstModelWhereInput[] | undefined;

  @Field(() => [FirstModelWhereInput], {
    nullable: true
  })
  NOT?: FirstModelWhereInput[] | undefined;

  @Field(() => FloatNullableFilter, {
    nullable: true
  })
  optionalFloatField?: FloatNullableFilter | undefined;

  @Field(() => SecondModelListRelationFilter, {
    nullable: true
  })
  secondModelsField?: SecondModelListRelationFilter | undefined;
}
"
`;

exports[`inputs should properly generate input type classes with SortOrderInput type fields: SecondModelUpsertWithWhereUniqueWithoutFirstModelFieldInput 1`] = `
"import { Args, ArgsType, Context, Field, Float, ID, Info, InputType, Int, Mutation, ObjectType, Parent, Query, ResolveField, Resolver, registerEnumType } from \\"@nestjs/graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { Prisma } from \\"../../../../helpers/prisma-client-mock\\";
import { DecimalJSScalar } from \\"../../scalars\\";
import { SecondModelCreateWithoutFirstModelFieldInput, SecondModelUpdateWithoutFirstModelFieldInput, SecondModelWhereUniqueInput } from \\"../inputs\\";

@InputType(\\"SecondModelUpsertWithWhereUniqueWithoutFirstModelFieldInput\\", {})
export class SecondModelUpsertWithWhereUniqueWithoutFirstModelFieldInput {
  @Field(() => SecondModelWhereUniqueInput, {
    nullable: false
  })
  where!: SecondModelWhereUniqueInput;

  @Field(() => SecondModelUpdateWithoutFirstModelFieldInput, {
    nullable: false
  })
  update!: SecondModelUpdateWithoutFirstModelFieldInput;

  @Field(() => SecondModelCreateWithoutFirstModelFieldInput, {
    nullable: false
  })
  create!: SecondModelCreateWithoutFirstModelFieldInput;
}
"
`;

exports[`inputs should properly generate input type classes with SortOrderInput type fields: SortOrderInput 1`] = `
"import { Args, ArgsType, Context, Field, Float, ID, Info, InputType, Int, Mutation, ObjectType, Parent, Query, ResolveField, Resolver, registerEnumType } from \\"@nestjs/graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { Prisma } from \\"../../../../helpers/prisma-client-mock\\";
import { DecimalJSScalar } from \\"../../scalars\\";
import { NullsOrder } from \\"../../enums/NullsOrder\\";
import { SortOrder } from \\"../../enums/SortOrder\\";

@InputType(\\"SortOrderInput\\", {})
export class SortOrderInput {
  @Field(() => SortOrder, {
    nullable: false
  })
  sort!: \\"asc\\" | \\"desc\\";

  @Field(() => NullsOrder, {
    nullable: true
  })
  nulls?: \\"first\\" | \\"last\\" | undefined;
}
"
`;

exports[`inputs should properly generate input type classes with SortOrderInput type fields: index 1`] = `
"export * from \\"./FirstModelAvgOrderByAggregateInput\\";
export * from \\"./FirstModelCountOrderByAggregateInput\\";
export * from \\"./FirstModelCreateInput\\";
export * from \\"./FirstModelCreateManyInput\\";
export * from \\"./FirstModelCreateNestedOneWithoutSecondModelsFieldInput\\";
export * from \\"./FirstModelCreateOrConnectWithoutSecondModelsFieldInput\\";
export * from \\"./FirstModelCreateWithoutSecondModelsFieldInput\\";
export * from \\"./FirstModelMaxOrderByAggregateInput\\";
export * from \\"./FirstModelMinOrderByAggregateInput\\";
export * from \\"./FirstModelOrderByWithAggregationInput\\";
export * from \\"./FirstModelOrderByWithRelationInput\\";
export * from \\"./FirstModelScalarRelationFilter\\";
export * from \\"./FirstModelScalarWhereWithAggregatesInput\\";
export * from \\"./FirstModelSumOrderByAggregateInput\\";
export * from \\"./FirstModelUpdateInput\\";
export * from \\"./FirstModelUpdateManyMutationInput\\";
export * from \\"./FirstModelUpdateOneRequiredWithoutSecondModelsFieldNestedInput\\";
export * from \\"./FirstModelUpdateToOneWithWhereWithoutSecondModelsFieldInput\\";
export * from \\"./FirstModelUpdateWithoutSecondModelsFieldInput\\";
export * from \\"./FirstModelUpsertWithoutSecondModelsFieldInput\\";
export * from \\"./FirstModelWhereInput\\";
export * from \\"./FirstModelWhereUniqueInput\\";
export * from \\"./FloatNullableFilter\\";
export * from \\"./FloatNullableWithAggregatesFilter\\";
export * from \\"./IntFieldUpdateOperationsInput\\";
export * from \\"./IntFilter\\";
export * from \\"./IntWithAggregatesFilter\\";
export * from \\"./NestedFloatFilter\\";
export * from \\"./NestedFloatNullableFilter\\";
export * from \\"./NestedFloatNullableWithAggregatesFilter\\";
export * from \\"./NestedIntFilter\\";
export * from \\"./NestedIntNullableFilter\\";
export * from \\"./NestedIntWithAggregatesFilter\\";
export * from \\"./NestedStringFilter\\";
export * from \\"./NestedStringWithAggregatesFilter\\";
export * from \\"./NullableFloatFieldUpdateOperationsInput\\";
export * from \\"./SecondModelAvgOrderByAggregateInput\\";
export * from \\"./SecondModelCountOrderByAggregateInput\\";
export * from \\"./SecondModelCreateInput\\";
export * from \\"./SecondModelCreateManyFirstModelFieldInput\\";
export * from \\"./SecondModelCreateManyFirstModelFieldInputEnvelope\\";
export * from \\"./SecondModelCreateManyInput\\";
export * from \\"./SecondModelCreateNestedManyWithoutFirstModelFieldInput\\";
export * from \\"./SecondModelCreateOrConnectWithoutFirstModelFieldInput\\";
export * from \\"./SecondModelCreateWithoutFirstModelFieldInput\\";
export * from \\"./SecondModelListRelationFilter\\";
export * from \\"./SecondModelMaxOrderByAggregateInput\\";
export * from \\"./SecondModelMinOrderByAggregateInput\\";
export * from \\"./SecondModelOrderByRelationAggregateInput\\";
export * from \\"./SecondModelOrderByWithAggregationInput\\";
export * from \\"./SecondModelOrderByWithRelationInput\\";
export * from \\"./SecondModelScalarWhereInput\\";
export * from \\"./SecondModelScalarWhereWithAggregatesInput\\";
export * from \\"./SecondModelSumOrderByAggregateInput\\";
export * from \\"./SecondModelUpdateInput\\";
export * from \\"./SecondModelUpdateManyMutationInput\\";
export * from \\"./SecondModelUpdateManyWithWhereWithoutFirstModelFieldInput\\";
export * from \\"./SecondModelUpdateManyWithoutFirstModelFieldNestedInput\\";
export * from \\"./SecondModelUpdateWithWhereUniqueWithoutFirstModelFieldInput\\";
export * from \\"./SecondModelUpdateWithoutFirstModelFieldInput\\";
export * from \\"./SecondModelUpsertWithWhereUniqueWithoutFirstModelFieldInput\\";
export * from \\"./SecondModelWhereInput\\";
export * from \\"./SecondModelWhereUniqueInput\\";
export * from \\"./SortOrderInput\\";
export * from \\"./StringFieldUpdateOperationsInput\\";
export * from \\"./StringFilter\\";
export * from \\"./StringWithAggregatesFilter\\";
"
`;

exports[`inputs should properly generate input type classes with SortOrderInput type fields: index 2`] = `
"export * from \\"./FirstModelAvgOrderByAggregateInput\\";
export * from \\"./FirstModelCountOrderByAggregateInput\\";
export * from \\"./FirstModelCreateInput\\";
export * from \\"./FirstModelCreateManyInput\\";
export * from \\"./FirstModelCreateNestedOneWithoutSecondModelsFieldInput\\";
export * from \\"./FirstModelCreateOrConnectWithoutSecondModelsFieldInput\\";
export * from \\"./FirstModelCreateWithoutSecondModelsFieldInput\\";
export * from \\"./FirstModelMaxOrderByAggregateInput\\";
export * from \\"./FirstModelMinOrderByAggregateInput\\";
export * from \\"./FirstModelOrderByWithAggregationInput\\";
export * from \\"./FirstModelOrderByWithRelationInput\\";
export * from \\"./FirstModelScalarRelationFilter\\";
export * from \\"./FirstModelScalarWhereWithAggregatesInput\\";
export * from \\"./FirstModelSumOrderByAggregateInput\\";
export * from \\"./FirstModelUpdateInput\\";
export * from \\"./FirstModelUpdateManyMutationInput\\";
export * from \\"./FirstModelUpdateOneRequiredWithoutSecondModelsFieldNestedInput\\";
export * from \\"./FirstModelUpdateToOneWithWhereWithoutSecondModelsFieldInput\\";
export * from \\"./FirstModelUpdateWithoutSecondModelsFieldInput\\";
export * from \\"./FirstModelUpsertWithoutSecondModelsFieldInput\\";
export * from \\"./FirstModelWhereInput\\";
export * from \\"./FirstModelWhereUniqueInput\\";
export * from \\"./FloatNullableFilter\\";
export * from \\"./FloatNullableWithAggregatesFilter\\";
export * from \\"./IntFieldUpdateOperationsInput\\";
export * from \\"./IntFilter\\";
export * from \\"./IntWithAggregatesFilter\\";
export * from \\"./NestedFloatFilter\\";
export * from \\"./NestedFloatNullableFilter\\";
export * from \\"./NestedFloatNullableWithAggregatesFilter\\";
export * from \\"./NestedIntFilter\\";
export * from \\"./NestedIntNullableFilter\\";
export * from \\"./NestedIntWithAggregatesFilter\\";
export * from \\"./NestedStringFilter\\";
export * from \\"./NestedStringWithAggregatesFilter\\";
export * from \\"./NullableFloatFieldUpdateOperationsInput\\";
export * from \\"./SecondModelAvgOrderByAggregateInput\\";
export * from \\"./SecondModelCountOrderByAggregateInput\\";
export * from \\"./SecondModelCreateInput\\";
export * from \\"./SecondModelCreateManyFirstModelFieldInput\\";
export * from \\"./SecondModelCreateManyFirstModelFieldInputEnvelope\\";
export * from \\"./SecondModelCreateManyInput\\";
export * from \\"./SecondModelCreateNestedManyWithoutFirstModelFieldInput\\";
export * from \\"./SecondModelCreateOrConnectWithoutFirstModelFieldInput\\";
export * from \\"./SecondModelCreateWithoutFirstModelFieldInput\\";
export * from \\"./SecondModelListRelationFilter\\";
export * from \\"./SecondModelMaxOrderByAggregateInput\\";
export * from \\"./SecondModelMinOrderByAggregateInput\\";
export * from \\"./SecondModelOrderByRelationAggregateInput\\";
export * from \\"./SecondModelOrderByWithAggregationInput\\";
export * from \\"./SecondModelOrderByWithRelationInput\\";
export * from \\"./SecondModelScalarWhereInput\\";
export * from \\"./SecondModelScalarWhereWithAggregatesInput\\";
export * from \\"./SecondModelSumOrderByAggregateInput\\";
export * from \\"./SecondModelUpdateInput\\";
export * from \\"./SecondModelUpdateManyMutationInput\\";
export * from \\"./SecondModelUpdateManyWithWhereWithoutFirstModelFieldInput\\";
export * from \\"./SecondModelUpdateManyWithoutFirstModelFieldNestedInput\\";
export * from \\"./SecondModelUpdateWithWhereUniqueWithoutFirstModelFieldInput\\";
export * from \\"./SecondModelUpdateWithoutFirstModelFieldInput\\";
export * from \\"./SecondModelUpsertWithWhereUniqueWithoutFirstModelFieldInput\\";
export * from \\"./SecondModelWhereInput\\";
export * from \\"./SecondModelWhereUniqueInput\\";
export * from \\"./SortOrderInput\\";
export * from \\"./StringFieldUpdateOperationsInput\\";
export * from \\"./StringFilter\\";
export * from \\"./StringWithAggregatesFilter\\";
"
`;

exports[`inputs should properly generate input type scalar filters classes for model with native types: BigIntNullableFilter 1`] = `
"import { Args, ArgsType, Context, Field, Float, ID, Info, InputType, Int, Mutation, ObjectType, Parent, Query, ResolveField, Resolver, registerEnumType } from \\"@nestjs/graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { Prisma } from \\"../../../../helpers/prisma-client-mock\\";
import { DecimalJSScalar } from \\"../../scalars\\";
import { NestedBigIntNullableFilter } from \\"../inputs\\";

@InputType(\\"BigIntNullableFilter\\", {})
export class BigIntNullableFilter {
  @Field(() => GraphQLScalars.BigIntResolver, {
    nullable: true
  })
  equals?: bigint | undefined;

  @Field(() => [GraphQLScalars.BigIntResolver], {
    nullable: true
  })
  in?: bigint[] | undefined;

  @Field(() => [GraphQLScalars.BigIntResolver], {
    nullable: true
  })
  notIn?: bigint[] | undefined;

  @Field(() => GraphQLScalars.BigIntResolver, {
    nullable: true
  })
  lt?: bigint | undefined;

  @Field(() => GraphQLScalars.BigIntResolver, {
    nullable: true
  })
  lte?: bigint | undefined;

  @Field(() => GraphQLScalars.BigIntResolver, {
    nullable: true
  })
  gt?: bigint | undefined;

  @Field(() => GraphQLScalars.BigIntResolver, {
    nullable: true
  })
  gte?: bigint | undefined;

  @Field(() => NestedBigIntNullableFilter, {
    nullable: true
  })
  not?: NestedBigIntNullableFilter | undefined;
}
"
`;

exports[`inputs should properly generate input type scalar filters classes for model with native types: BigIntNullableWithAggregatesFilter 1`] = `
"import { Args, ArgsType, Context, Field, Float, ID, Info, InputType, Int, Mutation, ObjectType, Parent, Query, ResolveField, Resolver, registerEnumType } from \\"@nestjs/graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { Prisma } from \\"../../../../helpers/prisma-client-mock\\";
import { DecimalJSScalar } from \\"../../scalars\\";
import { NestedBigIntNullableFilter, NestedBigIntNullableWithAggregatesFilter, NestedFloatNullableFilter, NestedIntNullableFilter } from \\"../inputs\\";

@InputType(\\"BigIntNullableWithAggregatesFilter\\", {})
export class BigIntNullableWithAggregatesFilter {
  @Field(() => GraphQLScalars.BigIntResolver, {
    nullable: true
  })
  equals?: bigint | undefined;

  @Field(() => [GraphQLScalars.BigIntResolver], {
    nullable: true
  })
  in?: bigint[] | undefined;

  @Field(() => [GraphQLScalars.BigIntResolver], {
    nullable: true
  })
  notIn?: bigint[] | undefined;

  @Field(() => GraphQLScalars.BigIntResolver, {
    nullable: true
  })
  lt?: bigint | undefined;

  @Field(() => GraphQLScalars.BigIntResolver, {
    nullable: true
  })
  lte?: bigint | undefined;

  @Field(() => GraphQLScalars.BigIntResolver, {
    nullable: true
  })
  gt?: bigint | undefined;

  @Field(() => GraphQLScalars.BigIntResolver, {
    nullable: true
  })
  gte?: bigint | undefined;

  @Field(() => NestedBigIntNullableWithAggregatesFilter, {
    nullable: true
  })
  not?: NestedBigIntNullableWithAggregatesFilter | undefined;

  @Field(() => NestedIntNullableFilter, {
    nullable: true
  })
  _count?: NestedIntNullableFilter | undefined;

  @Field(() => NestedFloatNullableFilter, {
    nullable: true
  })
  _avg?: NestedFloatNullableFilter | undefined;

  @Field(() => NestedBigIntNullableFilter, {
    nullable: true
  })
  _sum?: NestedBigIntNullableFilter | undefined;

  @Field(() => NestedBigIntNullableFilter, {
    nullable: true
  })
  _min?: NestedBigIntNullableFilter | undefined;

  @Field(() => NestedBigIntNullableFilter, {
    nullable: true
  })
  _max?: NestedBigIntNullableFilter | undefined;
}
"
`;

exports[`inputs should properly generate input type scalar filters classes for model with native types: BytesNullableFilter 1`] = `
"import { Args, ArgsType, Context, Field, Float, ID, Info, InputType, Int, Mutation, ObjectType, Parent, Query, ResolveField, Resolver, registerEnumType } from \\"@nestjs/graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { Prisma } from \\"../../../../helpers/prisma-client-mock\\";
import { DecimalJSScalar } from \\"../../scalars\\";
import { NestedBytesNullableFilter } from \\"../inputs\\";

@InputType(\\"BytesNullableFilter\\", {})
export class BytesNullableFilter {
  @Field(() => GraphQLScalars.ByteResolver, {
    nullable: true
  })
  equals?: Buffer | undefined;

  @Field(() => [GraphQLScalars.ByteResolver], {
    nullable: true
  })
  in?: Buffer[] | undefined;

  @Field(() => [GraphQLScalars.ByteResolver], {
    nullable: true
  })
  notIn?: Buffer[] | undefined;

  @Field(() => NestedBytesNullableFilter, {
    nullable: true
  })
  not?: NestedBytesNullableFilter | undefined;
}
"
`;

exports[`inputs should properly generate input type scalar filters classes for model with native types: BytesNullableWithAggregatesFilter 1`] = `
"import { Args, ArgsType, Context, Field, Float, ID, Info, InputType, Int, Mutation, ObjectType, Parent, Query, ResolveField, Resolver, registerEnumType } from \\"@nestjs/graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { Prisma } from \\"../../../../helpers/prisma-client-mock\\";
import { DecimalJSScalar } from \\"../../scalars\\";
import { NestedBytesNullableFilter, NestedBytesNullableWithAggregatesFilter, NestedIntNullableFilter } from \\"../inputs\\";

@InputType(\\"BytesNullableWithAggregatesFilter\\", {})
export class BytesNullableWithAggregatesFilter {
  @Field(() => GraphQLScalars.ByteResolver, {
    nullable: true
  })
  equals?: Buffer | undefined;

  @Field(() => [GraphQLScalars.ByteResolver], {
    nullable: true
  })
  in?: Buffer[] | undefined;

  @Field(() => [GraphQLScalars.ByteResolver], {
    nullable: true
  })
  notIn?: Buffer[] | undefined;

  @Field(() => NestedBytesNullableWithAggregatesFilter, {
    nullable: true
  })
  not?: NestedBytesNullableWithAggregatesFilter | undefined;

  @Field(() => NestedIntNullableFilter, {
    nullable: true
  })
  _count?: NestedIntNullableFilter | undefined;

  @Field(() => NestedBytesNullableFilter, {
    nullable: true
  })
  _min?: NestedBytesNullableFilter | undefined;

  @Field(() => NestedBytesNullableFilter, {
    nullable: true
  })
  _max?: NestedBytesNullableFilter | undefined;
}
"
`;

exports[`inputs should properly generate input type scalar filters classes for model with native types: DecimalNullableFilter 1`] = `
"import { Args, ArgsType, Context, Field, Float, ID, Info, InputType, Int, Mutation, ObjectType, Parent, Query, ResolveField, Resolver, registerEnumType } from \\"@nestjs/graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { Prisma } from \\"../../../../helpers/prisma-client-mock\\";
import { DecimalJSScalar } from \\"../../scalars\\";
import { NestedDecimalNullableFilter } from \\"../inputs\\";

@InputType(\\"DecimalNullableFilter\\", {})
export class DecimalNullableFilter {
  @Field(() => DecimalJSScalar, {
    nullable: true
  })
  equals?: Prisma.Decimal | undefined;

  @Field(() => [DecimalJSScalar], {
    nullable: true
  })
  in?: Prisma.Decimal[] | undefined;

  @Field(() => [DecimalJSScalar], {
    nullable: true
  })
  notIn?: Prisma.Decimal[] | undefined;

  @Field(() => DecimalJSScalar, {
    nullable: true
  })
  lt?: Prisma.Decimal | undefined;

  @Field(() => DecimalJSScalar, {
    nullable: true
  })
  lte?: Prisma.Decimal | undefined;

  @Field(() => DecimalJSScalar, {
    nullable: true
  })
  gt?: Prisma.Decimal | undefined;

  @Field(() => DecimalJSScalar, {
    nullable: true
  })
  gte?: Prisma.Decimal | undefined;

  @Field(() => NestedDecimalNullableFilter, {
    nullable: true
  })
  not?: NestedDecimalNullableFilter | undefined;
}
"
`;

exports[`inputs should properly generate input type scalar filters classes for model with native types: DecimalNullableWithAggregatesFilter 1`] = `
"import { Args, ArgsType, Context, Field, Float, ID, Info, InputType, Int, Mutation, ObjectType, Parent, Query, ResolveField, Resolver, registerEnumType } from \\"@nestjs/graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { Prisma } from \\"../../../../helpers/prisma-client-mock\\";
import { DecimalJSScalar } from \\"../../scalars\\";
import { NestedDecimalNullableFilter, NestedDecimalNullableWithAggregatesFilter, NestedIntNullableFilter } from \\"../inputs\\";

@InputType(\\"DecimalNullableWithAggregatesFilter\\", {})
export class DecimalNullableWithAggregatesFilter {
  @Field(() => DecimalJSScalar, {
    nullable: true
  })
  equals?: Prisma.Decimal | undefined;

  @Field(() => [DecimalJSScalar], {
    nullable: true
  })
  in?: Prisma.Decimal[] | undefined;

  @Field(() => [DecimalJSScalar], {
    nullable: true
  })
  notIn?: Prisma.Decimal[] | undefined;

  @Field(() => DecimalJSScalar, {
    nullable: true
  })
  lt?: Prisma.Decimal | undefined;

  @Field(() => DecimalJSScalar, {
    nullable: true
  })
  lte?: Prisma.Decimal | undefined;

  @Field(() => DecimalJSScalar, {
    nullable: true
  })
  gt?: Prisma.Decimal | undefined;

  @Field(() => DecimalJSScalar, {
    nullable: true
  })
  gte?: Prisma.Decimal | undefined;

  @Field(() => NestedDecimalNullableWithAggregatesFilter, {
    nullable: true
  })
  not?: NestedDecimalNullableWithAggregatesFilter | undefined;

  @Field(() => NestedIntNullableFilter, {
    nullable: true
  })
  _count?: NestedIntNullableFilter | undefined;

  @Field(() => NestedDecimalNullableFilter, {
    nullable: true
  })
  _avg?: NestedDecimalNullableFilter | undefined;

  @Field(() => NestedDecimalNullableFilter, {
    nullable: true
  })
  _sum?: NestedDecimalNullableFilter | undefined;

  @Field(() => NestedDecimalNullableFilter, {
    nullable: true
  })
  _min?: NestedDecimalNullableFilter | undefined;

  @Field(() => NestedDecimalNullableFilter, {
    nullable: true
  })
  _max?: NestedDecimalNullableFilter | undefined;
}
"
`;

exports[`inputs should properly generate input type scalar filters classes for model with native types: NestedBytesNullableFilter 1`] = `
"import { Args, ArgsType, Context, Field, Float, ID, Info, InputType, Int, Mutation, ObjectType, Parent, Query, ResolveField, Resolver, registerEnumType } from \\"@nestjs/graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { Prisma } from \\"../../../../helpers/prisma-client-mock\\";
import { DecimalJSScalar } from \\"../../scalars\\";

@InputType(\\"NestedBytesNullableFilter\\", {})
export class NestedBytesNullableFilter {
  @Field(() => GraphQLScalars.ByteResolver, {
    nullable: true
  })
  equals?: Buffer | undefined;

  @Field(() => [GraphQLScalars.ByteResolver], {
    nullable: true
  })
  in?: Buffer[] | undefined;

  @Field(() => [GraphQLScalars.ByteResolver], {
    nullable: true
  })
  notIn?: Buffer[] | undefined;

  @Field(() => NestedBytesNullableFilter, {
    nullable: true
  })
  not?: NestedBytesNullableFilter | undefined;
}
"
`;

exports[`inputs should properly generate input type scalar filters classes for model with native types: NestedBytesNullableWithAggregatesFilter 1`] = `
"import { Args, ArgsType, Context, Field, Float, ID, Info, InputType, Int, Mutation, ObjectType, Parent, Query, ResolveField, Resolver, registerEnumType } from \\"@nestjs/graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { Prisma } from \\"../../../../helpers/prisma-client-mock\\";
import { DecimalJSScalar } from \\"../../scalars\\";
import { NestedBytesNullableFilter, NestedIntNullableFilter } from \\"../inputs\\";

@InputType(\\"NestedBytesNullableWithAggregatesFilter\\", {})
export class NestedBytesNullableWithAggregatesFilter {
  @Field(() => GraphQLScalars.ByteResolver, {
    nullable: true
  })
  equals?: Buffer | undefined;

  @Field(() => [GraphQLScalars.ByteResolver], {
    nullable: true
  })
  in?: Buffer[] | undefined;

  @Field(() => [GraphQLScalars.ByteResolver], {
    nullable: true
  })
  notIn?: Buffer[] | undefined;

  @Field(() => NestedBytesNullableWithAggregatesFilter, {
    nullable: true
  })
  not?: NestedBytesNullableWithAggregatesFilter | undefined;

  @Field(() => NestedIntNullableFilter, {
    nullable: true
  })
  _count?: NestedIntNullableFilter | undefined;

  @Field(() => NestedBytesNullableFilter, {
    nullable: true
  })
  _min?: NestedBytesNullableFilter | undefined;

  @Field(() => NestedBytesNullableFilter, {
    nullable: true
  })
  _max?: NestedBytesNullableFilter | undefined;
}
"
`;

exports[`inputs should properly generate input type scalar filters classes for model with native types: NestedDecimalNullableFilter 1`] = `
"import { Args, ArgsType, Context, Field, Float, ID, Info, InputType, Int, Mutation, ObjectType, Parent, Query, ResolveField, Resolver, registerEnumType } from \\"@nestjs/graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { Prisma } from \\"../../../../helpers/prisma-client-mock\\";
import { DecimalJSScalar } from \\"../../scalars\\";

@InputType(\\"NestedDecimalNullableFilter\\", {})
export class NestedDecimalNullableFilter {
  @Field(() => DecimalJSScalar, {
    nullable: true
  })
  equals?: Prisma.Decimal | undefined;

  @Field(() => [DecimalJSScalar], {
    nullable: true
  })
  in?: Prisma.Decimal[] | undefined;

  @Field(() => [DecimalJSScalar], {
    nullable: true
  })
  notIn?: Prisma.Decimal[] | undefined;

  @Field(() => DecimalJSScalar, {
    nullable: true
  })
  lt?: Prisma.Decimal | undefined;

  @Field(() => DecimalJSScalar, {
    nullable: true
  })
  lte?: Prisma.Decimal | undefined;

  @Field(() => DecimalJSScalar, {
    nullable: true
  })
  gt?: Prisma.Decimal | undefined;

  @Field(() => DecimalJSScalar, {
    nullable: true
  })
  gte?: Prisma.Decimal | undefined;

  @Field(() => NestedDecimalNullableFilter, {
    nullable: true
  })
  not?: NestedDecimalNullableFilter | undefined;
}
"
`;

exports[`inputs should properly generate input type scalar filters classes for model with native types: NestedDecimalNullableWithAggregatesFilter 1`] = `
"import { Args, ArgsType, Context, Field, Float, ID, Info, InputType, Int, Mutation, ObjectType, Parent, Query, ResolveField, Resolver, registerEnumType } from \\"@nestjs/graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { Prisma } from \\"../../../../helpers/prisma-client-mock\\";
import { DecimalJSScalar } from \\"../../scalars\\";
import { NestedDecimalNullableFilter, NestedIntNullableFilter } from \\"../inputs\\";

@InputType(\\"NestedDecimalNullableWithAggregatesFilter\\", {})
export class NestedDecimalNullableWithAggregatesFilter {
  @Field(() => DecimalJSScalar, {
    nullable: true
  })
  equals?: Prisma.Decimal | undefined;

  @Field(() => [DecimalJSScalar], {
    nullable: true
  })
  in?: Prisma.Decimal[] | undefined;

  @Field(() => [DecimalJSScalar], {
    nullable: true
  })
  notIn?: Prisma.Decimal[] | undefined;

  @Field(() => DecimalJSScalar, {
    nullable: true
  })
  lt?: Prisma.Decimal | undefined;

  @Field(() => DecimalJSScalar, {
    nullable: true
  })
  lte?: Prisma.Decimal | undefined;

  @Field(() => DecimalJSScalar, {
    nullable: true
  })
  gt?: Prisma.Decimal | undefined;

  @Field(() => DecimalJSScalar, {
    nullable: true
  })
  gte?: Prisma.Decimal | undefined;

  @Field(() => NestedDecimalNullableWithAggregatesFilter, {
    nullable: true
  })
  not?: NestedDecimalNullableWithAggregatesFilter | undefined;

  @Field(() => NestedIntNullableFilter, {
    nullable: true
  })
  _count?: NestedIntNullableFilter | undefined;

  @Field(() => NestedDecimalNullableFilter, {
    nullable: true
  })
  _avg?: NestedDecimalNullableFilter | undefined;

  @Field(() => NestedDecimalNullableFilter, {
    nullable: true
  })
  _sum?: NestedDecimalNullableFilter | undefined;

  @Field(() => NestedDecimalNullableFilter, {
    nullable: true
  })
  _min?: NestedDecimalNullableFilter | undefined;

  @Field(() => NestedDecimalNullableFilter, {
    nullable: true
  })
  _max?: NestedDecimalNullableFilter | undefined;
}
"
`;

exports[`inputs should properly generate input type scalar filters classes for model with native types: NullableBigIntFieldUpdateOperationsInput 1`] = `
"import { Args, ArgsType, Context, Field, Float, ID, Info, InputType, Int, Mutation, ObjectType, Parent, Query, ResolveField, Resolver, registerEnumType } from \\"@nestjs/graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { Prisma } from \\"../../../../helpers/prisma-client-mock\\";
import { DecimalJSScalar } from \\"../../scalars\\";

@InputType(\\"NullableBigIntFieldUpdateOperationsInput\\", {})
export class NullableBigIntFieldUpdateOperationsInput {
  @Field(() => GraphQLScalars.BigIntResolver, {
    nullable: true
  })
  set?: bigint | undefined;

  @Field(() => GraphQLScalars.BigIntResolver, {
    nullable: true
  })
  increment?: bigint | undefined;

  @Field(() => GraphQLScalars.BigIntResolver, {
    nullable: true
  })
  decrement?: bigint | undefined;

  @Field(() => GraphQLScalars.BigIntResolver, {
    nullable: true
  })
  multiply?: bigint | undefined;

  @Field(() => GraphQLScalars.BigIntResolver, {
    nullable: true
  })
  divide?: bigint | undefined;
}
"
`;

exports[`inputs should properly generate input type scalar filters classes for model with native types: NullableBytesFieldUpdateOperationsInput 1`] = `
"import { Args, ArgsType, Context, Field, Float, ID, Info, InputType, Int, Mutation, ObjectType, Parent, Query, ResolveField, Resolver, registerEnumType } from \\"@nestjs/graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { Prisma } from \\"../../../../helpers/prisma-client-mock\\";
import { DecimalJSScalar } from \\"../../scalars\\";

@InputType(\\"NullableBytesFieldUpdateOperationsInput\\", {})
export class NullableBytesFieldUpdateOperationsInput {
  @Field(() => GraphQLScalars.ByteResolver, {
    nullable: true
  })
  set?: Buffer | undefined;
}
"
`;

exports[`inputs should properly generate input type scalar filters classes for model with native types: NullableDecimalFieldUpdateOperationsInput 1`] = `
"import { Args, ArgsType, Context, Field, Float, ID, Info, InputType, Int, Mutation, ObjectType, Parent, Query, ResolveField, Resolver, registerEnumType } from \\"@nestjs/graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { Prisma } from \\"../../../../helpers/prisma-client-mock\\";
import { DecimalJSScalar } from \\"../../scalars\\";

@InputType(\\"NullableDecimalFieldUpdateOperationsInput\\", {})
export class NullableDecimalFieldUpdateOperationsInput {
  @Field(() => DecimalJSScalar, {
    nullable: true
  })
  set?: Prisma.Decimal | undefined;

  @Field(() => DecimalJSScalar, {
    nullable: true
  })
  increment?: Prisma.Decimal | undefined;

  @Field(() => DecimalJSScalar, {
    nullable: true
  })
  decrement?: Prisma.Decimal | undefined;

  @Field(() => DecimalJSScalar, {
    nullable: true
  })
  multiply?: Prisma.Decimal | undefined;

  @Field(() => DecimalJSScalar, {
    nullable: true
  })
  divide?: Prisma.Decimal | undefined;
}
"
`;

exports[`inputs should properly generate input type scalar filters classes for model with native types: index 1`] = `
"export * from \\"./BigIntNullableFilter\\";
export * from \\"./BigIntNullableWithAggregatesFilter\\";
export * from \\"./BytesNullableFilter\\";
export * from \\"./BytesNullableWithAggregatesFilter\\";
export * from \\"./DecimalNullableFilter\\";
export * from \\"./DecimalNullableWithAggregatesFilter\\";
export * from \\"./IntFieldUpdateOperationsInput\\";
export * from \\"./IntFilter\\";
export * from \\"./IntWithAggregatesFilter\\";
export * from \\"./NativeTypeModelAvgOrderByAggregateInput\\";
export * from \\"./NativeTypeModelCountOrderByAggregateInput\\";
export * from \\"./NativeTypeModelCreateInput\\";
export * from \\"./NativeTypeModelCreateManyInput\\";
export * from \\"./NativeTypeModelMaxOrderByAggregateInput\\";
export * from \\"./NativeTypeModelMinOrderByAggregateInput\\";
export * from \\"./NativeTypeModelOrderByWithAggregationInput\\";
export * from \\"./NativeTypeModelOrderByWithRelationInput\\";
export * from \\"./NativeTypeModelScalarWhereWithAggregatesInput\\";
export * from \\"./NativeTypeModelSumOrderByAggregateInput\\";
export * from \\"./NativeTypeModelUpdateInput\\";
export * from \\"./NativeTypeModelUpdateManyMutationInput\\";
export * from \\"./NativeTypeModelWhereInput\\";
export * from \\"./NativeTypeModelWhereUniqueInput\\";
export * from \\"./NestedBigIntNullableFilter\\";
export * from \\"./NestedBigIntNullableWithAggregatesFilter\\";
export * from \\"./NestedBytesNullableFilter\\";
export * from \\"./NestedBytesNullableWithAggregatesFilter\\";
export * from \\"./NestedDecimalNullableFilter\\";
export * from \\"./NestedDecimalNullableWithAggregatesFilter\\";
export * from \\"./NestedFloatFilter\\";
export * from \\"./NestedFloatNullableFilter\\";
export * from \\"./NestedIntFilter\\";
export * from \\"./NestedIntNullableFilter\\";
export * from \\"./NestedIntWithAggregatesFilter\\";
export * from \\"./NullableBigIntFieldUpdateOperationsInput\\";
export * from \\"./NullableBytesFieldUpdateOperationsInput\\";
export * from \\"./NullableDecimalFieldUpdateOperationsInput\\";
export * from \\"./SortOrderInput\\";
"
`;

exports[`inputs when \`emitIsAbstract\` generator option is enabled should properly generate input type class decorator options: FirstModelWhereUniqueInput 1`] = `
"import { Args, ArgsType, Context, Field, Float, ID, Info, InputType, Int, Mutation, ObjectType, Parent, Query, ResolveField, Resolver, registerEnumType } from \\"@nestjs/graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { Prisma } from \\"../../../../helpers/prisma-client-mock\\";
import { DecimalJSScalar } from \\"../../scalars\\";
import { FirstModelWhereInput, FloatNullableFilter } from \\"../inputs\\";

@InputType(\\"FirstModelWhereUniqueInput\\", {
  isAbstract: true
})
export class FirstModelWhereUniqueInput {
  @Field(() => Int, {
    nullable: true
  })
  idField?: number | undefined;

  @Field(() => String, {
    nullable: true
  })
  uniqueStringField?: string | undefined;

  @Field(() => [FirstModelWhereInput], {
    nullable: true
  })
  AND?: FirstModelWhereInput[] | undefined;

  @Field(() => [FirstModelWhereInput], {
    nullable: true
  })
  OR?: FirstModelWhereInput[] | undefined;

  @Field(() => [FirstModelWhereInput], {
    nullable: true
  })
  NOT?: FirstModelWhereInput[] | undefined;

  @Field(() => FloatNullableFilter, {
    nullable: true
  })
  optionalFloatField?: FloatNullableFilter | undefined;
}
"
`;

exports[`inputs when \`fullTextSearch\` preview feature is enabled should properly generate input type classes with relevance and string search field: FirstModelOrderByRelevanceInput 1`] = `
"import { Args, ArgsType, Context, Field, Float, ID, Info, InputType, Int, Mutation, ObjectType, Parent, Query, ResolveField, Resolver, registerEnumType } from \\"@nestjs/graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { Prisma } from \\"../../../../helpers/prisma-client-mock\\";
import { DecimalJSScalar } from \\"../../scalars\\";
import { FirstModelOrderByRelevanceFieldEnum } from \\"../../enums/FirstModelOrderByRelevanceFieldEnum\\";
import { SortOrder } from \\"../../enums/SortOrder\\";

@InputType(\\"FirstModelOrderByRelevanceInput\\", {})
export class FirstModelOrderByRelevanceInput {
  @Field(() => [FirstModelOrderByRelevanceFieldEnum], {
    nullable: false
  })
  fields!: \\"uniqueStringField\\"[];

  @Field(() => SortOrder, {
    nullable: false
  })
  sort!: \\"asc\\" | \\"desc\\";

  @Field(() => String, {
    nullable: false
  })
  search!: string;
}
"
`;

exports[`inputs when \`fullTextSearch\` preview feature is enabled should properly generate input type classes with relevance and string search field: FirstModelOrderByWithRelationInput 1`] = `
"import { Args, ArgsType, Context, Field, Float, ID, Info, InputType, Int, Mutation, ObjectType, Parent, Query, ResolveField, Resolver, registerEnumType } from \\"@nestjs/graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { Prisma } from \\"../../../../helpers/prisma-client-mock\\";
import { DecimalJSScalar } from \\"../../scalars\\";
import { FirstModelOrderByRelevanceInput, SecondModelOrderByRelationAggregateInput } from \\"../inputs\\";
import { SortOrder } from \\"../../enums/SortOrder\\";

@InputType(\\"FirstModelOrderByWithRelationInput\\", {})
export class FirstModelOrderByWithRelationInput {
  @Field(() => SortOrder, {
    nullable: true
  })
  idField?: \\"asc\\" | \\"desc\\" | undefined;

  @Field(() => SortOrder, {
    nullable: true
  })
  uniqueStringField?: \\"asc\\" | \\"desc\\" | undefined;

  @Field(() => SortOrder, {
    nullable: true
  })
  floatField?: \\"asc\\" | \\"desc\\" | undefined;

  @Field(() => SecondModelOrderByRelationAggregateInput, {
    nullable: true
  })
  secondModelsField?: SecondModelOrderByRelationAggregateInput | undefined;

  @Field(() => FirstModelOrderByRelevanceInput, {
    nullable: true
  })
  _relevance?: FirstModelOrderByRelevanceInput | undefined;
}
"
`;

exports[`inputs when \`fullTextSearch\` preview feature is enabled should properly generate input type classes with relevance and string search field: NestedStringFilter 1`] = `
"import { Args, ArgsType, Context, Field, Float, ID, Info, InputType, Int, Mutation, ObjectType, Parent, Query, ResolveField, Resolver, registerEnumType } from \\"@nestjs/graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { Prisma } from \\"../../../../helpers/prisma-client-mock\\";
import { DecimalJSScalar } from \\"../../scalars\\";

@InputType(\\"NestedStringFilter\\", {})
export class NestedStringFilter {
  @Field(() => String, {
    nullable: true
  })
  equals?: string | undefined;

  @Field(() => [String], {
    nullable: true
  })
  in?: string[] | undefined;

  @Field(() => [String], {
    nullable: true
  })
  notIn?: string[] | undefined;

  @Field(() => String, {
    nullable: true
  })
  lt?: string | undefined;

  @Field(() => String, {
    nullable: true
  })
  lte?: string | undefined;

  @Field(() => String, {
    nullable: true
  })
  gt?: string | undefined;

  @Field(() => String, {
    nullable: true
  })
  gte?: string | undefined;

  @Field(() => String, {
    nullable: true
  })
  contains?: string | undefined;

  @Field(() => String, {
    nullable: true
  })
  startsWith?: string | undefined;

  @Field(() => String, {
    nullable: true
  })
  endsWith?: string | undefined;

  @Field(() => String, {
    nullable: true
  })
  search?: string | undefined;

  @Field(() => NestedStringFilter, {
    nullable: true
  })
  not?: NestedStringFilter | undefined;
}
"
`;

exports[`inputs when \`fullTextSearch\` preview feature is enabled should properly generate input type classes with relevance and string search field: StringFilter 1`] = `
"import { Args, ArgsType, Context, Field, Float, ID, Info, InputType, Int, Mutation, ObjectType, Parent, Query, ResolveField, Resolver, registerEnumType } from \\"@nestjs/graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { Prisma } from \\"../../../../helpers/prisma-client-mock\\";
import { DecimalJSScalar } from \\"../../scalars\\";
import { NestedStringFilter } from \\"../inputs\\";
import { QueryMode } from \\"../../enums/QueryMode\\";

@InputType(\\"StringFilter\\", {})
export class StringFilter {
  @Field(() => String, {
    nullable: true
  })
  equals?: string | undefined;

  @Field(() => [String], {
    nullable: true
  })
  in?: string[] | undefined;

  @Field(() => [String], {
    nullable: true
  })
  notIn?: string[] | undefined;

  @Field(() => String, {
    nullable: true
  })
  lt?: string | undefined;

  @Field(() => String, {
    nullable: true
  })
  lte?: string | undefined;

  @Field(() => String, {
    nullable: true
  })
  gt?: string | undefined;

  @Field(() => String, {
    nullable: true
  })
  gte?: string | undefined;

  @Field(() => String, {
    nullable: true
  })
  contains?: string | undefined;

  @Field(() => String, {
    nullable: true
  })
  startsWith?: string | undefined;

  @Field(() => String, {
    nullable: true
  })
  endsWith?: string | undefined;

  @Field(() => String, {
    nullable: true
  })
  search?: string | undefined;

  @Field(() => QueryMode, {
    nullable: true
  })
  mode?: \\"default\\" | \\"insensitive\\" | undefined;

  @Field(() => NestedStringFilter, {
    nullable: true
  })
  not?: NestedStringFilter | undefined;
}
"
`;

exports[`inputs when \`fullTextSearch\` preview feature is enabled should properly generate input type classes with relevance and string search field: index 1`] = `
"export * from \\"./FirstModelAvgOrderByAggregateInput\\";
export * from \\"./FirstModelCountOrderByAggregateInput\\";
export * from \\"./FirstModelCreateInput\\";
export * from \\"./FirstModelCreateManyInput\\";
export * from \\"./FirstModelCreateNestedOneWithoutSecondModelsFieldInput\\";
export * from \\"./FirstModelCreateOrConnectWithoutSecondModelsFieldInput\\";
export * from \\"./FirstModelCreateWithoutSecondModelsFieldInput\\";
export * from \\"./FirstModelMaxOrderByAggregateInput\\";
export * from \\"./FirstModelMinOrderByAggregateInput\\";
export * from \\"./FirstModelOrderByRelevanceInput\\";
export * from \\"./FirstModelOrderByWithAggregationInput\\";
export * from \\"./FirstModelOrderByWithRelationInput\\";
export * from \\"./FirstModelScalarRelationFilter\\";
export * from \\"./FirstModelScalarWhereWithAggregatesInput\\";
export * from \\"./FirstModelSumOrderByAggregateInput\\";
export * from \\"./FirstModelUpdateInput\\";
export * from \\"./FirstModelUpdateManyMutationInput\\";
export * from \\"./FirstModelUpdateOneRequiredWithoutSecondModelsFieldNestedInput\\";
export * from \\"./FirstModelUpdateToOneWithWhereWithoutSecondModelsFieldInput\\";
export * from \\"./FirstModelUpdateWithoutSecondModelsFieldInput\\";
export * from \\"./FirstModelUpsertWithoutSecondModelsFieldInput\\";
export * from \\"./FirstModelWhereInput\\";
export * from \\"./FirstModelWhereUniqueInput\\";
export * from \\"./FloatFieldUpdateOperationsInput\\";
export * from \\"./FloatFilter\\";
export * from \\"./FloatWithAggregatesFilter\\";
export * from \\"./IntFieldUpdateOperationsInput\\";
export * from \\"./IntFilter\\";
export * from \\"./IntWithAggregatesFilter\\";
export * from \\"./NestedFloatFilter\\";
export * from \\"./NestedFloatWithAggregatesFilter\\";
export * from \\"./NestedIntFilter\\";
export * from \\"./NestedIntWithAggregatesFilter\\";
export * from \\"./NestedStringFilter\\";
export * from \\"./NestedStringWithAggregatesFilter\\";
export * from \\"./SecondModelAvgOrderByAggregateInput\\";
export * from \\"./SecondModelCountOrderByAggregateInput\\";
export * from \\"./SecondModelCreateInput\\";
export * from \\"./SecondModelCreateManyFirstModelFieldInput\\";
export * from \\"./SecondModelCreateManyFirstModelFieldInputEnvelope\\";
export * from \\"./SecondModelCreateManyInput\\";
export * from \\"./SecondModelCreateNestedManyWithoutFirstModelFieldInput\\";
export * from \\"./SecondModelCreateOrConnectWithoutFirstModelFieldInput\\";
export * from \\"./SecondModelCreateWithoutFirstModelFieldInput\\";
export * from \\"./SecondModelListRelationFilter\\";
export * from \\"./SecondModelMaxOrderByAggregateInput\\";
export * from \\"./SecondModelMinOrderByAggregateInput\\";
export * from \\"./SecondModelOrderByRelationAggregateInput\\";
export * from \\"./SecondModelOrderByRelevanceInput\\";
export * from \\"./SecondModelOrderByWithAggregationInput\\";
export * from \\"./SecondModelOrderByWithRelationInput\\";
export * from \\"./SecondModelScalarWhereInput\\";
export * from \\"./SecondModelScalarWhereWithAggregatesInput\\";
export * from \\"./SecondModelSumOrderByAggregateInput\\";
export * from \\"./SecondModelUpdateInput\\";
export * from \\"./SecondModelUpdateManyMutationInput\\";
export * from \\"./SecondModelUpdateManyWithWhereWithoutFirstModelFieldInput\\";
export * from \\"./SecondModelUpdateManyWithoutFirstModelFieldNestedInput\\";
export * from \\"./SecondModelUpdateWithWhereUniqueWithoutFirstModelFieldInput\\";
export * from \\"./SecondModelUpdateWithoutFirstModelFieldInput\\";
export * from \\"./SecondModelUpsertWithWhereUniqueWithoutFirstModelFieldInput\\";
export * from \\"./SecondModelWhereInput\\";
export * from \\"./SecondModelWhereUniqueInput\\";
export * from \\"./StringFieldUpdateOperationsInput\\";
export * from \\"./StringFilter\\";
export * from \\"./StringWithAggregatesFilter\\";
"
`;

exports[`inputs when model field is renamed should properly generate input type classes: SampleOrderByWithRelationInput 1`] = `
"import { Args, ArgsType, Context, Field, Float, ID, Info, InputType, Int, Mutation, ObjectType, Parent, Query, ResolveField, Resolver, registerEnumType } from \\"@nestjs/graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { Prisma } from \\"../../../../helpers/prisma-client-mock\\";
import { DecimalJSScalar } from \\"../../scalars\\";
import { SortOrder } from \\"../../enums/SortOrder\\";

@InputType(\\"SampleOrderByWithRelationInput\\", {})
export class SampleOrderByWithRelationInput {
  @Field(() => SortOrder, {
    nullable: true
  })
  idField?: \\"asc\\" | \\"desc\\" | undefined;

  modelFieldName?: \\"asc\\" | \\"desc\\" | undefined;

  @Field(() => SortOrder, {
    nullable: true
  })
  get mappedFieldName() {
    return this.modelFieldName;
  }

  set mappedFieldName(modelFieldName: \\"asc\\" | \\"desc\\" | undefined) {
    this.modelFieldName = modelFieldName;
  }
}
"
`;

exports[`inputs when model field is renamed should properly generate input type classes: SampleWhereInput 1`] = `
"import { Args, ArgsType, Context, Field, Float, ID, Info, InputType, Int, Mutation, ObjectType, Parent, Query, ResolveField, Resolver, registerEnumType } from \\"@nestjs/graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { Prisma } from \\"../../../../helpers/prisma-client-mock\\";
import { DecimalJSScalar } from \\"../../scalars\\";
import { IntFilter, StringFilter } from \\"../inputs\\";

@InputType(\\"SampleWhereInput\\", {})
export class SampleWhereInput {
  @Field(() => [SampleWhereInput], {
    nullable: true
  })
  AND?: SampleWhereInput[] | undefined;

  @Field(() => [SampleWhereInput], {
    nullable: true
  })
  OR?: SampleWhereInput[] | undefined;

  @Field(() => [SampleWhereInput], {
    nullable: true
  })
  NOT?: SampleWhereInput[] | undefined;

  @Field(() => IntFilter, {
    nullable: true
  })
  idField?: IntFilter | undefined;

  modelFieldName?: StringFilter | undefined;

  @Field(() => StringFilter, {
    nullable: true
  })
  get mappedFieldName() {
    return this.modelFieldName;
  }

  set mappedFieldName(modelFieldName: StringFilter | undefined) {
    this.modelFieldName = modelFieldName;
  }
}
"
`;

exports[`inputs when model field is renamed should properly generate input type classes: index 1`] = `
"export * from \\"./IntFieldUpdateOperationsInput\\";
export * from \\"./IntFilter\\";
export * from \\"./IntWithAggregatesFilter\\";
export * from \\"./NestedFloatFilter\\";
export * from \\"./NestedIntFilter\\";
export * from \\"./NestedIntWithAggregatesFilter\\";
export * from \\"./NestedStringFilter\\";
export * from \\"./NestedStringWithAggregatesFilter\\";
export * from \\"./SampleAvgOrderByAggregateInput\\";
export * from \\"./SampleCountOrderByAggregateInput\\";
export * from \\"./SampleCreateInput\\";
export * from \\"./SampleCreateManyInput\\";
export * from \\"./SampleMaxOrderByAggregateInput\\";
export * from \\"./SampleMinOrderByAggregateInput\\";
export * from \\"./SampleOrderByWithAggregationInput\\";
export * from \\"./SampleOrderByWithRelationInput\\";
export * from \\"./SampleScalarWhereWithAggregatesInput\\";
export * from \\"./SampleSumOrderByAggregateInput\\";
export * from \\"./SampleUpdateInput\\";
export * from \\"./SampleUpdateManyMutationInput\\";
export * from \\"./SampleWhereInput\\";
export * from \\"./SampleWhereUniqueInput\\";
export * from \\"./StringFieldUpdateOperationsInput\\";
export * from \\"./StringFilter\\";
export * from \\"./StringWithAggregatesFilter\\";
"
`;

exports[`inputs when model is renamed should properly generate input type classes for filtering models by many to many relation fields: RenamedFirstModelOrderByWithRelationInput 1`] = `
"import { Args, ArgsType, Context, Field, Float, ID, Info, InputType, Int, Mutation, ObjectType, Parent, Query, ResolveField, Resolver, registerEnumType } from \\"@nestjs/graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { Prisma } from \\"../../../../helpers/prisma-client-mock\\";
import { DecimalJSScalar } from \\"../../scalars\\";
import { RenamedSecondModelOrderByRelationAggregateInput } from \\"../inputs\\";
import { SortOrder } from \\"../../enums/SortOrder\\";

@InputType(\\"RenamedFirstModelOrderByWithRelationInput\\", {})
export class RenamedFirstModelOrderByWithRelationInput {
  @Field(() => SortOrder, {
    nullable: true
  })
  idField?: \\"asc\\" | \\"desc\\" | undefined;

  @Field(() => SortOrder, {
    nullable: true
  })
  uniqueStringField?: \\"asc\\" | \\"desc\\" | undefined;

  @Field(() => SortOrder, {
    nullable: true
  })
  floatField?: \\"asc\\" | \\"desc\\" | undefined;

  @Field(() => RenamedSecondModelOrderByRelationAggregateInput, {
    nullable: true
  })
  secondModelsField?: RenamedSecondModelOrderByRelationAggregateInput | undefined;
}
"
`;

exports[`inputs when model is renamed should properly generate input type classes for filtering models by many to many relation fields: RenamedFirstModelScalarWhereInput 1`] = `
"import { Args, ArgsType, Context, Field, Float, ID, Info, InputType, Int, Mutation, ObjectType, Parent, Query, ResolveField, Resolver, registerEnumType } from \\"@nestjs/graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { Prisma } from \\"../../../../helpers/prisma-client-mock\\";
import { DecimalJSScalar } from \\"../../scalars\\";
import { FloatFilter, IntFilter, StringFilter } from \\"../inputs\\";

@InputType(\\"RenamedFirstModelScalarWhereInput\\", {})
export class RenamedFirstModelScalarWhereInput {
  @Field(() => [RenamedFirstModelScalarWhereInput], {
    nullable: true
  })
  AND?: RenamedFirstModelScalarWhereInput[] | undefined;

  @Field(() => [RenamedFirstModelScalarWhereInput], {
    nullable: true
  })
  OR?: RenamedFirstModelScalarWhereInput[] | undefined;

  @Field(() => [RenamedFirstModelScalarWhereInput], {
    nullable: true
  })
  NOT?: RenamedFirstModelScalarWhereInput[] | undefined;

  @Field(() => IntFilter, {
    nullable: true
  })
  idField?: IntFilter | undefined;

  @Field(() => StringFilter, {
    nullable: true
  })
  uniqueStringField?: StringFilter | undefined;

  @Field(() => FloatFilter, {
    nullable: true
  })
  floatField?: FloatFilter | undefined;
}
"
`;

exports[`inputs when model is renamed should properly generate input type classes for filtering models by many to many relation fields: RenamedFirstModelWhereInput 1`] = `
"import { Args, ArgsType, Context, Field, Float, ID, Info, InputType, Int, Mutation, ObjectType, Parent, Query, ResolveField, Resolver, registerEnumType } from \\"@nestjs/graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { Prisma } from \\"../../../../helpers/prisma-client-mock\\";
import { DecimalJSScalar } from \\"../../scalars\\";
import { FloatFilter, IntFilter, RenamedSecondModelListRelationFilter, StringFilter } from \\"../inputs\\";

@InputType(\\"RenamedFirstModelWhereInput\\", {})
export class RenamedFirstModelWhereInput {
  @Field(() => [RenamedFirstModelWhereInput], {
    nullable: true
  })
  AND?: RenamedFirstModelWhereInput[] | undefined;

  @Field(() => [RenamedFirstModelWhereInput], {
    nullable: true
  })
  OR?: RenamedFirstModelWhereInput[] | undefined;

  @Field(() => [RenamedFirstModelWhereInput], {
    nullable: true
  })
  NOT?: RenamedFirstModelWhereInput[] | undefined;

  @Field(() => IntFilter, {
    nullable: true
  })
  idField?: IntFilter | undefined;

  @Field(() => StringFilter, {
    nullable: true
  })
  uniqueStringField?: StringFilter | undefined;

  @Field(() => FloatFilter, {
    nullable: true
  })
  floatField?: FloatFilter | undefined;

  @Field(() => RenamedSecondModelListRelationFilter, {
    nullable: true
  })
  secondModelsField?: RenamedSecondModelListRelationFilter | undefined;
}
"
`;

exports[`inputs when model is renamed should properly generate input type classes for filtering models by many to many relation fields: RenamedFirstModelWhereUniqueInput 1`] = `
"import { Args, ArgsType, Context, Field, Float, ID, Info, InputType, Int, Mutation, ObjectType, Parent, Query, ResolveField, Resolver, registerEnumType } from \\"@nestjs/graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { Prisma } from \\"../../../../helpers/prisma-client-mock\\";
import { DecimalJSScalar } from \\"../../scalars\\";
import { FloatFilter, RenamedFirstModelWhereInput, RenamedSecondModelListRelationFilter } from \\"../inputs\\";

@InputType(\\"RenamedFirstModelWhereUniqueInput\\", {})
export class RenamedFirstModelWhereUniqueInput {
  @Field(() => Int, {
    nullable: true
  })
  idField?: number | undefined;

  @Field(() => String, {
    nullable: true
  })
  uniqueStringField?: string | undefined;

  @Field(() => [RenamedFirstModelWhereInput], {
    nullable: true
  })
  AND?: RenamedFirstModelWhereInput[] | undefined;

  @Field(() => [RenamedFirstModelWhereInput], {
    nullable: true
  })
  OR?: RenamedFirstModelWhereInput[] | undefined;

  @Field(() => [RenamedFirstModelWhereInput], {
    nullable: true
  })
  NOT?: RenamedFirstModelWhereInput[] | undefined;

  @Field(() => FloatFilter, {
    nullable: true
  })
  floatField?: FloatFilter | undefined;

  @Field(() => RenamedSecondModelListRelationFilter, {
    nullable: true
  })
  secondModelsField?: RenamedSecondModelListRelationFilter | undefined;
}
"
`;

exports[`inputs when model is renamed should properly generate input type classes for filtering models by many to many relation fields: index 1`] = `
"export * from \\"./FloatFieldUpdateOperationsInput\\";
export * from \\"./FloatFilter\\";
export * from \\"./FloatWithAggregatesFilter\\";
export * from \\"./IntFieldUpdateOperationsInput\\";
export * from \\"./IntFilter\\";
export * from \\"./IntWithAggregatesFilter\\";
export * from \\"./NestedFloatFilter\\";
export * from \\"./NestedFloatWithAggregatesFilter\\";
export * from \\"./NestedIntFilter\\";
export * from \\"./NestedIntWithAggregatesFilter\\";
export * from \\"./NestedStringFilter\\";
export * from \\"./NestedStringWithAggregatesFilter\\";
export * from \\"./RenamedFirstModelAvgOrderByAggregateInput\\";
export * from \\"./RenamedFirstModelCountOrderByAggregateInput\\";
export * from \\"./RenamedFirstModelCreateInput\\";
export * from \\"./RenamedFirstModelCreateManyInput\\";
export * from \\"./RenamedFirstModelCreateNestedManyWithoutSecondModelsFieldInput\\";
export * from \\"./RenamedFirstModelCreateOrConnectWithoutSecondModelsFieldInput\\";
export * from \\"./RenamedFirstModelCreateWithoutSecondModelsFieldInput\\";
export * from \\"./RenamedFirstModelListRelationFilter\\";
export * from \\"./RenamedFirstModelMaxOrderByAggregateInput\\";
export * from \\"./RenamedFirstModelMinOrderByAggregateInput\\";
export * from \\"./RenamedFirstModelOrderByRelationAggregateInput\\";
export * from \\"./RenamedFirstModelOrderByWithAggregationInput\\";
export * from \\"./RenamedFirstModelOrderByWithRelationInput\\";
export * from \\"./RenamedFirstModelScalarWhereInput\\";
export * from \\"./RenamedFirstModelScalarWhereWithAggregatesInput\\";
export * from \\"./RenamedFirstModelSumOrderByAggregateInput\\";
export * from \\"./RenamedFirstModelUpdateInput\\";
export * from \\"./RenamedFirstModelUpdateManyMutationInput\\";
export * from \\"./RenamedFirstModelUpdateManyWithWhereWithoutSecondModelsFieldInput\\";
export * from \\"./RenamedFirstModelUpdateManyWithoutSecondModelsFieldNestedInput\\";
export * from \\"./RenamedFirstModelUpdateWithWhereUniqueWithoutSecondModelsFieldInput\\";
export * from \\"./RenamedFirstModelUpdateWithoutSecondModelsFieldInput\\";
export * from \\"./RenamedFirstModelUpsertWithWhereUniqueWithoutSecondModelsFieldInput\\";
export * from \\"./RenamedFirstModelWhereInput\\";
export * from \\"./RenamedFirstModelWhereUniqueInput\\";
export * from \\"./RenamedSecondModelAvgOrderByAggregateInput\\";
export * from \\"./RenamedSecondModelCountOrderByAggregateInput\\";
export * from \\"./RenamedSecondModelCreateInput\\";
export * from \\"./RenamedSecondModelCreateManyInput\\";
export * from \\"./RenamedSecondModelCreateNestedManyWithoutFirstModelsFieldInput\\";
export * from \\"./RenamedSecondModelCreateOrConnectWithoutFirstModelsFieldInput\\";
export * from \\"./RenamedSecondModelCreateWithoutFirstModelsFieldInput\\";
export * from \\"./RenamedSecondModelListRelationFilter\\";
export * from \\"./RenamedSecondModelMaxOrderByAggregateInput\\";
export * from \\"./RenamedSecondModelMinOrderByAggregateInput\\";
export * from \\"./RenamedSecondModelOrderByRelationAggregateInput\\";
export * from \\"./RenamedSecondModelOrderByWithAggregationInput\\";
export * from \\"./RenamedSecondModelOrderByWithRelationInput\\";
export * from \\"./RenamedSecondModelScalarWhereInput\\";
export * from \\"./RenamedSecondModelScalarWhereWithAggregatesInput\\";
export * from \\"./RenamedSecondModelSumOrderByAggregateInput\\";
export * from \\"./RenamedSecondModelUpdateInput\\";
export * from \\"./RenamedSecondModelUpdateManyMutationInput\\";
export * from \\"./RenamedSecondModelUpdateManyWithWhereWithoutFirstModelsFieldInput\\";
export * from \\"./RenamedSecondModelUpdateManyWithoutFirstModelsFieldNestedInput\\";
export * from \\"./RenamedSecondModelUpdateWithWhereUniqueWithoutFirstModelsFieldInput\\";
export * from \\"./RenamedSecondModelUpdateWithoutFirstModelsFieldInput\\";
export * from \\"./RenamedSecondModelUpsertWithWhereUniqueWithoutFirstModelsFieldInput\\";
export * from \\"./RenamedSecondModelWhereInput\\";
export * from \\"./RenamedSecondModelWhereUniqueInput\\";
export * from \\"./StringFieldUpdateOperationsInput\\";
export * from \\"./StringFilter\\";
export * from \\"./StringWithAggregatesFilter\\";
"
`;

exports[`inputs when model is renamed should properly generate input type classes for filtering models by one to many relation fields: FirstModelScalarRelationFilter 1`] = `
"import { Args, ArgsType, Context, Field, Float, ID, Info, InputType, Int, Mutation, ObjectType, Parent, Query, ResolveField, Resolver, registerEnumType } from \\"@nestjs/graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { Prisma } from \\"../../../../helpers/prisma-client-mock\\";
import { DecimalJSScalar } from \\"../../scalars\\";
import { RenamedFirstModelWhereInput } from \\"../inputs\\";

@InputType(\\"FirstModelScalarRelationFilter\\", {})
export class FirstModelScalarRelationFilter {
  @Field(() => RenamedFirstModelWhereInput, {
    nullable: true
  })
  is?: RenamedFirstModelWhereInput | undefined;

  @Field(() => RenamedFirstModelWhereInput, {
    nullable: true
  })
  isNot?: RenamedFirstModelWhereInput | undefined;
}
"
`;

exports[`inputs when model is renamed should properly generate input type classes for filtering models by one to many relation fields: RenamedFirstModelOrderByWithRelationInput 1`] = `
"import { Args, ArgsType, Context, Field, Float, ID, Info, InputType, Int, Mutation, ObjectType, Parent, Query, ResolveField, Resolver, registerEnumType } from \\"@nestjs/graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { Prisma } from \\"../../../../helpers/prisma-client-mock\\";
import { DecimalJSScalar } from \\"../../scalars\\";
import { RenamedSecondModelOrderByRelationAggregateInput } from \\"../inputs\\";
import { SortOrder } from \\"../../enums/SortOrder\\";

@InputType(\\"RenamedFirstModelOrderByWithRelationInput\\", {})
export class RenamedFirstModelOrderByWithRelationInput {
  @Field(() => SortOrder, {
    nullable: true
  })
  idField?: \\"asc\\" | \\"desc\\" | undefined;

  @Field(() => SortOrder, {
    nullable: true
  })
  uniqueStringField?: \\"asc\\" | \\"desc\\" | undefined;

  @Field(() => SortOrder, {
    nullable: true
  })
  floatField?: \\"asc\\" | \\"desc\\" | undefined;

  @Field(() => RenamedSecondModelOrderByRelationAggregateInput, {
    nullable: true
  })
  secondModelsField?: RenamedSecondModelOrderByRelationAggregateInput | undefined;
}
"
`;

exports[`inputs when model is renamed should properly generate input type classes for filtering models by one to many relation fields: RenamedFirstModelWhereInput 1`] = `
"import { Args, ArgsType, Context, Field, Float, ID, Info, InputType, Int, Mutation, ObjectType, Parent, Query, ResolveField, Resolver, registerEnumType } from \\"@nestjs/graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { Prisma } from \\"../../../../helpers/prisma-client-mock\\";
import { DecimalJSScalar } from \\"../../scalars\\";
import { FloatFilter, IntFilter, RenamedSecondModelListRelationFilter, StringFilter } from \\"../inputs\\";

@InputType(\\"RenamedFirstModelWhereInput\\", {})
export class RenamedFirstModelWhereInput {
  @Field(() => [RenamedFirstModelWhereInput], {
    nullable: true
  })
  AND?: RenamedFirstModelWhereInput[] | undefined;

  @Field(() => [RenamedFirstModelWhereInput], {
    nullable: true
  })
  OR?: RenamedFirstModelWhereInput[] | undefined;

  @Field(() => [RenamedFirstModelWhereInput], {
    nullable: true
  })
  NOT?: RenamedFirstModelWhereInput[] | undefined;

  @Field(() => IntFilter, {
    nullable: true
  })
  idField?: IntFilter | undefined;

  @Field(() => StringFilter, {
    nullable: true
  })
  uniqueStringField?: StringFilter | undefined;

  @Field(() => FloatFilter, {
    nullable: true
  })
  floatField?: FloatFilter | undefined;

  @Field(() => RenamedSecondModelListRelationFilter, {
    nullable: true
  })
  secondModelsField?: RenamedSecondModelListRelationFilter | undefined;
}
"
`;

exports[`inputs when model is renamed should properly generate input type classes for filtering models by one to many relation fields: RenamedFirstModelWhereUniqueInput 1`] = `
"import { Args, ArgsType, Context, Field, Float, ID, Info, InputType, Int, Mutation, ObjectType, Parent, Query, ResolveField, Resolver, registerEnumType } from \\"@nestjs/graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { Prisma } from \\"../../../../helpers/prisma-client-mock\\";
import { DecimalJSScalar } from \\"../../scalars\\";
import { FloatFilter, RenamedFirstModelWhereInput, RenamedSecondModelListRelationFilter } from \\"../inputs\\";

@InputType(\\"RenamedFirstModelWhereUniqueInput\\", {})
export class RenamedFirstModelWhereUniqueInput {
  @Field(() => Int, {
    nullable: true
  })
  idField?: number | undefined;

  @Field(() => String, {
    nullable: true
  })
  uniqueStringField?: string | undefined;

  @Field(() => [RenamedFirstModelWhereInput], {
    nullable: true
  })
  AND?: RenamedFirstModelWhereInput[] | undefined;

  @Field(() => [RenamedFirstModelWhereInput], {
    nullable: true
  })
  OR?: RenamedFirstModelWhereInput[] | undefined;

  @Field(() => [RenamedFirstModelWhereInput], {
    nullable: true
  })
  NOT?: RenamedFirstModelWhereInput[] | undefined;

  @Field(() => FloatFilter, {
    nullable: true
  })
  floatField?: FloatFilter | undefined;

  @Field(() => RenamedSecondModelListRelationFilter, {
    nullable: true
  })
  secondModelsField?: RenamedSecondModelListRelationFilter | undefined;
}
"
`;

exports[`inputs when model is renamed should properly generate input type classes for filtering models by one to many relation fields: RenamedSecondModelListRelationFilter 1`] = `
"import { Args, ArgsType, Context, Field, Float, ID, Info, InputType, Int, Mutation, ObjectType, Parent, Query, ResolveField, Resolver, registerEnumType } from \\"@nestjs/graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { Prisma } from \\"../../../../helpers/prisma-client-mock\\";
import { DecimalJSScalar } from \\"../../scalars\\";
import { RenamedSecondModelWhereInput } from \\"../inputs\\";

@InputType(\\"RenamedSecondModelListRelationFilter\\", {})
export class RenamedSecondModelListRelationFilter {
  @Field(() => RenamedSecondModelWhereInput, {
    nullable: true
  })
  every?: RenamedSecondModelWhereInput | undefined;

  @Field(() => RenamedSecondModelWhereInput, {
    nullable: true
  })
  some?: RenamedSecondModelWhereInput | undefined;

  @Field(() => RenamedSecondModelWhereInput, {
    nullable: true
  })
  none?: RenamedSecondModelWhereInput | undefined;
}
"
`;

exports[`inputs when model is renamed should properly generate input type classes for filtering models by one to many relation fields: RenamedSecondModelOrderByWithRelationInput 1`] = `
"import { Args, ArgsType, Context, Field, Float, ID, Info, InputType, Int, Mutation, ObjectType, Parent, Query, ResolveField, Resolver, registerEnumType } from \\"@nestjs/graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { Prisma } from \\"../../../../helpers/prisma-client-mock\\";
import { DecimalJSScalar } from \\"../../scalars\\";
import { RenamedFirstModelOrderByWithRelationInput } from \\"../inputs\\";
import { SortOrder } from \\"../../enums/SortOrder\\";

@InputType(\\"RenamedSecondModelOrderByWithRelationInput\\", {})
export class RenamedSecondModelOrderByWithRelationInput {
  @Field(() => SortOrder, {
    nullable: true
  })
  idField?: \\"asc\\" | \\"desc\\" | undefined;

  @Field(() => SortOrder, {
    nullable: true
  })
  uniqueStringField?: \\"asc\\" | \\"desc\\" | undefined;

  @Field(() => SortOrder, {
    nullable: true
  })
  floatField?: \\"asc\\" | \\"desc\\" | undefined;

  @Field(() => SortOrder, {
    nullable: true
  })
  firstModelFieldId?: \\"asc\\" | \\"desc\\" | undefined;

  @Field(() => RenamedFirstModelOrderByWithRelationInput, {
    nullable: true
  })
  firstModelField?: RenamedFirstModelOrderByWithRelationInput | undefined;
}
"
`;

exports[`inputs when model is renamed should properly generate input type classes for filtering models by one to many relation fields: RenamedSecondModelScalarWhereInput 1`] = `
"import { Args, ArgsType, Context, Field, Float, ID, Info, InputType, Int, Mutation, ObjectType, Parent, Query, ResolveField, Resolver, registerEnumType } from \\"@nestjs/graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { Prisma } from \\"../../../../helpers/prisma-client-mock\\";
import { DecimalJSScalar } from \\"../../scalars\\";
import { FloatFilter, IntFilter, StringFilter } from \\"../inputs\\";

@InputType(\\"RenamedSecondModelScalarWhereInput\\", {})
export class RenamedSecondModelScalarWhereInput {
  @Field(() => [RenamedSecondModelScalarWhereInput], {
    nullable: true
  })
  AND?: RenamedSecondModelScalarWhereInput[] | undefined;

  @Field(() => [RenamedSecondModelScalarWhereInput], {
    nullable: true
  })
  OR?: RenamedSecondModelScalarWhereInput[] | undefined;

  @Field(() => [RenamedSecondModelScalarWhereInput], {
    nullable: true
  })
  NOT?: RenamedSecondModelScalarWhereInput[] | undefined;

  @Field(() => IntFilter, {
    nullable: true
  })
  idField?: IntFilter | undefined;

  @Field(() => StringFilter, {
    nullable: true
  })
  uniqueStringField?: StringFilter | undefined;

  @Field(() => FloatFilter, {
    nullable: true
  })
  floatField?: FloatFilter | undefined;

  @Field(() => IntFilter, {
    nullable: true
  })
  firstModelFieldId?: IntFilter | undefined;
}
"
`;

exports[`inputs when model is renamed should properly generate input type classes for filtering models by one to many relation fields: RenamedSecondModelWhereInput 1`] = `
"import { Args, ArgsType, Context, Field, Float, ID, Info, InputType, Int, Mutation, ObjectType, Parent, Query, ResolveField, Resolver, registerEnumType } from \\"@nestjs/graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { Prisma } from \\"../../../../helpers/prisma-client-mock\\";
import { DecimalJSScalar } from \\"../../scalars\\";
import { FirstModelScalarRelationFilter, FloatFilter, IntFilter, StringFilter } from \\"../inputs\\";

@InputType(\\"RenamedSecondModelWhereInput\\", {})
export class RenamedSecondModelWhereInput {
  @Field(() => [RenamedSecondModelWhereInput], {
    nullable: true
  })
  AND?: RenamedSecondModelWhereInput[] | undefined;

  @Field(() => [RenamedSecondModelWhereInput], {
    nullable: true
  })
  OR?: RenamedSecondModelWhereInput[] | undefined;

  @Field(() => [RenamedSecondModelWhereInput], {
    nullable: true
  })
  NOT?: RenamedSecondModelWhereInput[] | undefined;

  @Field(() => IntFilter, {
    nullable: true
  })
  idField?: IntFilter | undefined;

  @Field(() => StringFilter, {
    nullable: true
  })
  uniqueStringField?: StringFilter | undefined;

  @Field(() => FloatFilter, {
    nullable: true
  })
  floatField?: FloatFilter | undefined;

  @Field(() => IntFilter, {
    nullable: true
  })
  firstModelFieldId?: IntFilter | undefined;

  @Field(() => FirstModelScalarRelationFilter, {
    nullable: true
  })
  firstModelField?: FirstModelScalarRelationFilter | undefined;
}
"
`;

exports[`inputs when model is renamed should properly generate input type classes for filtering models by one to many relation fields: RenamedSecondModelWhereUniqueInput 1`] = `
"import { Args, ArgsType, Context, Field, Float, ID, Info, InputType, Int, Mutation, ObjectType, Parent, Query, ResolveField, Resolver, registerEnumType } from \\"@nestjs/graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { Prisma } from \\"../../../../helpers/prisma-client-mock\\";
import { DecimalJSScalar } from \\"../../scalars\\";
import { FirstModelScalarRelationFilter, FloatFilter, IntFilter, RenamedSecondModelWhereInput } from \\"../inputs\\";

@InputType(\\"RenamedSecondModelWhereUniqueInput\\", {})
export class RenamedSecondModelWhereUniqueInput {
  @Field(() => Int, {
    nullable: true
  })
  idField?: number | undefined;

  @Field(() => String, {
    nullable: true
  })
  uniqueStringField?: string | undefined;

  @Field(() => [RenamedSecondModelWhereInput], {
    nullable: true
  })
  AND?: RenamedSecondModelWhereInput[] | undefined;

  @Field(() => [RenamedSecondModelWhereInput], {
    nullable: true
  })
  OR?: RenamedSecondModelWhereInput[] | undefined;

  @Field(() => [RenamedSecondModelWhereInput], {
    nullable: true
  })
  NOT?: RenamedSecondModelWhereInput[] | undefined;

  @Field(() => FloatFilter, {
    nullable: true
  })
  floatField?: FloatFilter | undefined;

  @Field(() => IntFilter, {
    nullable: true
  })
  firstModelFieldId?: IntFilter | undefined;

  @Field(() => FirstModelScalarRelationFilter, {
    nullable: true
  })
  firstModelField?: FirstModelScalarRelationFilter | undefined;
}
"
`;

exports[`inputs when model is renamed should properly generate input type classes for filtering models by one to many relation fields: index 1`] = `
"export * from \\"./FirstModelScalarRelationFilter\\";
export * from \\"./FloatFieldUpdateOperationsInput\\";
export * from \\"./FloatFilter\\";
export * from \\"./FloatWithAggregatesFilter\\";
export * from \\"./IntFieldUpdateOperationsInput\\";
export * from \\"./IntFilter\\";
export * from \\"./IntWithAggregatesFilter\\";
export * from \\"./NestedFloatFilter\\";
export * from \\"./NestedFloatWithAggregatesFilter\\";
export * from \\"./NestedIntFilter\\";
export * from \\"./NestedIntWithAggregatesFilter\\";
export * from \\"./NestedStringFilter\\";
export * from \\"./NestedStringWithAggregatesFilter\\";
export * from \\"./RenamedFirstModelAvgOrderByAggregateInput\\";
export * from \\"./RenamedFirstModelCountOrderByAggregateInput\\";
export * from \\"./RenamedFirstModelCreateInput\\";
export * from \\"./RenamedFirstModelCreateManyInput\\";
export * from \\"./RenamedFirstModelCreateNestedOneWithoutSecondModelsFieldInput\\";
export * from \\"./RenamedFirstModelCreateOrConnectWithoutSecondModelsFieldInput\\";
export * from \\"./RenamedFirstModelCreateWithoutSecondModelsFieldInput\\";
export * from \\"./RenamedFirstModelMaxOrderByAggregateInput\\";
export * from \\"./RenamedFirstModelMinOrderByAggregateInput\\";
export * from \\"./RenamedFirstModelOrderByWithAggregationInput\\";
export * from \\"./RenamedFirstModelOrderByWithRelationInput\\";
export * from \\"./RenamedFirstModelScalarWhereWithAggregatesInput\\";
export * from \\"./RenamedFirstModelSumOrderByAggregateInput\\";
export * from \\"./RenamedFirstModelUpdateInput\\";
export * from \\"./RenamedFirstModelUpdateManyMutationInput\\";
export * from \\"./RenamedFirstModelUpdateOneRequiredWithoutSecondModelsFieldNestedInput\\";
export * from \\"./RenamedFirstModelUpdateToOneWithWhereWithoutSecondModelsFieldInput\\";
export * from \\"./RenamedFirstModelUpdateWithoutSecondModelsFieldInput\\";
export * from \\"./RenamedFirstModelUpsertWithoutSecondModelsFieldInput\\";
export * from \\"./RenamedFirstModelWhereInput\\";
export * from \\"./RenamedFirstModelWhereUniqueInput\\";
export * from \\"./RenamedSecondModelAvgOrderByAggregateInput\\";
export * from \\"./RenamedSecondModelCountOrderByAggregateInput\\";
export * from \\"./RenamedSecondModelCreateInput\\";
export * from \\"./RenamedSecondModelCreateManyFirstModelFieldInput\\";
export * from \\"./RenamedSecondModelCreateManyFirstModelFieldInputEnvelope\\";
export * from \\"./RenamedSecondModelCreateManyInput\\";
export * from \\"./RenamedSecondModelCreateNestedManyWithoutFirstModelFieldInput\\";
export * from \\"./RenamedSecondModelCreateOrConnectWithoutFirstModelFieldInput\\";
export * from \\"./RenamedSecondModelCreateWithoutFirstModelFieldInput\\";
export * from \\"./RenamedSecondModelListRelationFilter\\";
export * from \\"./RenamedSecondModelMaxOrderByAggregateInput\\";
export * from \\"./RenamedSecondModelMinOrderByAggregateInput\\";
export * from \\"./RenamedSecondModelOrderByRelationAggregateInput\\";
export * from \\"./RenamedSecondModelOrderByWithAggregationInput\\";
export * from \\"./RenamedSecondModelOrderByWithRelationInput\\";
export * from \\"./RenamedSecondModelScalarWhereInput\\";
export * from \\"./RenamedSecondModelScalarWhereWithAggregatesInput\\";
export * from \\"./RenamedSecondModelSumOrderByAggregateInput\\";
export * from \\"./RenamedSecondModelUpdateInput\\";
export * from \\"./RenamedSecondModelUpdateManyMutationInput\\";
export * from \\"./RenamedSecondModelUpdateManyWithWhereWithoutFirstModelFieldInput\\";
export * from \\"./RenamedSecondModelUpdateManyWithoutFirstModelFieldNestedInput\\";
export * from \\"./RenamedSecondModelUpdateWithWhereUniqueWithoutFirstModelFieldInput\\";
export * from \\"./RenamedSecondModelUpdateWithoutFirstModelFieldInput\\";
export * from \\"./RenamedSecondModelUpsertWithWhereUniqueWithoutFirstModelFieldInput\\";
export * from \\"./RenamedSecondModelWhereInput\\";
export * from \\"./RenamedSecondModelWhereUniqueInput\\";
export * from \\"./StringFieldUpdateOperationsInput\\";
export * from \\"./StringFilter\\";
export * from \\"./StringWithAggregatesFilter\\";
"
`;

exports[`inputs when model is renamed should properly generate input type classes: ExampleOrderByWithRelationInput 1`] = `
"import { Args, ArgsType, Context, Field, Float, ID, Info, InputType, Int, Mutation, ObjectType, Parent, Query, ResolveField, Resolver, registerEnumType } from \\"@nestjs/graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { Prisma } from \\"../../../../helpers/prisma-client-mock\\";
import { DecimalJSScalar } from \\"../../scalars\\";
import { OtherModelOrderByWithRelationInput } from \\"../inputs\\";
import { SortOrder } from \\"../../enums/SortOrder\\";

@InputType(\\"ExampleOrderByWithRelationInput\\", {})
export class ExampleOrderByWithRelationInput {
  @Field(() => SortOrder, {
    nullable: true
  })
  intIdField?: \\"asc\\" | \\"desc\\" | undefined;

  @Field(() => SortOrder, {
    nullable: true
  })
  stringField?: \\"asc\\" | \\"desc\\" | undefined;

  @Field(() => SortOrder, {
    nullable: true
  })
  floatField?: \\"asc\\" | \\"desc\\" | undefined;

  @Field(() => SortOrder, {
    nullable: true
  })
  booleanField?: \\"asc\\" | \\"desc\\" | undefined;

  @Field(() => SortOrder, {
    nullable: true
  })
  dateField?: \\"asc\\" | \\"desc\\" | undefined;

  @Field(() => SortOrder, {
    nullable: true
  })
  otherId?: \\"asc\\" | \\"desc\\" | undefined;

  @Field(() => OtherModelOrderByWithRelationInput, {
    nullable: true
  })
  other?: OtherModelOrderByWithRelationInput | undefined;
}
"
`;

exports[`inputs when model is renamed should properly generate input type classes: ExampleWhereInput 1`] = `
"import { Args, ArgsType, Context, Field, Float, ID, Info, InputType, Int, Mutation, ObjectType, Parent, Query, ResolveField, Resolver, registerEnumType } from \\"@nestjs/graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { Prisma } from \\"../../../../helpers/prisma-client-mock\\";
import { DecimalJSScalar } from \\"../../scalars\\";
import { BoolFilter, DateTimeFilter, FloatFilter, IntFilter, OtherModelScalarRelationFilter, StringFilter } from \\"../inputs\\";

@InputType(\\"ExampleWhereInput\\", {})
export class ExampleWhereInput {
  @Field(() => [ExampleWhereInput], {
    nullable: true
  })
  AND?: ExampleWhereInput[] | undefined;

  @Field(() => [ExampleWhereInput], {
    nullable: true
  })
  OR?: ExampleWhereInput[] | undefined;

  @Field(() => [ExampleWhereInput], {
    nullable: true
  })
  NOT?: ExampleWhereInput[] | undefined;

  @Field(() => IntFilter, {
    nullable: true
  })
  intIdField?: IntFilter | undefined;

  @Field(() => StringFilter, {
    nullable: true
  })
  stringField?: StringFilter | undefined;

  @Field(() => FloatFilter, {
    nullable: true
  })
  floatField?: FloatFilter | undefined;

  @Field(() => BoolFilter, {
    nullable: true
  })
  booleanField?: BoolFilter | undefined;

  @Field(() => DateTimeFilter, {
    nullable: true
  })
  dateField?: DateTimeFilter | undefined;

  @Field(() => IntFilter, {
    nullable: true
  })
  otherId?: IntFilter | undefined;

  @Field(() => OtherModelScalarRelationFilter, {
    nullable: true
  })
  other?: OtherModelScalarRelationFilter | undefined;
}
"
`;

exports[`inputs when model is renamed should properly generate input type classes: ExampleWhereUniqueInput 1`] = `
"import { Args, ArgsType, Context, Field, Float, ID, Info, InputType, Int, Mutation, ObjectType, Parent, Query, ResolveField, Resolver, registerEnumType } from \\"@nestjs/graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { Prisma } from \\"../../../../helpers/prisma-client-mock\\";
import { DecimalJSScalar } from \\"../../scalars\\";
import { BoolFilter, DateTimeFilter, ExampleWhereInput, FloatFilter, IntFilter, OtherModelScalarRelationFilter } from \\"../inputs\\";

@InputType(\\"ExampleWhereUniqueInput\\", {})
export class ExampleWhereUniqueInput {
  @Field(() => Int, {
    nullable: true
  })
  intIdField?: number | undefined;

  @Field(() => String, {
    nullable: true
  })
  stringField?: string | undefined;

  @Field(() => [ExampleWhereInput], {
    nullable: true
  })
  AND?: ExampleWhereInput[] | undefined;

  @Field(() => [ExampleWhereInput], {
    nullable: true
  })
  OR?: ExampleWhereInput[] | undefined;

  @Field(() => [ExampleWhereInput], {
    nullable: true
  })
  NOT?: ExampleWhereInput[] | undefined;

  @Field(() => FloatFilter, {
    nullable: true
  })
  floatField?: FloatFilter | undefined;

  @Field(() => BoolFilter, {
    nullable: true
  })
  booleanField?: BoolFilter | undefined;

  @Field(() => DateTimeFilter, {
    nullable: true
  })
  dateField?: DateTimeFilter | undefined;

  @Field(() => IntFilter, {
    nullable: true
  })
  otherId?: IntFilter | undefined;

  @Field(() => OtherModelScalarRelationFilter, {
    nullable: true
  })
  other?: OtherModelScalarRelationFilter | undefined;
}
"
`;

exports[`inputs when model is renamed should properly generate input type classes: index 1`] = `
"export * from \\"./BoolFieldUpdateOperationsInput\\";
export * from \\"./BoolFilter\\";
export * from \\"./BoolWithAggregatesFilter\\";
export * from \\"./DateTimeFieldUpdateOperationsInput\\";
export * from \\"./DateTimeFilter\\";
export * from \\"./DateTimeWithAggregatesFilter\\";
export * from \\"./ExampleAvgOrderByAggregateInput\\";
export * from \\"./ExampleCountOrderByAggregateInput\\";
export * from \\"./ExampleCreateInput\\";
export * from \\"./ExampleCreateManyInput\\";
export * from \\"./ExampleCreateManyOtherInput\\";
export * from \\"./ExampleCreateManyOtherInputEnvelope\\";
export * from \\"./ExampleCreateNestedManyWithoutOtherInput\\";
export * from \\"./ExampleCreateOrConnectWithoutOtherInput\\";
export * from \\"./ExampleCreateWithoutOtherInput\\";
export * from \\"./ExampleListRelationFilter\\";
export * from \\"./ExampleMaxOrderByAggregateInput\\";
export * from \\"./ExampleMinOrderByAggregateInput\\";
export * from \\"./ExampleOrderByRelationAggregateInput\\";
export * from \\"./ExampleOrderByWithAggregationInput\\";
export * from \\"./ExampleOrderByWithRelationInput\\";
export * from \\"./ExampleScalarWhereInput\\";
export * from \\"./ExampleScalarWhereWithAggregatesInput\\";
export * from \\"./ExampleSumOrderByAggregateInput\\";
export * from \\"./ExampleUpdateInput\\";
export * from \\"./ExampleUpdateManyMutationInput\\";
export * from \\"./ExampleUpdateManyWithWhereWithoutOtherInput\\";
export * from \\"./ExampleUpdateManyWithoutOtherNestedInput\\";
export * from \\"./ExampleUpdateWithWhereUniqueWithoutOtherInput\\";
export * from \\"./ExampleUpdateWithoutOtherInput\\";
export * from \\"./ExampleUpsertWithWhereUniqueWithoutOtherInput\\";
export * from \\"./ExampleWhereInput\\";
export * from \\"./ExampleWhereUniqueInput\\";
export * from \\"./FloatFieldUpdateOperationsInput\\";
export * from \\"./FloatFilter\\";
export * from \\"./FloatWithAggregatesFilter\\";
export * from \\"./IntFieldUpdateOperationsInput\\";
export * from \\"./IntFilter\\";
export * from \\"./IntWithAggregatesFilter\\";
export * from \\"./NestedBoolFilter\\";
export * from \\"./NestedBoolWithAggregatesFilter\\";
export * from \\"./NestedDateTimeFilter\\";
export * from \\"./NestedDateTimeWithAggregatesFilter\\";
export * from \\"./NestedFloatFilter\\";
export * from \\"./NestedFloatWithAggregatesFilter\\";
export * from \\"./NestedIntFilter\\";
export * from \\"./NestedIntWithAggregatesFilter\\";
export * from \\"./NestedStringFilter\\";
export * from \\"./NestedStringWithAggregatesFilter\\";
export * from \\"./OtherModelAvgOrderByAggregateInput\\";
export * from \\"./OtherModelCountOrderByAggregateInput\\";
export * from \\"./OtherModelCreateInput\\";
export * from \\"./OtherModelCreateManyInput\\";
export * from \\"./OtherModelCreateNestedOneWithoutSampleModelInput\\";
export * from \\"./OtherModelCreateOrConnectWithoutSampleModelInput\\";
export * from \\"./OtherModelCreateWithoutSampleModelInput\\";
export * from \\"./OtherModelMaxOrderByAggregateInput\\";
export * from \\"./OtherModelMinOrderByAggregateInput\\";
export * from \\"./OtherModelOrderByWithAggregationInput\\";
export * from \\"./OtherModelOrderByWithRelationInput\\";
export * from \\"./OtherModelScalarRelationFilter\\";
export * from \\"./OtherModelScalarWhereWithAggregatesInput\\";
export * from \\"./OtherModelSumOrderByAggregateInput\\";
export * from \\"./OtherModelUpdateInput\\";
export * from \\"./OtherModelUpdateManyMutationInput\\";
export * from \\"./OtherModelUpdateOneRequiredWithoutSampleModelNestedInput\\";
export * from \\"./OtherModelUpdateToOneWithWhereWithoutSampleModelInput\\";
export * from \\"./OtherModelUpdateWithoutSampleModelInput\\";
export * from \\"./OtherModelUpsertWithoutSampleModelInput\\";
export * from \\"./OtherModelWhereInput\\";
export * from \\"./OtherModelWhereUniqueInput\\";
export * from \\"./StringFieldUpdateOperationsInput\\";
export * from \\"./StringFilter\\";
export * from \\"./StringWithAggregatesFilter\\";
"
`;

exports[`inputs when prisma client is generated into node_modules should properly generate prisma client imports in input type class files: SampleWhereInput 1`] = `
"import { Args, ArgsType, Context, Field, Float, ID, Info, InputType, Int, Mutation, ObjectType, Parent, Query, ResolveField, Resolver, registerEnumType } from \\"@nestjs/graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { Prisma } from \\"@prisma/client\\";
import { DecimalJSScalar } from \\"../../scalars\\";
import { IntFilter, StringFilter } from \\"../inputs\\";

@InputType(\\"SampleWhereInput\\", {})
export class SampleWhereInput {
  @Field(() => [SampleWhereInput], {
    nullable: true
  })
  AND?: SampleWhereInput[] | undefined;

  @Field(() => [SampleWhereInput], {
    nullable: true
  })
  OR?: SampleWhereInput[] | undefined;

  @Field(() => [SampleWhereInput], {
    nullable: true
  })
  NOT?: SampleWhereInput[] | undefined;

  @Field(() => IntFilter, {
    nullable: true
  })
  idField?: IntFilter | undefined;

  @Field(() => StringFilter, {
    nullable: true
  })
  modelFieldName?: StringFilter | undefined;
}
"
`;

exports[`inputs when prisma client is generated into node_modules should properly generate prisma client imports in input type class files: index 1`] = `
"export * from \\"./IntFieldUpdateOperationsInput\\";
export * from \\"./IntFilter\\";
export * from \\"./IntWithAggregatesFilter\\";
export * from \\"./NestedFloatFilter\\";
export * from \\"./NestedIntFilter\\";
export * from \\"./NestedIntWithAggregatesFilter\\";
export * from \\"./NestedStringFilter\\";
export * from \\"./NestedStringWithAggregatesFilter\\";
export * from \\"./SampleAvgOrderByAggregateInput\\";
export * from \\"./SampleCountOrderByAggregateInput\\";
export * from \\"./SampleCreateInput\\";
export * from \\"./SampleCreateManyInput\\";
export * from \\"./SampleMaxOrderByAggregateInput\\";
export * from \\"./SampleMinOrderByAggregateInput\\";
export * from \\"./SampleOrderByWithAggregationInput\\";
export * from \\"./SampleOrderByWithRelationInput\\";
export * from \\"./SampleScalarWhereWithAggregatesInput\\";
export * from \\"./SampleSumOrderByAggregateInput\\";
export * from \\"./SampleUpdateInput\\";
export * from \\"./SampleUpdateManyMutationInput\\";
export * from \\"./SampleWhereInput\\";
export * from \\"./SampleWhereUniqueInput\\";
export * from \\"./StringFieldUpdateOperationsInput\\";
export * from \\"./StringFilter\\";
export * from \\"./StringWithAggregatesFilter\\";
"
`;

exports[`inputs when useSimpleInputs config option is set to true should properly generate input type classes for updating scalar fields in postgres schema: SampleModelUpdateInput 1`] = `
"import { Args, ArgsType, Context, Field, Float, ID, Info, InputType, Int, Mutation, ObjectType, Parent, Query, ResolveField, Resolver, registerEnumType } from \\"@nestjs/graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { Prisma } from \\"../../../../helpers/prisma-client-mock\\";
import { DecimalJSScalar } from \\"../../scalars\\";
import { Color } from \\"../../enums/Color\\";

@InputType(\\"SampleModelUpdateInput\\", {})
export class SampleModelUpdateInput {
  @Field(() => String, {
    nullable: true
  })
  stringField?: string | undefined;

  @Field(() => String, {
    nullable: true
  })
  optionalStringField?: string | undefined;

  @Field(() => Int, {
    nullable: true
  })
  intField?: number | undefined;

  @Field(() => Int, {
    nullable: true
  })
  optionalIntField?: number | undefined;

  @Field(() => Float, {
    nullable: true
  })
  floatField?: number | undefined;

  @Field(() => Float, {
    nullable: true
  })
  optionalFloatField?: number | undefined;

  @Field(() => Boolean, {
    nullable: true
  })
  booleanField?: boolean | undefined;

  @Field(() => Boolean, {
    nullable: true
  })
  optionalBooleanField?: boolean | undefined;

  @Field(() => Date, {
    nullable: true
  })
  dateField?: Date | undefined;

  @Field(() => Date, {
    nullable: true
  })
  optionalDateField?: Date | undefined;

  @Field(() => GraphQLScalars.JSONResolver, {
    nullable: true
  })
  jsonField?: Prisma.InputJsonValue | undefined;

  @Field(() => GraphQLScalars.JSONResolver, {
    nullable: true
  })
  optionalJsonField?: Prisma.InputJsonValue | undefined;

  @Field(() => Color, {
    nullable: true
  })
  enumField?: \\"RED\\" | \\"GREEN\\" | \\"BLUE\\" | undefined;

  @Field(() => Color, {
    nullable: true
  })
  optionalEnumField?: \\"RED\\" | \\"GREEN\\" | \\"BLUE\\" | undefined;

  @Field(() => [Int], {
    nullable: true
  })
  intArrayField?: number[] | undefined;

  @Field(() => [String], {
    nullable: true
  })
  stringArrayField?: string[] | undefined;
}
"
`;

exports[`inputs when useSimpleInputs config option is set to true should properly generate input type classes for updating scalar fields in postgres schema: SampleModelUpdateManyMutationInput 1`] = `
"import { Args, ArgsType, Context, Field, Float, ID, Info, InputType, Int, Mutation, ObjectType, Parent, Query, ResolveField, Resolver, registerEnumType } from \\"@nestjs/graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { Prisma } from \\"../../../../helpers/prisma-client-mock\\";
import { DecimalJSScalar } from \\"../../scalars\\";
import { Color } from \\"../../enums/Color\\";

@InputType(\\"SampleModelUpdateManyMutationInput\\", {})
export class SampleModelUpdateManyMutationInput {
  @Field(() => String, {
    nullable: true
  })
  stringField?: string | undefined;

  @Field(() => String, {
    nullable: true
  })
  optionalStringField?: string | undefined;

  @Field(() => Int, {
    nullable: true
  })
  intField?: number | undefined;

  @Field(() => Int, {
    nullable: true
  })
  optionalIntField?: number | undefined;

  @Field(() => Float, {
    nullable: true
  })
  floatField?: number | undefined;

  @Field(() => Float, {
    nullable: true
  })
  optionalFloatField?: number | undefined;

  @Field(() => Boolean, {
    nullable: true
  })
  booleanField?: boolean | undefined;

  @Field(() => Boolean, {
    nullable: true
  })
  optionalBooleanField?: boolean | undefined;

  @Field(() => Date, {
    nullable: true
  })
  dateField?: Date | undefined;

  @Field(() => Date, {
    nullable: true
  })
  optionalDateField?: Date | undefined;

  @Field(() => GraphQLScalars.JSONResolver, {
    nullable: true
  })
  jsonField?: Prisma.InputJsonValue | undefined;

  @Field(() => GraphQLScalars.JSONResolver, {
    nullable: true
  })
  optionalJsonField?: Prisma.InputJsonValue | undefined;

  @Field(() => Color, {
    nullable: true
  })
  enumField?: \\"RED\\" | \\"GREEN\\" | \\"BLUE\\" | undefined;

  @Field(() => Color, {
    nullable: true
  })
  optionalEnumField?: \\"RED\\" | \\"GREEN\\" | \\"BLUE\\" | undefined;

  @Field(() => [Int], {
    nullable: true
  })
  intArrayField?: number[] | undefined;

  @Field(() => [String], {
    nullable: true
  })
  stringArrayField?: string[] | undefined;
}
"
`;

exports[`inputs when useSimpleInputs config option is set to true should properly generate input type classes for updating scalar fields in postgres schema: index 1`] = `
"export * from \\"./BoolFieldUpdateOperationsInput\\";
export * from \\"./BoolFilter\\";
export * from \\"./BoolNullableFilter\\";
export * from \\"./BoolNullableWithAggregatesFilter\\";
export * from \\"./BoolWithAggregatesFilter\\";
export * from \\"./DateTimeFieldUpdateOperationsInput\\";
export * from \\"./DateTimeFilter\\";
export * from \\"./DateTimeNullableFilter\\";
export * from \\"./DateTimeNullableWithAggregatesFilter\\";
export * from \\"./DateTimeWithAggregatesFilter\\";
export * from \\"./EnumColorFieldUpdateOperationsInput\\";
export * from \\"./EnumColorFilter\\";
export * from \\"./EnumColorNullableFilter\\";
export * from \\"./EnumColorNullableWithAggregatesFilter\\";
export * from \\"./EnumColorWithAggregatesFilter\\";
export * from \\"./FloatFieldUpdateOperationsInput\\";
export * from \\"./FloatFilter\\";
export * from \\"./FloatNullableFilter\\";
export * from \\"./FloatNullableWithAggregatesFilter\\";
export * from \\"./FloatWithAggregatesFilter\\";
export * from \\"./IntFieldUpdateOperationsInput\\";
export * from \\"./IntFilter\\";
export * from \\"./IntNullableFilter\\";
export * from \\"./IntNullableListFilter\\";
export * from \\"./IntNullableWithAggregatesFilter\\";
export * from \\"./IntWithAggregatesFilter\\";
export * from \\"./JsonFilter\\";
export * from \\"./JsonNullableFilter\\";
export * from \\"./JsonNullableWithAggregatesFilter\\";
export * from \\"./JsonWithAggregatesFilter\\";
export * from \\"./NestedBoolFilter\\";
export * from \\"./NestedBoolNullableFilter\\";
export * from \\"./NestedBoolNullableWithAggregatesFilter\\";
export * from \\"./NestedBoolWithAggregatesFilter\\";
export * from \\"./NestedDateTimeFilter\\";
export * from \\"./NestedDateTimeNullableFilter\\";
export * from \\"./NestedDateTimeNullableWithAggregatesFilter\\";
export * from \\"./NestedDateTimeWithAggregatesFilter\\";
export * from \\"./NestedEnumColorFilter\\";
export * from \\"./NestedEnumColorNullableFilter\\";
export * from \\"./NestedEnumColorNullableWithAggregatesFilter\\";
export * from \\"./NestedEnumColorWithAggregatesFilter\\";
export * from \\"./NestedFloatFilter\\";
export * from \\"./NestedFloatNullableFilter\\";
export * from \\"./NestedFloatNullableWithAggregatesFilter\\";
export * from \\"./NestedFloatWithAggregatesFilter\\";
export * from \\"./NestedIntFilter\\";
export * from \\"./NestedIntNullableFilter\\";
export * from \\"./NestedIntNullableWithAggregatesFilter\\";
export * from \\"./NestedIntWithAggregatesFilter\\";
export * from \\"./NestedJsonFilter\\";
export * from \\"./NestedJsonNullableFilter\\";
export * from \\"./NestedStringFilter\\";
export * from \\"./NestedStringNullableFilter\\";
export * from \\"./NestedStringNullableWithAggregatesFilter\\";
export * from \\"./NestedStringWithAggregatesFilter\\";
export * from \\"./NullableBoolFieldUpdateOperationsInput\\";
export * from \\"./NullableDateTimeFieldUpdateOperationsInput\\";
export * from \\"./NullableEnumColorFieldUpdateOperationsInput\\";
export * from \\"./NullableFloatFieldUpdateOperationsInput\\";
export * from \\"./NullableIntFieldUpdateOperationsInput\\";
export * from \\"./NullableStringFieldUpdateOperationsInput\\";
export * from \\"./SampleModelAvgOrderByAggregateInput\\";
export * from \\"./SampleModelCountOrderByAggregateInput\\";
export * from \\"./SampleModelCreateInput\\";
export * from \\"./SampleModelCreateManyInput\\";
export * from \\"./SampleModelCreateintArrayFieldInput\\";
export * from \\"./SampleModelCreatestringArrayFieldInput\\";
export * from \\"./SampleModelMaxOrderByAggregateInput\\";
export * from \\"./SampleModelMinOrderByAggregateInput\\";
export * from \\"./SampleModelOrderByWithAggregationInput\\";
export * from \\"./SampleModelOrderByWithRelationInput\\";
export * from \\"./SampleModelScalarWhereWithAggregatesInput\\";
export * from \\"./SampleModelSumOrderByAggregateInput\\";
export * from \\"./SampleModelUpdateInput\\";
export * from \\"./SampleModelUpdateManyMutationInput\\";
export * from \\"./SampleModelUpdateintArrayFieldInput\\";
export * from \\"./SampleModelUpdatestringArrayFieldInput\\";
export * from \\"./SampleModelWhereInput\\";
export * from \\"./SampleModelWhereUniqueInput\\";
export * from \\"./SortOrderInput\\";
export * from \\"./StringFieldUpdateOperationsInput\\";
export * from \\"./StringFilter\\";
export * from \\"./StringNullableFilter\\";
export * from \\"./StringNullableListFilter\\";
export * from \\"./StringNullableWithAggregatesFilter\\";
export * from \\"./StringWithAggregatesFilter\\";
"
`;

exports[`inputs when useUncheckedScalarInputs mode is enabled should properly generate input type classes for filtering models by one to many relation fields: FirstModelCreateNestedOneWithoutSecondModelsFieldInput 1`] = `
"import { Args, ArgsType, Context, Field, Float, ID, Info, InputType, Int, Mutation, ObjectType, Parent, Query, ResolveField, Resolver, registerEnumType } from \\"@nestjs/graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { Prisma } from \\"../../../../helpers/prisma-client-mock\\";
import { DecimalJSScalar } from \\"../../scalars\\";
import { FirstModelCreateOrConnectWithoutSecondModelsFieldInput, FirstModelUncheckedCreateWithoutSecondModelsFieldInput, FirstModelWhereUniqueInput } from \\"../inputs\\";

@InputType(\\"FirstModelCreateNestedOneWithoutSecondModelsFieldInput\\", {})
export class FirstModelCreateNestedOneWithoutSecondModelsFieldInput {
  @Field(() => FirstModelUncheckedCreateWithoutSecondModelsFieldInput, {
    nullable: true
  })
  create?: FirstModelUncheckedCreateWithoutSecondModelsFieldInput | undefined;

  @Field(() => FirstModelCreateOrConnectWithoutSecondModelsFieldInput, {
    nullable: true
  })
  connectOrCreate?: FirstModelCreateOrConnectWithoutSecondModelsFieldInput | undefined;

  @Field(() => FirstModelWhereUniqueInput, {
    nullable: true
  })
  connect?: FirstModelWhereUniqueInput | undefined;
}
"
`;

exports[`inputs when useUncheckedScalarInputs mode is enabled should properly generate input type classes for filtering models by one to many relation fields: FirstModelCreateOrConnectWithoutSecondModelsFieldInput 1`] = `
"import { Args, ArgsType, Context, Field, Float, ID, Info, InputType, Int, Mutation, ObjectType, Parent, Query, ResolveField, Resolver, registerEnumType } from \\"@nestjs/graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { Prisma } from \\"../../../../helpers/prisma-client-mock\\";
import { DecimalJSScalar } from \\"../../scalars\\";
import { FirstModelUncheckedCreateWithoutSecondModelsFieldInput, FirstModelWhereUniqueInput } from \\"../inputs\\";

@InputType(\\"FirstModelCreateOrConnectWithoutSecondModelsFieldInput\\", {})
export class FirstModelCreateOrConnectWithoutSecondModelsFieldInput {
  @Field(() => FirstModelWhereUniqueInput, {
    nullable: false
  })
  where!: FirstModelWhereUniqueInput;

  @Field(() => FirstModelUncheckedCreateWithoutSecondModelsFieldInput, {
    nullable: false
  })
  create!: FirstModelUncheckedCreateWithoutSecondModelsFieldInput;
}
"
`;

exports[`inputs when useUncheckedScalarInputs mode is enabled should properly generate input type classes for filtering models by one to many relation fields: FirstModelCreateWithoutSecondModelsFieldInputTSFile 1`] = `
"import { Args, ArgsType, Context, Field, Float, ID, Info, InputType, Int, Mutation, ObjectType, Parent, Query, ResolveField, Resolver, registerEnumType } from \\"@nestjs/graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { Prisma } from \\"../../../../helpers/prisma-client-mock\\";
import { DecimalJSScalar } from \\"../../scalars\\";

@InputType(\\"FirstModelCreateWithoutSecondModelsFieldInput\\", {})
export class FirstModelCreateWithoutSecondModelsFieldInput {
  @Field(() => String, {
    nullable: false
  })
  uniqueStringField!: string;

  @Field(() => Float, {
    nullable: false
  })
  floatField!: number;
}
"
`;

exports[`inputs when useUncheckedScalarInputs mode is enabled should properly generate input type classes for filtering models by one to many relation fields: FirstModelUncheckedCreateInput 1`] = `
"import { Args, ArgsType, Context, Field, Float, ID, Info, InputType, Int, Mutation, ObjectType, Parent, Query, ResolveField, Resolver, registerEnumType } from \\"@nestjs/graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { Prisma } from \\"../../../../helpers/prisma-client-mock\\";
import { DecimalJSScalar } from \\"../../scalars\\";
import { SecondModelUncheckedCreateNestedManyWithoutFirstModelFieldInput } from \\"../inputs\\";

@InputType(\\"FirstModelUncheckedCreateInput\\", {})
export class FirstModelUncheckedCreateInput {
  @Field(() => Int, {
    nullable: true
  })
  idField?: number | undefined;

  @Field(() => String, {
    nullable: false
  })
  uniqueStringField!: string;

  @Field(() => Float, {
    nullable: false
  })
  floatField!: number;

  @Field(() => SecondModelUncheckedCreateNestedManyWithoutFirstModelFieldInput, {
    nullable: true
  })
  secondModelsField?: SecondModelUncheckedCreateNestedManyWithoutFirstModelFieldInput | undefined;
}
"
`;

exports[`inputs when useUncheckedScalarInputs mode is enabled should properly generate input type classes for filtering models by one to many relation fields: FirstModelUncheckedCreateWithoutSecondModelsFieldInput 1`] = `
"import { Args, ArgsType, Context, Field, Float, ID, Info, InputType, Int, Mutation, ObjectType, Parent, Query, ResolveField, Resolver, registerEnumType } from \\"@nestjs/graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { Prisma } from \\"../../../../helpers/prisma-client-mock\\";
import { DecimalJSScalar } from \\"../../scalars\\";

@InputType(\\"FirstModelUncheckedCreateWithoutSecondModelsFieldInput\\", {})
export class FirstModelUncheckedCreateWithoutSecondModelsFieldInput {
  @Field(() => Int, {
    nullable: true
  })
  idField?: number | undefined;

  @Field(() => String, {
    nullable: false
  })
  uniqueStringField!: string;

  @Field(() => Float, {
    nullable: false
  })
  floatField!: number;
}
"
`;

exports[`inputs when useUncheckedScalarInputs mode is enabled should properly generate input type classes for filtering models by one to many relation fields: FirstModelUncheckedUpdateInput 1`] = `
"import { Args, ArgsType, Context, Field, Float, ID, Info, InputType, Int, Mutation, ObjectType, Parent, Query, ResolveField, Resolver, registerEnumType } from \\"@nestjs/graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { Prisma } from \\"../../../../helpers/prisma-client-mock\\";
import { DecimalJSScalar } from \\"../../scalars\\";
import { FloatFieldUpdateOperationsInput, IntFieldUpdateOperationsInput, SecondModelUncheckedUpdateManyWithoutFirstModelFieldNestedInput, StringFieldUpdateOperationsInput } from \\"../inputs\\";

@InputType(\\"FirstModelUncheckedUpdateInput\\", {})
export class FirstModelUncheckedUpdateInput {
  @Field(() => IntFieldUpdateOperationsInput, {
    nullable: true
  })
  idField?: IntFieldUpdateOperationsInput | undefined;

  @Field(() => StringFieldUpdateOperationsInput, {
    nullable: true
  })
  uniqueStringField?: StringFieldUpdateOperationsInput | undefined;

  @Field(() => FloatFieldUpdateOperationsInput, {
    nullable: true
  })
  floatField?: FloatFieldUpdateOperationsInput | undefined;

  @Field(() => SecondModelUncheckedUpdateManyWithoutFirstModelFieldNestedInput, {
    nullable: true
  })
  secondModelsField?: SecondModelUncheckedUpdateManyWithoutFirstModelFieldNestedInput | undefined;
}
"
`;

exports[`inputs when useUncheckedScalarInputs mode is enabled should properly generate input type classes for filtering models by one to many relation fields: FirstModelUncheckedUpdateManyInput 1`] = `
"import { Args, ArgsType, Context, Field, Float, ID, Info, InputType, Int, Mutation, ObjectType, Parent, Query, ResolveField, Resolver, registerEnumType } from \\"@nestjs/graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { Prisma } from \\"../../../../helpers/prisma-client-mock\\";
import { DecimalJSScalar } from \\"../../scalars\\";
import { FloatFieldUpdateOperationsInput, IntFieldUpdateOperationsInput, StringFieldUpdateOperationsInput } from \\"../inputs\\";

@InputType(\\"FirstModelUncheckedUpdateManyInput\\", {})
export class FirstModelUncheckedUpdateManyInput {
  @Field(() => IntFieldUpdateOperationsInput, {
    nullable: true
  })
  idField?: IntFieldUpdateOperationsInput | undefined;

  @Field(() => StringFieldUpdateOperationsInput, {
    nullable: true
  })
  uniqueStringField?: StringFieldUpdateOperationsInput | undefined;

  @Field(() => FloatFieldUpdateOperationsInput, {
    nullable: true
  })
  floatField?: FloatFieldUpdateOperationsInput | undefined;
}
"
`;

exports[`inputs when useUncheckedScalarInputs mode is enabled should properly generate input type classes for filtering models by one to many relation fields: FirstModelUncheckedUpdateWithoutSecondModelsFieldInput 1`] = `
"import { Args, ArgsType, Context, Field, Float, ID, Info, InputType, Int, Mutation, ObjectType, Parent, Query, ResolveField, Resolver, registerEnumType } from \\"@nestjs/graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { Prisma } from \\"../../../../helpers/prisma-client-mock\\";
import { DecimalJSScalar } from \\"../../scalars\\";
import { FloatFieldUpdateOperationsInput, IntFieldUpdateOperationsInput, StringFieldUpdateOperationsInput } from \\"../inputs\\";

@InputType(\\"FirstModelUncheckedUpdateWithoutSecondModelsFieldInput\\", {})
export class FirstModelUncheckedUpdateWithoutSecondModelsFieldInput {
  @Field(() => IntFieldUpdateOperationsInput, {
    nullable: true
  })
  idField?: IntFieldUpdateOperationsInput | undefined;

  @Field(() => StringFieldUpdateOperationsInput, {
    nullable: true
  })
  uniqueStringField?: StringFieldUpdateOperationsInput | undefined;

  @Field(() => FloatFieldUpdateOperationsInput, {
    nullable: true
  })
  floatField?: FloatFieldUpdateOperationsInput | undefined;
}
"
`;

exports[`inputs when useUncheckedScalarInputs mode is enabled should properly generate input type classes for filtering models by one to many relation fields: FirstModelUpdateOneRequiredWithoutSecondModelsFieldNestedInput 1`] = `
"import { Args, ArgsType, Context, Field, Float, ID, Info, InputType, Int, Mutation, ObjectType, Parent, Query, ResolveField, Resolver, registerEnumType } from \\"@nestjs/graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { Prisma } from \\"../../../../helpers/prisma-client-mock\\";
import { DecimalJSScalar } from \\"../../scalars\\";
import { FirstModelCreateOrConnectWithoutSecondModelsFieldInput, FirstModelUncheckedCreateWithoutSecondModelsFieldInput, FirstModelUncheckedUpdateWithoutSecondModelsFieldInput, FirstModelUpsertWithoutSecondModelsFieldInput, FirstModelWhereUniqueInput } from \\"../inputs\\";

@InputType(\\"FirstModelUpdateOneRequiredWithoutSecondModelsFieldNestedInput\\", {})
export class FirstModelUpdateOneRequiredWithoutSecondModelsFieldNestedInput {
  @Field(() => FirstModelUncheckedCreateWithoutSecondModelsFieldInput, {
    nullable: true
  })
  create?: FirstModelUncheckedCreateWithoutSecondModelsFieldInput | undefined;

  @Field(() => FirstModelCreateOrConnectWithoutSecondModelsFieldInput, {
    nullable: true
  })
  connectOrCreate?: FirstModelCreateOrConnectWithoutSecondModelsFieldInput | undefined;

  @Field(() => FirstModelUpsertWithoutSecondModelsFieldInput, {
    nullable: true
  })
  upsert?: FirstModelUpsertWithoutSecondModelsFieldInput | undefined;

  @Field(() => FirstModelWhereUniqueInput, {
    nullable: true
  })
  connect?: FirstModelWhereUniqueInput | undefined;

  @Field(() => FirstModelUncheckedUpdateWithoutSecondModelsFieldInput, {
    nullable: true
  })
  update?: FirstModelUncheckedUpdateWithoutSecondModelsFieldInput | undefined;
}
"
`;

exports[`inputs when useUncheckedScalarInputs mode is enabled should properly generate input type classes for filtering models by one to many relation fields: FirstModelUpdateWithoutSecondModelsFieldInputTSFile 1`] = `
"import { Args, ArgsType, Context, Field, Float, ID, Info, InputType, Int, Mutation, ObjectType, Parent, Query, ResolveField, Resolver, registerEnumType } from \\"@nestjs/graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { Prisma } from \\"../../../../helpers/prisma-client-mock\\";
import { DecimalJSScalar } from \\"../../scalars\\";
import { FloatFieldUpdateOperationsInput, StringFieldUpdateOperationsInput } from \\"../inputs\\";

@InputType(\\"FirstModelUpdateWithoutSecondModelsFieldInput\\", {})
export class FirstModelUpdateWithoutSecondModelsFieldInput {
  @Field(() => StringFieldUpdateOperationsInput, {
    nullable: true
  })
  uniqueStringField?: StringFieldUpdateOperationsInput | undefined;

  @Field(() => FloatFieldUpdateOperationsInput, {
    nullable: true
  })
  floatField?: FloatFieldUpdateOperationsInput | undefined;
}
"
`;

exports[`inputs when useUncheckedScalarInputs mode is enabled should properly generate input type classes for filtering models by one to many relation fields: FirstModelUpsertWithoutSecondModelsFieldInputTSFile 1`] = `
"import { Args, ArgsType, Context, Field, Float, ID, Info, InputType, Int, Mutation, ObjectType, Parent, Query, ResolveField, Resolver, registerEnumType } from \\"@nestjs/graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { Prisma } from \\"../../../../helpers/prisma-client-mock\\";
import { DecimalJSScalar } from \\"../../scalars\\";
import { FirstModelUncheckedCreateWithoutSecondModelsFieldInput, FirstModelUncheckedUpdateWithoutSecondModelsFieldInput, FirstModelWhereInput } from \\"../inputs\\";

@InputType(\\"FirstModelUpsertWithoutSecondModelsFieldInput\\", {})
export class FirstModelUpsertWithoutSecondModelsFieldInput {
  @Field(() => FirstModelUncheckedUpdateWithoutSecondModelsFieldInput, {
    nullable: false
  })
  update!: FirstModelUncheckedUpdateWithoutSecondModelsFieldInput;

  @Field(() => FirstModelUncheckedCreateWithoutSecondModelsFieldInput, {
    nullable: false
  })
  create!: FirstModelUncheckedCreateWithoutSecondModelsFieldInput;

  @Field(() => FirstModelWhereInput, {
    nullable: true
  })
  where?: FirstModelWhereInput | undefined;
}
"
`;

exports[`inputs when useUncheckedScalarInputs mode is enabled should properly generate input type classes for filtering models by one to many relation fields: index 1`] = `
"export * from \\"./FirstModelAvgOrderByAggregateInput\\";
export * from \\"./FirstModelCountOrderByAggregateInput\\";
export * from \\"./FirstModelCreateInput\\";
export * from \\"./FirstModelCreateManyInput\\";
export * from \\"./FirstModelCreateNestedOneWithoutSecondModelsFieldInput\\";
export * from \\"./FirstModelCreateOrConnectWithoutSecondModelsFieldInput\\";
export * from \\"./FirstModelCreateWithoutSecondModelsFieldInput\\";
export * from \\"./FirstModelMaxOrderByAggregateInput\\";
export * from \\"./FirstModelMinOrderByAggregateInput\\";
export * from \\"./FirstModelOrderByWithAggregationInput\\";
export * from \\"./FirstModelOrderByWithRelationInput\\";
export * from \\"./FirstModelScalarRelationFilter\\";
export * from \\"./FirstModelScalarWhereWithAggregatesInput\\";
export * from \\"./FirstModelSumOrderByAggregateInput\\";
export * from \\"./FirstModelUncheckedCreateInput\\";
export * from \\"./FirstModelUncheckedCreateWithoutSecondModelsFieldInput\\";
export * from \\"./FirstModelUncheckedUpdateInput\\";
export * from \\"./FirstModelUncheckedUpdateManyInput\\";
export * from \\"./FirstModelUncheckedUpdateWithoutSecondModelsFieldInput\\";
export * from \\"./FirstModelUpdateInput\\";
export * from \\"./FirstModelUpdateManyMutationInput\\";
export * from \\"./FirstModelUpdateOneRequiredWithoutSecondModelsFieldNestedInput\\";
export * from \\"./FirstModelUpdateToOneWithWhereWithoutSecondModelsFieldInput\\";
export * from \\"./FirstModelUpdateWithoutSecondModelsFieldInput\\";
export * from \\"./FirstModelUpsertWithoutSecondModelsFieldInput\\";
export * from \\"./FirstModelWhereInput\\";
export * from \\"./FirstModelWhereUniqueInput\\";
export * from \\"./FloatFieldUpdateOperationsInput\\";
export * from \\"./FloatFilter\\";
export * from \\"./FloatWithAggregatesFilter\\";
export * from \\"./IntFieldUpdateOperationsInput\\";
export * from \\"./IntFilter\\";
export * from \\"./IntWithAggregatesFilter\\";
export * from \\"./NestedFloatFilter\\";
export * from \\"./NestedFloatWithAggregatesFilter\\";
export * from \\"./NestedIntFilter\\";
export * from \\"./NestedIntWithAggregatesFilter\\";
export * from \\"./NestedStringFilter\\";
export * from \\"./NestedStringWithAggregatesFilter\\";
export * from \\"./SecondModelAvgOrderByAggregateInput\\";
export * from \\"./SecondModelCountOrderByAggregateInput\\";
export * from \\"./SecondModelCreateInput\\";
export * from \\"./SecondModelCreateManyFirstModelFieldInput\\";
export * from \\"./SecondModelCreateManyFirstModelFieldInputEnvelope\\";
export * from \\"./SecondModelCreateManyInput\\";
export * from \\"./SecondModelCreateNestedManyWithoutFirstModelFieldInput\\";
export * from \\"./SecondModelCreateOrConnectWithoutFirstModelFieldInput\\";
export * from \\"./SecondModelCreateWithoutFirstModelFieldInput\\";
export * from \\"./SecondModelListRelationFilter\\";
export * from \\"./SecondModelMaxOrderByAggregateInput\\";
export * from \\"./SecondModelMinOrderByAggregateInput\\";
export * from \\"./SecondModelOrderByRelationAggregateInput\\";
export * from \\"./SecondModelOrderByWithAggregationInput\\";
export * from \\"./SecondModelOrderByWithRelationInput\\";
export * from \\"./SecondModelScalarWhereInput\\";
export * from \\"./SecondModelScalarWhereWithAggregatesInput\\";
export * from \\"./SecondModelSumOrderByAggregateInput\\";
export * from \\"./SecondModelUncheckedCreateInput\\";
export * from \\"./SecondModelUncheckedCreateNestedManyWithoutFirstModelFieldInput\\";
export * from \\"./SecondModelUncheckedCreateWithoutFirstModelFieldInput\\";
export * from \\"./SecondModelUncheckedUpdateInput\\";
export * from \\"./SecondModelUncheckedUpdateManyInput\\";
export * from \\"./SecondModelUncheckedUpdateManyWithoutFirstModelFieldInput\\";
export * from \\"./SecondModelUncheckedUpdateManyWithoutFirstModelFieldNestedInput\\";
export * from \\"./SecondModelUncheckedUpdateWithoutFirstModelFieldInput\\";
export * from \\"./SecondModelUpdateInput\\";
export * from \\"./SecondModelUpdateManyMutationInput\\";
export * from \\"./SecondModelUpdateManyWithWhereWithoutFirstModelFieldInput\\";
export * from \\"./SecondModelUpdateManyWithoutFirstModelFieldNestedInput\\";
export * from \\"./SecondModelUpdateWithWhereUniqueWithoutFirstModelFieldInput\\";
export * from \\"./SecondModelUpdateWithoutFirstModelFieldInput\\";
export * from \\"./SecondModelUpsertWithWhereUniqueWithoutFirstModelFieldInput\\";
export * from \\"./SecondModelWhereInput\\";
export * from \\"./SecondModelWhereUniqueInput\\";
export * from \\"./StringFieldUpdateOperationsInput\\";
export * from \\"./StringFilter\\";
export * from \\"./StringWithAggregatesFilter\\";
"
`;
